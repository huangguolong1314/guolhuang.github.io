<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySql学习 —— 子查询(where、from、exists) 及 连接查询(left join、right join、inner join、union join)</title>
      <link href="/2022/02/09/mySql%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/02/09/mySql%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li>子查询<ul><li>1、where型子查询：把内层查询的结果作为外层查询的比较条件</li><li>2、from型子查询：把内层的查询结果当成临时表，供外层sql再次查询。查询结果集可以当成表看待。临时表要使用一个别名</li><li>3、exists型子查询：把外层sql的结果，拿到内层sql去测试，如果内层的sql成立，则该行取出。内层查询是exists后的查询</li><li>4、any，in子查询</li><li>5、子查询总结</li></ul></li><li>连接查询<ul><li>1、全相乘（不是全连接、连接查询），全相乘是做笛卡尔积</li><li>2、左连接查询 left join … on …</li><li>3、右连接查询 right join … on …</li><li>4、内连接 inner join … on …</li><li>5、全连接 full join … on …</li><li>6、联合查询 union</li><li>7、连接查询总结</li></ul></li></ul><hr><p><code>注：该mysql系列博客仅为个人学习笔记。</code></p><p>使用goods表来练习子查询，表结构如下：<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/1.png" alt=""></p><p>所有数据(cat_id与category.cat_id关联)：<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/2.png" alt=""></p><p>类别表：<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/3.png" alt=""></p><p>mingoods(连接查询时作测试)：<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/4.png" alt=""></p><hr><h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><h3 id="1、where型子查询：把内层查询的结果作为外层查询的比较条件"><a href="#1、where型子查询：把内层查询的结果作为外层查询的比较条件" class="headerlink" title="1、where型子查询：把内层查询的结果作为外层查询的比较条件"></a>1、<code>where型子查询：把内层查询的结果作为外层查询的比较条件</code></h3><p>1.1 查询id最大的一件商品（使用排序+分页实现）<br>    mysql&gt; SELECT goods_id,goods_name,shop_price FROM goods ORDER BY goods_id DESC LIMIT 1;<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/5.png" alt=""></p><p>1.2 查询id最大的一件商品（使用where子查询实现）<br>    mysql&gt; SELECT goods_id,goods_name,shop_price FROM goods WHERE goods_id = (SELECT MAX(goods_id) FROM goods);<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/6.png" alt=""></p><p>1.3 查询每个类别下id最大的商品（使用where子查询实现）<br>    mysql&gt; SELECT goods_id,goods_name,cat_id,shop_price FROM goods WHERE goods_id IN (SELECT MAX(goods_id) FROM goods GROUP BY cat_id);<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/7.png" alt=""></p><h3 id="2、from型子查询：把内层的查询结果当成临时表，供外层sql再次查询。查询结果集可以当成表看待。临时表要使用一个别名。"><a href="#2、from型子查询：把内层的查询结果当成临时表，供外层sql再次查询。查询结果集可以当成表看待。临时表要使用一个别名。" class="headerlink" title="2、from型子查询：把内层的查询结果当成临时表，供外层sql再次查询。查询结果集可以当成表看待。临时表要使用一个别名。"></a>2、<code>from型子查询：把内层的查询结果当成临时表，供外层sql再次查询。查询结果集可以当成表看待。临时表要使用一个别名。</code></h3><p>2.1 查询每个类别下id最大的商品（使用from型子查询）<br>    mysql&gt; SELECT goods_id,goods_name,cat_id,shop_price FROM (SELECT goods_id,goods_name,cat_id,shop_price FROM goods ORDER BY cat_id ASC,goods_id DESC) AS tmp GROUP BY cat_id;<br>    子查询查出的结果集看第二张图，可以看到每个类别的第一条商品的id都为该类别下的最大值。然后将这个结果集作为一张临时表，巧妙的使用group by 查询出每个类别下的第一条记录，即为每个类别下商品id最大。<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/8.png" alt=""><br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/9.png" alt=""></p><h3 id="3、exists型子查询：把外层sql的结果，拿到内层sql去测试，如果内层的sql成立，则该行取出。内层查询是exists后的查询。"><a href="#3、exists型子查询：把外层sql的结果，拿到内层sql去测试，如果内层的sql成立，则该行取出。内层查询是exists后的查询。" class="headerlink" title="3、exists型子查询：把外层sql的结果，拿到内层sql去测试，如果内层的sql成立，则该行取出。内层查询是exists后的查询。"></a>3、<code>exists型子查询：把外层sql的结果，拿到内层sql去测试，如果内层的sql成立，则该行取出。内层查询是exists后的查询。</code></h3><p>3.1 从类别表中取出其类别下有商品的类别（如果改类别下没有商品，则不取出），（使用where子查询）<br>    mysql&gt; SELECT c.cat_id,c.cat_name FROM category c WHERE c.cat_id IN (SELECT g.cat_id FROM goods g GROUP BY g.cat_id);<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/10.png" alt=""></p><p>3.2 从类别表中取出其类别下有商品的类别（如果该类别下没有商品，则不取出），（使用exists子查询）<br>    mysql&gt; SELECT c.cat_id,c.cat_name FROM category c WHERE EXISTS (SELECT 1 FROM goods g WHERE g.cat_id = c.cat_id);<br>    exists子查询，如果exists后的内层查询能查询出数据，则表示存在；为空则不存在。<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/11.png" alt=""></p><h3 id="4、-any，in-子查询"><a href="#4、-any，in-子查询" class="headerlink" title="4、 any，in 子查询"></a>4、 <code>any，in 子查询</code></h3><p><code>用一张数字表作为子查询</code><br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/12.png" alt=""></p><p>4.1 使用 any 查出类别大于任何一个num值的类别。<br>    ANY关键词必须后面接一个比较操作符。ANY关键词的意思是“对于在子查询返回的列中的任一数值，如果比较结果为TRUE的话，则返回TRUE”。<br>    mysql&gt; SELECT cat_id,cat_name FROM category WHERE cat_id &gt; ANY (SELECT num FROM nums);<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/13.png" alt=""></p><p>4.2 使用 in 查出cat_id 等于 num 的类别<br>    mysql&gt; SELECT cat_id,cat_name FROM category WHERE cat_id IN (SELECT num FROM nums);<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/14.png" alt=""></p><p>4.3 in 的效果跟 =any 的效果是一样的<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/15.png" alt=""></p><p>4.4 使用 all 查询<br>    词语ALL必须接在一个比较操作符的后面。ALL的意思是“对于子查询返回的列中的所有值，如果比较结果为TRUE，则返回TRUE。”<br>    mysql&gt; SELECT cat_id,cat_name FROM category WHERE cat_id &gt; ALL (SELECT num FROM nums);<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/16.png" alt=""></p><p>4.5 not in 和 &lt;&gt; any 的效果是一样的<br>    NOT IN 不是 &lt;&gt; ANY 的别名，但是是<code>&lt;&gt; ALL的别名</code><br>    mysql&gt; SELECT cat_id,cat_name FROM category WHERE cat_id NOT IN (SELECT num FROM nums);<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/17.png" alt=""></p><h3 id="5、子查询总结"><a href="#5、子查询总结" class="headerlink" title="5、子查询总结"></a>5、<code>子查询总结</code></h3><p>5.1 where型子查询：把内层查询的结果作为外层查询的比较条件。<br>5.2 from型子查询：把内层的查询结果当成临时表，供外层sql再次查询。查询结果集可以当成表看待，<code>临时表需要一个别名</code>。<br>5.3  exists型子查询：把外层sql的结果，拿到内层sql去测试，如果内层的sql成立，则该行取出。内层sql是exists后的查询。<br>5.4 子查询也可以嵌套在其它子查询中，嵌套程度可以很深。<code>子查询必须要位于圆括号中</code>。<br>5.5 <code>子查询的主要优势</code>为:<br>    5.5.1 子查询允许结构化的查询，这样就可以把一个语句的每个部分隔离开。<br>    5.5.2 有些操作需要复杂的联合和关联。子查询提供了其它的方法来执行这些操作。<br>5.6 <code>ANY关键词必须后面接一个比较操作符</code>。ANY关键词的意思是“对于在子查询返回的列中的<code>任一数值</code>，如果比较结果为TRUE的话，则返回TRUE”。 词语 IN 是 ＝ANY 的别名，二者效果相同。NOT IN不是  &lt;&gt; ANY  的别名，但是是  &lt;&gt; ALL  的别名。<br>5.7 词语ALL必须接在一个比较操作符的后面。ALL的意思是“对于子查询返回的列中的<code>所有值</code>，如果比较结果为TRUE，则返回TRUE。”<br>5.8 <code>优化子查询</code>有些子句会影响在子查询中的行的数量和顺序，通过加一些限制条件来限制子查询查出来的条数。例如：<br>    5.8.1 SELECT * FROM t1 WHERE t1.column1 IN (SELECT column1 FROM t2 ORDER BY column1);<br>    5.8.2 SELECT * FROM t1 WHERE t1.column1 IN (SELECT DISTINCT column1 FROM t2);<br>    5.8.3 SELECT * FROM t1 WHERE EXISTS (SELECT * FROM t2 LIMIT 1);<br>    5.8.4 用子查询替换联合，例如：<br>        5.8.4.1 SELECT DISTINCT column1 FROM t1 WHERE t1.column1 IN (SELECT column1 FROM t2);<br>            <code>代替这个：</code> SELECT DISTINCT t1.column1 FROM t1, t2 WHERE t1.column1 = t2.column1;</p><h1 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h1><p>学习链接查询，先了解“笛卡尔积”，看下百度给出的解释：<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/18.png" alt=""><br><code>在数据库中，一张表就是一个集合，每一行就是集合中的一个元素</code>。表之间作联合查询既是作笛卡尔乘积，比如A表有5条数据，B表有8条数据，如果不做条件筛选，那么两表查询就有<code>5 x 8 = 40</code> 条数据。</p><p>先看下用到的测试表基本信息：我们要实现的功能就是查询商品的时候，从类别表将商品类别名称关联查询出来。<br>    行数：类别表14条，商品表4条<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/19.png" alt=""></p><pre><code>结构：商品表和类别表都有一个cat_id</code></pre><p><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/20.png" alt=""></p><pre><code>小类别表（左右连接时做对比）</code></pre><p><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/21.png" alt=""></p><h3 id="1、全相乘（不是全连接、连接查询），全相乘是作笛卡尔积"><a href="#1、全相乘（不是全连接、连接查询），全相乘是作笛卡尔积" class="headerlink" title="1、全相乘（不是全连接、连接查询），全相乘是作笛卡尔积"></a>1、<code>全相乘</code>（不是全连接、连接查询），全相乘是作笛卡尔积</h3><p>两表全相乘，就是直接从两张表里查询；从查询的截图看出，总共查出了 <code>4 x 14 = 56</code> 条记录，这些记录是笛卡尔乘积的结果，既是两两组合；<br>但是我们要的是每个商品的信息显示类别名称而已，这里却查出了56条记录，其中52条记录都是无限的数据，<code>全相乘的查询效率低</code>。<br>    mysql&gt; SELECT g,goods_name,g.cat_id, c.cat_id,c.cat_name FROM mingoods g, category c;<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/22.png" alt=""><br>    如果在两张表里有相同字段，做联合查询的时候，要区别表明，否则会报错（模糊不清）<br>    mysql&gt; SELECT goods_name,cat_id,cat_name FROM <code>mingoods,category</code>;<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/23.png" alt=""><br>    添加条件，使两表关联查询，这样查出来就是商品和类别一一对应了。虽然这里查询来4条记录，但是<code>全相乘效率低，全相乘会在内存中生成一个非常大的数据（临时表），因为有很多不必要的数据</code>。<br>    <code>如果一张表有10000条数据，另一张表有10000条数据，两表全相乘就是100W条数据，是非常消耗内存的</code>。而且，全相乘不能好好的利用索引，因为全相乘生成一张临时表，临时表是没有索引的，大大降低了查询效率。<br>    mysql&gt; SELECT g.goods_name,g.cat_id AS g_cat_id, c.cat_id AS c_cat_id, c.cat_name FROM mingoods g, category c WHERE g.cat_id = c.cat_id;<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/24.png" alt=""></p><h3 id="2、左连接查询-left-join-on"><a href="#2、左连接查询-left-join-on" class="headerlink" title="2、左连接查询 left join ... on ..."></a>2、<code>左连接查询 left join ... on ...</code></h3><p>语法：select A.filed, [A.filed2, …. ,] B.filed, [B.filed4…,] from <left table> as A  <code>left join</code> <right table> as B <code>on</code> <expression><br>假设有A、B两张表，左连接查询即 A表在左不动，B表在右滑动，A表与B表通过一个关系来关联行，B表去匹配A表。</p><p>2.1 先来看看on后的条件恒为真的情况<br>    mysql&gt; SELECT g.goods_name,g.cat_id, c.cat_id ,c.cat_name FROM mingoods g LEFT JOIN category c ON 1;<br>    跟全相乘相比，从截图可以看出，总记录数仍然不变，还是 <code>4 x 14 = 56</code> 条记录。但是这次是商品表不动，类别表去匹配，因为每次都为真，所以将所有的记录都查出来了。<code>左连接，其实就可以看成左表是主表，右表是从表</code>。<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/25.png" alt=""></p><p>2.2 根据cat_id使两表关联行<br>    mysql&gt; SELECT g.goods_name,g.cat_id,c.cat_id,c.cat_name <code>FROM mingoods g LEFT JOIN category c ON g.cat_id = c.cat_id</code>;<br>    使用左连接查询达到了同样的效果，但是不会有其他冗余数据，<code>查询速度快，消耗内存小，而且使用了索引。左连接查询效率相比于全相乘的效率快了10+倍以上</code>。<br>    左连接时，mingoods表（左表）不动，category表（右表）根据条件去一条条匹配，虽说category表也是读取一行行记录，然后判断cat_id是否跟mingoods表的相同，但是，左连接使用了索引，cat_id建立了索引的话，查询速度非常快，所以整体效率相比于全相乘要快得多，全相乘没有使用索引。<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/26.png" alt=""></p><p>2.3 查询出第四个类别下的商品，要求显示商品名称<br>    mysql&gt; SELECT g.goods_name,g.cat_id,c.cat_name,g.shop_price FROM goods g LEFT JOIN category c ON g.cat_id = c.cat_id WHERE g.cat_id = 4;<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/27.png" alt=""></p><p>2.4 对于左连接查询，如果右表中没有满足条件的行，则默认填充NULL<br>    mysql&gt; SELECT g.goods_name,g.cat_id AS g_cat_id, c.cat_id AS c_cat_id,c.cat_id FROM mingoods g LEFT JOIN mincategory c ON g.cat_id = c.cat_id;<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/28.png" alt=""></p><h3 id="3、右连接查询-right-join-on"><a href="#3、右连接查询-right-join-on" class="headerlink" title="3、右连接查询 right join ... on ..."></a>3、<code>右连接查询 right join ... on ...</code></h3><p>语法：select A.field1,A.field2,…, B.field3,B.field4  from <left table> A <code>right join</code> <right table> B <code>on</code> <expression><br>右连接查询跟左连接查询类似，只是右连接是以右表为主表，会将右表所有数据查询出来，而左表则根据条件去匹配，如果左表没有满足条件的行，则左边默认显示NULL。左右连接是可以互换的。<br>    mysql&gt; SELECT g.goods_name,g.cat_id AS g_cat_id,  c.cat_id AS c_cat_id,c.cat_name FROM mingoods g RIGHT JOIN mincategory c ON g.cat_id = c.cat_id;<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/29.png" alt=""></p><h3 id="4、内连接-inner-join-on"><a href="#4、内连接-inner-join-on" class="headerlink" title="4、内连接 inner join ... on ..."></a>4、<code>内连接 inner join ... on ...</code></h3><p>语法：select A.field1,A.field2,.., B.field3, B.field4 from <left table> A <code>inner join</code> <right table> B <code>on</code> <expression><br>内连接查询，就是取左连接和右连接的交集，如果两边不能匹配条件，则都不取出。<br>    mysql&gt; SELECT g.goods_name,g.cat_id, c.* from mingoods g INNER JOIN mincategory c ON g.cat_id = c.cat_id;<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/30.png" alt=""></p><h3 id="5、全连接-full-join-on"><a href="#5、全连接-full-join-on" class="headerlink" title="5、全连接 full join ... on ..."></a>5、<code>全连接 full join ... on ...</code></h3><p>语法：select … from <left table> <code>full join</code> <right table> <code>on</code> <expression><br>全连接会将两个表的所有数据查询出来，不满足条件的为NULL。<br>全连接查询跟全相乘查询的区别在于，如果某个项不匹配，全相乘不会查出来，全连接会查出来，而连接的另一边则为NULL。</p><h3 id="6、联合查询-union"><a href="#6、联合查询-union" class="headerlink" title="6、联合查询 union"></a>6、<code>联合查询 union</code></h3><p>语法：select A.field1 as f1, A.field2 as f2 from <table1> A <code>union</code> (select B.field3 as f1, field4 as f2 from <table2> B)<br>union是求两个查询的并集。union合并的是结果集，不区分来自于哪一张表，所以可以合并多张表查询出来的数据。<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/31.png" alt=""></p><p>6.1 将两张表的数据合并查询出来<br>    mysql&gt; SELECT id, content, user FROM comment UNION (SELECT id, msg AS content, user FROM feedback);<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/32.png" alt=""></p><p>6.2 union查询，列名不一致时，以第一条sql语句的列名对齐<br>    mysql&gt; SELECT id, content, user FROM comment UNION (SELECT id, msg, user FROM feedback);<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/33.png" alt=""></p><p>6.3 使用union查询会将重复的行过滤掉<br>    mysql&gt; SELECT content,user FROM comment UNION (SELECT msg, user FROM feedback);<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/34.png" alt=""></p><p>6.4 使用union all查询所有，重复的行不会被过滤<br>    mysql&gt; SELECT content,user FROM comment UNION ALL (SELECT msg, user FROM feedback);<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/35.png" alt=""></p><p>6.5 union查询，如果列数不相等，会报列数不相等错误<br>    mysql&gt; SELECT content,user FROM comment UNION (SELECT msg, user FROM feedback);<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/36.png" alt=""></p><p>6.6 union 后的结果集还可以再做筛选<br>    mysql&gt; SELECT id,content,user FROM comment UNION ALL (SELECT id, msg, user FROM feedback) ORDER BY id DESC;<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/37.png" alt=""></p><p><code>union查询时，order by放在内层sql中是不起作用的；因为union查出来的结果集再排序，内层的排序就没有意义了；因此，内层的order by排序，在执行期间，被mysql的代码分析器给优化掉了。</code><br>    mysql&gt; (SELECT id,content,user FROM comment ORDER BY id DESC) UNION ALL (SELECT id, msg, user FROM feedback ORDER BY id DESC);<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/38.png" alt=""></p><p><code>order by 如果和limit一起使用，就显得有意义了，就不会被优化掉</code><br>    mysql&gt; ( SELECT goods_name,cat_id,shop_price FROM goods WHERE cat_id = 3 ORDER BY shop_price DESC LIMIT 3 ) UNION ( SELECT goods_name,cat_id,shop_price FROM goods WHERE cat_id = 4 ORDER BY shop_price DESC LIMIT 2 );<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/39.png" alt=""></p><p>6.7 练习<br>    mysql&gt; SELECT name, SUM(money) FROM ( ( SELECT * FROM A ) UNION ALL ( SELECT * FROM B ) ) tmp GROUP BY name;<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/40.png" alt=""><br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/41.png" alt=""></p><h3 id="7、连接查询总结"><a href="#7、连接查询总结" class="headerlink" title="7、连接查询总结"></a>7、连接查询总结</h3><ol><li><p><code>在数据库中，一张表就是一个集合，每一行就是集合中的一个元素</code>。连接查询即是作笛卡尔积，比如A表有1W条数据，B表有1W条数据，那么两表查询就有 1W X 1W = 100W 条数据</p></li><li><p><code>如果在两张表里有相同字段，做联合查询的时候，要区别表名</code>，否则会报错误(ambiguous 模糊不清)</p></li><li><p><code>全相乘效率低，全相乘会在内存中生成一个非常大的数据(临时表)，因为有很多不必要的数据</code>。如果一张表有10000条数据，另一张表有10000条数据，两表全相乘就是100W条数据，是非常消耗内存的。而且，<code>全相乘不能好好的利用索引，因为全相乘生成一张临时表，临时表里是没有索引的，大大降低了查询效率</code>。</p></li><li><p>左连接查询时，以左表为主表，会将左表所有数据查询出来；左表不动，右表根据条件去一条条匹配，如果没有满足条件的记录，则右边返回NULL。右连接查询时，以右表为主表，会将右表所有数据查询出来，右表不动，左表则根据条件去匹配，如果左表没有满足条件的行，则左边返回NULL。左右连接是可以互换的：A left join B  ==  B right join A (都是以A为主表) 。<code>左右连接既然可以互换，出于移植兼容性方面的考虑，尽量使用左连接</code>。</p></li><li><p>连接查询时，虽说也是读取一行行记录，然后判断是否满足条件，但是，<code>连接查询使用了索引，条件列建立了索引的话，查询速度非常快，所以整体效率相比于全相乘要快得多，全相乘是没有使用索引的</code>。使用连接查询，查询速度快，消耗内存小，而且使用了索引。连接查询效率相比于全相乘的查询效率快了10+倍以上。</p></li><li><p>内连接查询，就是取左连接和右连接的<code>交集</code>，如果两边不能匹配条件，则都不取出。</p></li><li><p>MySql可以用union(联合查询)来查出左连接和右连接的<code>并集</code>。<br><code>union查询会过滤重复的行，union all 不会过滤重复的行</code>。<code>union查询时，union之间的sql列数必须相等，列名以第一条sql的列为准</code>；列类型可以不一样，但没太大意义。<code>union查询时，order by放在内层sql中是不起作用的；因为union查出来的结果集再排序，内层的排序就没有意义了；因此，内层的order by排序，在执行期间，被mysql的代码分析器给优化掉了</code>。但是，<code>order by 如果和limit一起使用</code>，就显得有意义了，会影响最终结果集，就不会被优化掉。order by会根据最终是否会影响结果集而选择性的优化。</p></li><li><p>LEFT JOIN 是 LEFT OUTER JOIN 的缩写，同理，RIGHT JOIN 是 RIGHT OUTER JOIN 的缩写；JOIN 是 INNER JOIN 的缩写。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx详解</title>
      <link href="/2021/06/21/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%90%9E%E5%AE%9Anginx%E9%85%8D%E7%BD%AE/"/>
      <url>/2021/06/21/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%90%9E%E5%AE%9Anginx%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li>安装nginx</li><li>nginx配置<ul><li>基本结构</li><li>主要配置含义</li><li>nginx.conf配置文件的语法规则</li><li>内置变量</li><li>常用命令</li><li>配置nginx开机自启</li><li>配置nginx全局可用</li></ul></li><li>nginx常用功能配置<ul><li>反向代理</li><li>访问控制</li><li>6种负载均衡策略</li><li>gzip压缩</li><li>HTTP服务器</li><li>动静分离</li><li>请求限制</li><li>正向代理</li><li>图片防盗链</li><li>适配PC或移动设备</li><li>设置耳机域名</li><li>配置HTTPS</li><li>配置HTTP转HTTPS</li><li>单页面项目history路由配置</li><li>配置最高可用集群（双机热备）</li></ul></li><li>其它功能和技巧配置<ul><li>代理缓存</li><li>访问日志</li><li>错误日志</li><li>静态资源服务器</li><li>禁止指定user_agent</li><li>请求过滤</li><li>ab命令</li><li>泛域名路径分离</li><li>泛域名转发</li></ul></li><li>附nginx模块<ul><li>nginx模块分类</li><li>模块清单</li></ul></li></ul><hr><h1 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h1><p>下载nginx的压缩包文件到根目录，官网下载地址：nginx.org/download/nginx-x.xx.xx.tar.gz<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum update  # 更新系统软件</span><br><span class="line">cd &#x2F;</span><br><span class="line">wget nginx.org&#x2F;download&#x2F;nginx-1.22.2.tar.gz</span><br></pre></td></tr></table></figure><br>解压tar.gz压缩包文件，进去nginx-1.22.2<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf nginx-1.22.2.tar.gz</span><br><span class="line">cd nginx-1.22.2</span><br></pre></td></tr></table></figure><br>进入文件夹后进行配置检查<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure</span><br></pre></td></tr></table></figure><br>通过安装前的配置检查，发现有报错，检查中发现一些依赖库没有找到，这时候需要先安装nginx的一些依赖库<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum -y install pcre  # 安装nginx支持rewrite</span><br><span class="line">yum -y install gcc-c++</span><br><span class="line">yum -y install zlib*</span><br><span class="line">yum -y install openssl openssl-devel</span><br></pre></td></tr></table></figure><br>再次进行检查操作./configure 没有发现报错显示，接下来进行编译并安装的操作<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure</span><br></pre></td></tr></table></figure><br>这里需要特别注意下，以后需要用到的功能模块是否存在，不然以后添加新的包会比较麻烦。<br>查看默认安装的模块支持<br>命令 <code>ls nginx-1.22.2</code> 查看nginx的文件列表，可以发现里面又一个auto的目录<br>在这个auto的目录种又一个options文件，这个文件里面保存的就是nginx编译过程种的所有选项配置<br>用过命令： <code>cat nginx-1.22.2/auto/options | grep YES</code> 就可以查看<br><a href="https://jingyan.baidu.com/article/454316ab354edcf7a7c03a81.html" target="_blank" rel="noopener">nginx编译安装时，怎么查看安装模块</a></p><p>编译安装<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><br>这里需要注意，模块的支持跟后续的nginx配置有关，比如SSL，gzip压缩等等，编译安装前最好检查需要配置的模块存不存在。<br>查看nginx安装后的目录，可以看到已经安装到 <code>/usr/local/nginx</code> 目录了<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">whereis nginx</span><br><span class="line">$nginx: &#x2F;usr&#x2F;local&#x2F;nginx</span><br></pre></td></tr></table></figure><br>启动nginx服务<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin</span><br><span class="line">.&#x2F;nginx</span><br></pre></td></tr></table></figure><br>服务启动的时候报错了： <code>nginx : [emerg] bind() to 0.0.0.0:80 filed (98: Address alredy in use)</code> 通过命令查看本机网络地址和端口等一些信息，<br>找到被占用的80端口 <code>netstat -ntpl</code> 的tcp连接，并杀死进程（kill 进程 pid）<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -ntpl</span><br><span class="line">kill 进程PID</span><br></pre></td></tr></table></figure><br>继续启动 nginx 服务，启动成功<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nginx</span><br></pre></td></tr></table></figure></p><hr><h1 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h1><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main        # 全局配置，对全局生效</span><br><span class="line">|-- events  # 配置影响 nginx 服务器与用户的网络连接</span><br><span class="line">|-- http    # 配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置</span><br><span class="line">|   |-- upstream        # 配置后端服务器具体地址，负载均衡配置不可或缺的部分</span><br><span class="line">|   |-- server          # 配置虚拟主机的相关参数，一个http块中可以有多个server块</span><br><span class="line">|   |-- server</span><br><span class="line">|   |   |-- location    # server块可以包含多个location块，location指令用于匹配uri</span><br><span class="line">|   |   |-- location</span><br><span class="line">|   |   |-- ...</span><br><span class="line">|   |-- ...</span><br><span class="line">|-- ...</span><br></pre></td></tr></table></figure><h3 id="主要配置含义"><a href="#主要配置含义" class="headerlink" title="主要配置含义"></a>主要配置含义</h3><pre><code>&gt;   main:nginx： 的全局配置，对全局生效；&gt;   events： 配置影响nginx服务器或与用户的网络连接；&gt;   http： 可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模版的配置；&gt;   server： 配置虚拟主机的相关参数，一个http中可以有多个server；&gt;   location： 配置请求的路由，以及各种页面的处理情况；&gt;   upstream： 配置后端服务器具体地址，负载均衡配置不可或缺的部分；</code></pre><h3 id="nginx-conf-配置文件的语法规则"><a href="#nginx-conf-配置文件的语法规则" class="headerlink" title="nginx.conf 配置文件的语法规则"></a>nginx.conf 配置文件的语法规则</h3><pre><code>&gt;   配置文件由指令与指令块构成；&gt;   每条指令以 “;“ 分号结尾，指令与参数间以空格符号分隔；&gt;   指令块以 {} 大括号将多条指令组织在一起；&gt;   include 语句允许组合多个配置文件以提升可维护性；&gt;   通过 # 符号添加注释，提高可读性；&gt;   通过 $ 符号使用变量；&gt;   部分指令的参数支持正则表达式，例如常用的 location 指令；</code></pre><h3 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h3><pre><code>|       TCP         |       UDP      | |       ----        |      ----        ||     $host      |   请求信息中的Host，如果请求中没有Host行，则等于设置的服务器名        ||     $request_method      |     客户端请求类型，如 GET、POST      ||     $remote_addr      |   客户端的 ip 地址        ||     $args      |   请求中的参数        ||     $content_length      |   请求头中的 Content-length 字段        ||     $http_user_agent      |   客户端 agent 信息        ||     $http_cookie      |    客户端 cookie 信息       ||     $remote_port      |    客户端的端口       ||     $server_protocol      |  请求使用的协议，如 HTTP/1.1         ||     $server_addr      |   服务器地址        ||     $server_name      |   服务器名称        ||     $server_port      |   服务器的端口号        |</code></pre><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>这里列举几个常用的命令<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload  # 向主进程发送信号，重新加载配置文件，热重启</span><br><span class="line">nginx -s reopen  # 重启nginx</span><br><span class="line">nginx -s stop  # 快速关闭</span><br><span class="line">nginx -s quit  # 等待工作进程处理完成后关闭</span><br><span class="line">nginx -T  # 查看当前 nginx 最终的配置</span><br><span class="line">nginx -t -c &lt;配置路径&gt;  # 检查配置是否由问题，如果预警在配置目录，则不需要 -c</span><br></pre></td></tr></table></figure><br>以上命令通过 <code>nginx -h</code> 就可以查看到，还有其它不常用的这里不在列出。</p><p>Linux 系统应用管理工具 systemd 关于 nginx 的常用命令：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx  # 启动 nginx</span><br><span class="line">systemctl stop nginx   # 停止 nginx</span><br><span class="line">systemctl restart nginx  # 重启 nginx</span><br><span class="line">systemctl reload nginx  # 重新加载 nginx，用于修改配置后</span><br><span class="line">systemctl enable nginx  # 设置开机启动 nginx</span><br><span class="line">systemctl disable nginx  # 关闭开启启动 nginx</span><br><span class="line">systemctl status nginx  # 查看 nginx 运行状态</span><br></pre></td></tr></table></figure></p><h3 id="配置-nginx-开启自启"><a href="#配置-nginx-开启自启" class="headerlink" title="配置 nginx 开启自启"></a>配置 nginx 开启自启</h3><p>利用 systemctl 命令：<br>如果用yum install 命令安装的nginx，yum命令会自动创建nginx.service文件，直接用命令：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable nginx  # 设置开机启动 nginx</span><br><span class="line">systemctl disable nginx  # 关闭开机启动 nginx</span><br></pre></td></tr></table></figure><br>就你可以设置开机自启，否则需要在系统服务目录里创建 nginx.service 文件。<br>创建并打开 nginx.service 文件：<br><code>vi /lib/systemd/system/nginx.service</code><br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">内容如下:</span><br><span class="line">        [Unit]</span><br><span class="line">        Description&#x3D;nginx</span><br><span class="line">        After&#x3D;network.target</span><br><span class="line"></span><br><span class="line">        [Service]</span><br><span class="line">        Type&#x3D;forking</span><br><span class="line">        ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx</span><br><span class="line">        ExecReload&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s reload</span><br><span class="line">        ExecStop&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s quit</span><br><span class="line">        PrivateTmp&#x3D;true</span><br><span class="line"></span><br><span class="line">        [Install]</span><br><span class="line">        WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure><br><code>:wq</code> 保存退出，运行 <code>systemctl daemon-reload</code> 使文件生效。</p><p>这样便可以通过以下命令操作nginx了：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx.service  # 启动nginx服务</span><br><span class="line">systemctl enable nginx.service  # 设置开机启动</span><br><span class="line">systemctl disable nginx.service  # 停止开机启动</span><br><span class="line">systemctl status nginx.service  # 查看服务当前状态</span><br><span class="line">systemctl restart nginx.service  # 重新启动服务</span><br><span class="line">systemctl is-enabled nginx.service  # 查询服务是否开机启动</span><br></pre></td></tr></table></figure></p><h3 id="通过开机启动命令脚本实现开机自启"><a href="#通过开机启动命令脚本实现开机自启" class="headerlink" title="通过开机启动命令脚本实现开机自启"></a>通过开机启动命令脚本实现开机自启</h3><p>创建开启启动命令脚本文件：<br><code>vi /etc/init.d/nginx</code></p><p>在这个 nginx 文件中插入以下启动脚本代码，启动脚本代码来源网络复制，实测有效：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#! &#x2F;bin&#x2F;bash</span><br><span class="line"># chkconfig: -85 15</span><br><span class="line">PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx</span><br><span class="line">DESC&#x3D;&quot;nginx daemon&quot;</span><br><span class="line">NAME&#x3D;nginx</span><br><span class="line">DAEMON&#x3D;$PATH&#x2F;sbin&#x2F;$NAME</span><br><span class="line">CONFIGFILE&#x3D;$PATH&#x2F;logs&#x2F;$NAME.pid</span><br><span class="line">scriptNAME&#x3D;&#x2F;etc&#x2F;init.d&#x2F;$NAME</span><br><span class="line">set -e</span><br><span class="line">[ -x &quot;$DAEMON&quot; ] || exit 0</span><br><span class="line">do_start() &#123;</span><br><span class="line">    $DAEMON -c $CONFIGFILE || echo -n &quot;nginx already running&quot;</span><br><span class="line">&#125;</span><br><span class="line">do_stop() &#123;</span><br><span class="line">    $DAEMON -s stop || echo -n &quot;nginx not running&quot;</span><br><span class="line">&#125;</span><br><span class="line">do_reload() &#123;</span><br><span class="line">    $DAEMON -s reload || echo -n &quot;nginx can&#39;t reload&quot;</span><br><span class="line">&#125;</span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">start()</span><br><span class="line">echo -n &quot;Starting $DESC: $NAME&quot;</span><br><span class="line">do_start</span><br><span class="line">echo &quot;.&quot;</span><br><span class="line">;;</span><br><span class="line">restart()</span><br><span class="line">echo -n &quot;Restarting $DESC: $NAME&quot;</span><br><span class="line">do_stop</span><br><span class="line">do_start</span><br><span class="line">echo &quot;.&quot;</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">echo &quot;Usage: $scriptNAME &#123;start|stop|reload|restart&#125;&quot; &gt;&amp;2</span><br><span class="line">exit 3</span><br><span class="line">;;</span><br><span class="line">esac</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><br>设置所有人都有对这个启动脚本 nginx 文件的执行权限：<br><code>chmod a+x /etc/init.d/nginx</code></p><p>把nginx加入系统服务中：<br><code>chkconfig --add nginx</code></p><p>把服务设置为开机启动<br><code>chkconfig nginx on</code></p><p>reboot 重启系统生效，可以使用上面 systemctl 方法相同的命令：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx.service  # 启动nginx服务</span><br><span class="line">systemctl enable nginx.service  # 设置开机启动</span><br><span class="line">systemctl disable nginx.service  # 停止开机启动</span><br><span class="line">systemctl status nginx.service  # 查看服务当前状态</span><br><span class="line">systemctl restart nginx.service  # 重新启动服务</span><br><span class="line">systemctl is-enabled nginx.service  # 查询服务是否开机启动</span><br></pre></td></tr></table></figure></p><p>如果服务启动的时候出现 <code>Restarting nginx daemon: nginxnginx: [error] open() &quot;/usr/local/nginx/logs/nginx.pid&quot; filed (2: No such file or directory) nginx not running</code> 的错误，通过 nginx -c 参数指定配置文件即可解决<br><code>/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/ngonx.conf</code></p><p>如果服务启动中出现 <code>nginx: [emerg] bind() to 0.0.0.0:80 filed (98: Address already in use)</code> 的错误，可以先通过 <code>service nginx stop</code> 停止服务，再启动就好。</p><h3 id="配置-nginx-全局可用"><a href="#配置-nginx-全局可用" class="headerlink" title="配置 nginx 全局可用"></a>配置 nginx 全局可用</h3><p>当你每次改了 <code>nginx.conf</code> 配置文件的内容都需要重新到 nginx 启动目录去执行命令，或者通过 -p 参数指向特定目录，会不会感觉很麻烦？</p><p>例如：直接执行 <code>nginx -s reload</code> 会报错 <code>-bash: nginx command not found</code> 需要 <code>/usr/local/nginx/sbin</code> 目录下面去执行，并且是执行 <code>./nginx -s reload</code> 。</p><p>这里有两种方式可以解决，一种是通过脚本对 nginx 命令包装，这里介绍另外一种比较简单：通过把 nginx 配置到环境变量里，用nginx执行指令即可。步骤如下：</p><p>1、编辑/etc/profile<br><code>vi /etc/profile</code></p><p>2、在最后一行添加配置，:wq 保存<br><code>export PATH=$PATH:/usr/local/nginx/sbin</code></p><p>3、使配置立即生效<br><code>source /etc/profile</code></p><p>这样就可以愉快的直接在全局使用 nginx 命令了。</p><hr><h1 id="nginx-常用功能"><a href="#nginx-常用功能" class="headerlink" title="nginx 常用功能"></a>nginx 常用功能</h1><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>我们最常说的反向代理的是通过反向代理解决跨域问题。</p><p>其实反响代理还可以用来控制缓存（代理缓存 proxy cache），进行访问控制等等，以及后面说的负载均衡其实都是通过反向代理来实现的。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen  8080;</span><br><span class="line">    # 用户访问 ip:8080&#x2F;test 下的所有路径代理到 baidu.com</span><br><span class="line">    location &#x2F;test &#123;</span><br><span class="line">        proxy_pass  https:&#x2F;&#x2F;baidu.com;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 所有 &#x2F;api 下的接口访问代理到本地的 8080 端口</span><br><span class="line">    # 例如你本地运行的 go 服务的端口是 8888，接口都是以 &#x2F;api 开头</span><br><span class="line">    location &#x2F;api &#123;</span><br><span class="line">        proxy_pass  http:&#x2F;&#x2F;localhost:8888;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    location ~ ^&#x2F;index.html &#123;</span><br><span class="line">        # 匹配 index.html 页面除了 127.0.0.1 以外都可以访问</span><br><span class="line">        deny 192.168.1.1;</span><br><span class="line">        deny 192.168.1.2;</span><br><span class="line">        allow all;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>上面命令表示禁止 192.168.1.1 和 192.168.1.2 两个 ip 访问，其它全部允许。从上到下的顺序，匹配到了便跳出，可以按你的需求设置。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>通过负载均衡充利用服务器资源，nginx 目前支持自带4中负载均衡策略，还有2种常用的第三方策略。</p><h4 id="轮训策略（默认）"><a href="#轮训策略（默认）" class="headerlink" title="轮训策略（默认）"></a>轮训策略（默认）</h4><p>每个请求按照时间顺序逐一分配到不同的后端服务器，如果有后端服务器挂掉，能自动剔除。但是如果其中某一台服务器压力太大，出现延迟，会影响所有分配在这台服务器下的用户。</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream test.com &#123;</span><br><span class="line">        server 192.168.1.12:8887;</span><br><span class="line">        server 192.168.1.13:8888;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        location &#x2F;api &#123;</span><br><span class="line">            proxy_pass  http:&#x2F;&#x2F;test.com;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h4 id="根据服务器权重"><a href="#根据服务器权重" class="headerlink" title="根据服务器权重"></a>根据服务器权重</h4><p>例如要配置：10 次请求中大概 1 次访问到 8888 端口，9 次访问到 8887 端口：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream test.com &#123;</span><br><span class="line">        server 192.168.1.12:8887 weight&#x3D;9;</span><br><span class="line">        server 192.168.1.13:8888 weight&#x3D;1;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        location &#x2F;api &#123;</span><br><span class="line">            proxy_pass  http:&#x2F;&#x2F;test.com;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="客户端-id-绑定（ip-hash）"><a href="#客户端-id-绑定（ip-hash）" class="headerlink" title="客户端 id 绑定（ip_hash）"></a>客户端 id 绑定（ip_hash）</h4><p>来自同一个 ip 的请求永远只分配一台服务器，有效解决了动态网页的 session 共享问题，例如：比如把登陆信息保存到了 session 中，那么跳转到另外一台服务器的时候就需要重新登陆了。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream test.com &#123;</span><br><span class="line">        ip_hash;</span><br><span class="line">        server 192.168.1.12:8887;</span><br><span class="line">        server 192.168.1.13:8888;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        location &#x2F;api &#123;</span><br><span class="line">            proxy_pass  http:&#x2F;&#x2F;test.com;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="最小连接数策略"><a href="#最小连接数策略" class="headerlink" title="最小连接数策略"></a>最小连接数策略</h4><p>将请求优先分配给压力较小的服务器，它可以平衡每个队列的长度，并避免向压力大的服务器添加更多的请求。</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream test.com &#123;</span><br><span class="line">        least_conn;</span><br><span class="line">        server 192.168.1.12:8887;</span><br><span class="line">        server 192.168.1.13:8888;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        location &#x2F;api &#123;</span><br><span class="line">            proxy_pass  http:&#x2F;&#x2F;test.com;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h4 id="最快响应时间策略（依赖于第三方-NGINX-Plus）"><a href="#最快响应时间策略（依赖于第三方-NGINX-Plus）" class="headerlink" title="最快响应时间策略（依赖于第三方 NGINX Plus）"></a>最快响应时间策略（依赖于第三方 NGINX Plus）</h4><p>依赖于 NGINX Plus，优先分配给响应时间最短的服务器。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream test.com &#123;</span><br><span class="line">        fair;</span><br><span class="line">        server 192.168.1.12:8887;</span><br><span class="line">        server 192.168.1.13:8888;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        location &#x2F;api &#123;</span><br><span class="line">            proxy_pass  http:&#x2F;&#x2F;test.com;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="按访问url的hash结果（第三方）"><a href="#按访问url的hash结果（第三方）" class="headerlink" title="按访问url的hash结果（第三方）"></a>按访问url的hash结果（第三方）</h4><p>按访问的 url 的 hash 结果来分配请求，使每个 url 定向到同一个后端服务器，后端服务器为缓存时比较有效。在 upstream 中加入 hash 语句，server 语句中 不能写入 weight 等其它的参数，hash_method 是使用的 hash 算法。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream test.com &#123;</span><br><span class="line">        hash $request_uri;</span><br><span class="line">        hash_method crc32;</span><br><span class="line">        server 192.168.1.12:8887;</span><br><span class="line">        server 192.168.1.13:8888;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        location &#x2F;api &#123;</span><br><span class="line">            proxy_pass  http:&#x2F;&#x2F;test.com;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>采用 HAproxy 的 loadbalance uri 或者 nginx 的 upstream_hash 模块，都可以做到针对 uri 进行哈希算法式的负载均衡转发。</p><h3 id="gzip-压缩"><a href="#gzip-压缩" class="headerlink" title="gzip 压缩"></a>gzip 压缩</h3><p>开启 gzip 压缩可以大幅减少 http 传输过程中文件的大小，可以极大的提高网站的访问速度，基本是必不可少的优化操作：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gzip    on;  # 开启 gzip 压缩</span><br><span class="line"># gzip_types</span><br><span class="line"># gzip_static on;</span><br><span class="line"># gzip_proxied expired no-cache no-store private auth;</span><br><span class="line"># gzip_buffers 16 8k;</span><br><span class="line">gzip_min_length 1k;</span><br><span class="line">gzip_comp_level 4;</span><br><span class="line">gzip_http_version 1.0;</span><br><span class="line">gzip_vary off;</span><br><span class="line">gzip_disable &quot;MSIE [1-6]\.&quot;;</span><br></pre></td></tr></table></figure></p><ul><li>解释一下以上参数：<blockquote><ol><li>gzip_types：要采用 gzip 压缩的 MIME 文件类型，其中 text/html 被系统强制启用；</li><li>gzip_static：默认 off，该模块启用后，Nginx 首先检查是否存在请求静态文件的 gz 结尾的文件，如果有则直接返回该 .gz 文件内容；</li><li>gzip_proxied：默认 off nginx 做为反响代理时启用，用于设置启用或禁用从代理服务器上收到相应内容的 gzip 压缩；</li><li>gzip_buffers：获取多少内存用于缓存压缩结果，16 8k 表示 8k*16 为单位获得；</li><li>gzip_min_length：允许压缩的页面最小字节数，页面字节数 从 header 头中的 Content-Length 中进行获取，默认值是 0，不管也页面多大都压缩。建议设置成大于 1k 的字节数，小于 1k 可能会越压越大；</li><li>gzip_comp_level：gzip 压缩比，压缩级别是 1-9，1 压缩级别最低，9 最高，级别越高压缩率越大，压缩时间越长，建议 4-6；</li><li>gzip_http_version：默认 1.1，启用 gzip 所需的 HTTP 最低版本；</li><li>gzip_vary：用于在响应消息头中添加 Vary：Accept-Encoding，使代理服务器根据请求头中的 Accept-Encoding 识别是否启用 gzip 压缩；</li><li>gzip_disable：指定那些不需要 gzip 压缩的浏览器；<br>其中第2点，普遍是结合前端打包的时候打包成 gzip 文件后部署到服务器上，这样服务器就可以直接使用 gzip 的文件了，并且可以把压缩比例提高，这样 nginx 就不用压缩，也就不会影响速度，一般不追求极致的情况下，前端不用做任何配置就可以使用了。</li></ol></blockquote></li></ul><p>附前端 webpack 开启 gzip 压缩配置，在 vue-cli3 的 vue.config.js 配置文件中：<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CompressionWebpackPlugin = <span class="built_in">require</span>(<span class="string">'compression-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// gzip 配置</span></span><br><span class="line">    configureWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">            <span class="comment">// 生产环境</span></span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                plugins: [<span class="keyword">new</span> ConpressionWebpackPlugin (&#123;</span><br><span class="line">                    test: <span class="regexp">/\.js$|\.html$|\.css/</span>,    <span class="comment">// 匹配文件名</span></span><br><span class="line">                    threshold: <span class="number">1024</span>,                <span class="comment">// 文件压缩阀值，对超过 1k 的进行压缩</span></span><br><span class="line">                    deleteOriginalAssets: <span class="literal">false</span>     <span class="comment">// 是否删除源文件</span></span><br><span class="line">                &#125;)]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="HTTP-服务器"><a href="#HTTP-服务器" class="headerlink" title="HTTP 服务器"></a>HTTP 服务器</h3><p>nginx 本身也是一个静态资源的服务器，当只有静态资源的时候，就可以使用 nginx 来做服务器：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen  80;</span><br><span class="line">    server_name localhost;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root    &#x2F;usr&#x2F;local&#x2F;app;</span><br><span class="line">        index   index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>这样如果访问 <a href="http://ip" target="_blank" rel="noopener">http://ip</a> 就会默认访问到 /usr/local/app 目录下面的 index.html，如果一个网站只是静态页面的话，那么就可以通过这种方式来实现部署，比如一个静态官网。</p><h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3><p>就是把动态和静态的请求分开。方式主要有两种：<br>    *   一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也就是目前主流推崇的方案<br>    *   一种就是动态跟静态文件混合在一起发布，通过 nginx 配置来分开<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 所有静态请求都由nginx处理，存放目录为 html</span><br><span class="line">location ~ \.(gif|jpg|jpeg|png|bmp|swf|css|js)$ &#123;</span><br><span class="line">    root    &#x2F;usr&#x2F;local&#x2F;resource;</span><br><span class="line">    expires 10h;    # 设置过期时间为 10 小时</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 所有动态请求都转发给 tomcat 处理</span><br><span class="line">location ~ \.(jsp|do)$ &#123;</span><br><span class="line">    proxt_pass  127.0.0.1:8888;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意上面设置了 expires，当 nginx 设置了 expires 后，例如设置为：expires 10d；那么，所在的 location 或 if 的内容，用户在 10 天内请求的时候，都只会访问浏览器中的缓存，而不会去请求 nginx。</p><h3 id="请求限制"><a href="#请求限制" class="headerlink" title="请求限制"></a>请求限制</h3><p>对于大流量恶意的访问，会造成带宽的浪费，给服务器增加压力。可以通过 nginx 对于同一 ip 的连接数以及并发数进行限制。合理的控制还可以用来防止 DDos 和 CC攻击。</p><p>关于请求限制主要使用 nginx 默认集成的 2个模块：<br>    *   limit_conn_module 连接频率限制模块<br>    *   limit_req_module  请求频率限制模块</p><p>涉及到的配置主要是：<br>    *   limit_req_zone  限制请求数<br>    *   limit_conn_zone 限制并发连接数</p><h4 id="通过-limit-req-zone-限制请求数"><a href="#通过-limit-req-zone-限制请求数" class="headerlink" title="通过 limit_req_zone 限制请求数"></a>通过 limit_req_zone 限制请求数</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    limit_conn_zone $binary_remote_addrzone&#x3D;limit : 10m; &#x2F;&#x2F; 设置共享内存空间大小</span><br><span class="line">    server &#123;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            limit_conn addr 5;  # 同一用户地址同一时间只允许5个链接</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>如果共享内存空间被耗尽，服务器将会对后续所有的请求返回503（Service Temporarily Unavailable）错误。<br>当多个limit_conn_zone 指令被配置时，所有的连接数限制都会生效。比如，下面配置不仅会限制单一IP来源的连接数同时也会限制单一虚拟服务器的总连接数：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">limit_conn_zone $binary_remote_addr zone&#x3D;perip:10m;</span><br><span class="line">limit_conn_zone $server_name zone&#x3D;perserver:10m;</span><br><span class="line">server &#123;</span><br><span class="line">    limit_conn perip 10; # 限制每个 ip 连接到服务器的数量</span><br><span class="line">    limit_conn perserver 2000; # 限制连接到服务器的总数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h4 id="通过-limit-conn-zone-限制并发连接数"><a href="#通过-limit-conn-zone-限制并发连接数" class="headerlink" title="通过 limit_conn_zone 限制并发连接数"></a>通过 limit_conn_zone 限制并发连接数</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">limit_req_zone $binary_remote_addr zone&#x3D;creq:10 mrate&#x3D;10r&#x2F;s;</span><br><span class="line">server&#123;</span><br><span class="line">    location &#x2F;&#123;</span><br><span class="line">        limit_req zone&#x3D;creq burst&#x3D;5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>限制平均每秒不超过一个请求，同时允许超过频率限制的请求数不多于5个。<br>如果不希望超过的请求被延迟，可以用 nodelay 参数，如：<code>limit_req zone=creq burst=5 nodelay;</code></p><h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p>正向代理，意思是一个位于客户端和原始服务器（origin server）之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标（原始服务器），然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理，比如我们使用的 VPN 服务就是正向代理，直观区别：<br><img src= "/img/loading.gifs" data-src="/images/nginx/img1.jpg" alt=""></p><p>配置正向代理：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">resolver 8.8.8.8 # 谷歌的域名解析地址</span><br><span class="line">server &#123;</span><br><span class="line">    resolver_timeout 5s; &#x2F;&#x2F; 设超时时间</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        # 当客户端请求我的时候，我会把请求转发给它</span><br><span class="line">        # $host 要访问的主机名 $request_uri 请求路径</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;$host$request_uri;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>正向代理的对象是客户端，服务器端看不到正真的客户端。</p><h3 id="图片防盗链"><a href="#图片防盗链" class="headerlink" title="图片防盗链"></a>图片防盗链</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    server &#123;</span><br><span class="line">    listen       80;      </span><br><span class="line">    server_name  *.test;</span><br><span class="line"></span><br><span class="line">    # 图片防盗链</span><br><span class="line">    location ~* \.(gif|jpg|jpeg|png|bmp|swf)$ &#123;</span><br><span class="line">        valid_referers none blocked server_names ~\.google\. ~\.baidu\. *.qq.com;  # 只允许本机 IP 外链引用，将百度和谷歌也加入白名单有利于 SEO</span><br><span class="line">        if ($invalid_referer)&#123;</span><br><span class="line">            return 403;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>以上配置就能防止其它网站利用外链访问我们的图片，有利于节省流量。</p><h3 id="适配-PC-或移动设备"><a href="#适配-PC-或移动设备" class="headerlink" title="适配 PC 或移动设备"></a>适配 PC 或移动设备</h3><p>根据用户设备不用返回不用样式的站点，以前经常使用的是纯前端的自适应布局，但是复杂的网站并不适合响应式，无论是复杂性和易用性上面还是不如分开编写的好，比如我们常见的淘宝、京东。</p><p>根据用户请求的 user-agent 来判断是返回 PC 还是 H5 站点：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name test.com;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root  &#x2F;usr&#x2F;local&#x2F;app&#x2F;pc; # pc 的 html 路径</span><br><span class="line">        if ($http_user_agent ~* &#39;(Android|webOS|iPhone|iPod|BlackBerry)&#39;) &#123;</span><br><span class="line">            root &#x2F;usr&#x2F;local&#x2F;app&#x2F;mobile; # mobile 的 html 路径</span><br><span class="line">        &#125;</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="设置二级域名"><a href="#设置二级域名" class="headerlink" title="设置二级域名"></a>设置二级域名</h3><p>新建一个 server 即可：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name admin.test.com; &#x2F;&#x2F; 二级域名</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root  &#x2F;usr&#x2F;local&#x2F;app&#x2F;admin; # 二级域名的 html 路径</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="配置-HTTPS"><a href="#配置-HTTPS" class="headerlink" title="配置 HTTPS"></a>配置 HTTPS</h3><p>这里我们使用 cerbot 免费证书，但申请一次有效期只有三个月，（好像可以用 crontab 尝试配置自动续期）：<br>先安装 cerbot</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;dl.eff.org&#x2F;cerbot-auto</span><br><span class="line">chmod a+x cerbot-auto</span><br></pre></td></tr></table></figure></code></pre><p>申请证书（注意：需要把申请证书的域名先解析到这台服务器上，才能申请）：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo .&#x2F;certbot-auto certonly --standalone --email admin@abc.com -d test.com -d www.test.com</span><br></pre></td></tr></table></figure></code></pre><p>执行上面指令，按提示操作。<br>Cerbot 会启动一个临时服务器来完成验证，（会占用 80 端口或 443 端口，因此需要暂时关闭 Web 服务器），然后 Cerbot 会把证书以文件的形式保存，包括完整的证书链文件和私钥文件。</p><p>文件保存在 etc/letsencrypt/live 下面的域名目录下。</p><p>修改 nginx 配置：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    server&#123;</span><br><span class="line">    listen 443 ssl http2; &#x2F;&#x2F; 这里还启用了 http&#x2F;2.0</span><br><span class="line"></span><br><span class="line">    ssl_certificate &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;test.com&#x2F;fullchain.pem; # 证书文件地址</span><br><span class="line">    ssl_certificate_key &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;test.com&#x2F;privkey.pem; # 私钥文件地址</span><br><span class="line"></span><br><span class="line">    server_name test.com www.test.com; &#x2F;&#x2F; 证书绑定的域名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="配置-HTTP-转-HTTPS"><a href="#配置-HTTP-转-HTTPS" class="headerlink" title="配置 HTTP 转 HTTPS"></a>配置 HTTP 转 HTTPS</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    server &#123;</span><br><span class="line">    listen      80;</span><br><span class="line">    server_name test.com www.test.com;</span><br><span class="line"></span><br><span class="line">    # 单域名重定向</span><br><span class="line">    if ($host &#x3D; &#39;www.sherlocked93.club&#39;)&#123;</span><br><span class="line">        return 301 https:&#x2F;&#x2F;www.sherlocked93.club$request_uri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 全局非 https 协议时重定向</span><br><span class="line">    if ($scheme !&#x3D; &#39;https&#39;) &#123;</span><br><span class="line">        return 301 https:&#x2F;&#x2F;$server_name$request_uri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 或者全部重定向</span><br><span class="line">    return 301 https:&#x2F;&#x2F;$server_name$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>以上配置选择自己需要的一条即可，不用全部加。</p><h3 id="单页面项目-history-路由配置"><a href="#单页面项目-history-路由配置" class="headerlink" title="单页面项目 history 路由配置"></a>单页面项目 history 路由配置</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  fe.sherlocked93.club;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root       &#x2F;usr&#x2F;local&#x2F;app&#x2F;dist;  # vue 打包后的文件夹</span><br><span class="line">        index      index.html index.htm;</span><br><span class="line">        try_files  $uri $uri&#x2F; &#x2F;index.html @rewrites; # 默认目录下的 index.html，如果都不存在则重定向</span><br><span class="line"></span><br><span class="line">        expires -1;                          # 首页一般没有强制缓存</span><br><span class="line">        add_header Cache-Control no-cache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location @rewrites &#123; &#x2F;&#x2F; 重定向设置</span><br><span class="line">        rewrite ^(.+)$ &#x2F;index.html break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p><a href="https://router.vuejs.org/zh/guide/essentials/history-mode.html#%E5%90%8E%E7%AB%AF%E9%85%8D%E7%BD%AE%E4%BE%8B%E5%AD%90" target="_blank" rel="noopener">vue-router</a> 官网只有一句话 <code>try_files $uri $uri/ /index.html;</code> 而上面做了一些重定向处理。</p><h3 id="配置高可用集群（双机热备）"><a href="#配置高可用集群（双机热备）" class="headerlink" title="配置高可用集群（双机热备）"></a>配置高可用集群（双机热备）</h3><p>当主机 nginx 服务器宕机之后，切换到备份的 nginx 服务器</p><p>首先安装 keepalived：<code>yum install keepalived -y</code> 然后编辑 <code>/etc/keepalived/keepalived.conf</code> 配置文件，并在配置文件中增加 <code>vrrp_script</code> 定义一个外围检测机制，并在 <code>vrrp_instance</code> 中通过定义 <code>track_script</code> 来追踪脚本执行过程，实现节点转移：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">global_defs&#123;</span><br><span class="line">notification_email &#123;</span><br><span class="line">        cchroot@gmail.com</span><br><span class="line">&#125;</span><br><span class="line">notification_email_from test@firewall.loc</span><br><span class="line">smtp_server 127.0.0.1</span><br><span class="line">smtp_connect_timeout 30 &#x2F;&#x2F; 上面都是邮件配置</span><br><span class="line">router_id LVS_DEVEL     &#x2F;&#x2F; 当前服务器名字，用 hostname 命令来查看</span><br><span class="line">&#125;</span><br><span class="line">vrrp_script chk_maintainace &#123; &#x2F;&#x2F; 检测机制的脚本名称为chk_maintainace</span><br><span class="line">    script &quot;[[ -e&#x2F;etc&#x2F;keepalived&#x2F;down ]] &amp;&amp; exit 1 || exit 0&quot; &#x2F;&#x2F; 可以是脚本路径或脚本命令</span><br><span class="line">    &#x2F;&#x2F; script &quot;&#x2F;etc&#x2F;keepalived&#x2F;nginx_check.sh&quot;    &#x2F;&#x2F; 比如这样的脚本路径</span><br><span class="line">    interval 2  &#x2F;&#x2F; 每隔2秒检测一次</span><br><span class="line">    weight -20  &#x2F;&#x2F; 当脚本执行成立，那么把当前服务器优先级改为-20</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instanceVI_1 &#123;   &#x2F;&#x2F; 每一个vrrp_instance就是定义一个虚拟路由器</span><br><span class="line">    state MASTER      &#x2F;&#x2F; 主机为MASTER，备用机为BACKUP</span><br><span class="line">    interface eth0    &#x2F;&#x2F; 网卡名字，可以从ifconfig中查找</span><br><span class="line">    virtual_router_id 51 &#x2F;&#x2F; 虚拟路由的id号，一般小于255，主备机id需要一样</span><br><span class="line">    priority 100      &#x2F;&#x2F; 优先级，master的优先级比backup的大</span><br><span class="line">    advert_int 1      &#x2F;&#x2F; 默认心跳间隔</span><br><span class="line">    authentication &#123;  &#x2F;&#x2F; 认证机制</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111   &#x2F;&#x2F; 密码</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;  &#x2F;&#x2F; 虚拟地址vip</span><br><span class="line">    172.16.2.8</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>其中检测脚本 <code>nginx_check.sh</code> ，这里提供一个：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">A&#x3D;&#96;ps -C nginx --no-header | wc -l&#96;</span><br><span class="line">if [ $A -eq 0 ];then</span><br><span class="line">    &#x2F;usr&#x2F;sbin&#x2F;nginx # 尝试重新启动nginx</span><br><span class="line">    sleep 2         # 睡眠2秒</span><br><span class="line">    if [ &#96;ps -C nginx --no-header | wc -l&#96; -eq 0 ];then</span><br><span class="line">        killall keepalived # 启动失败，将keepalived服务杀死。将vip漂移到其它备份节点</span><br><span class="line">    fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></code></pre><p>复制一份到备份服务器，备份 nginx 的配置要将 <code>state</code> 后改为 <code>BACKUP</code> ， <code>priority</code> 改为比主机小。<br>设置完毕后各自 <code>service keepalived start</code> 启动，经过访问成功后，可以把 Master 机的 keepalived 停掉，此时 Master 机就不再是主机了 <code>services keepalived stop</code> 看到访问虚拟 IP 时是否能够自动切换到备机 ip addr。</p><p>再次启动 Master 的 keepalived，此时 vip 又变到了主机上。</p><p>配置高可用集群的内容来源于：<a href="https://juejin.cn/post/6844904144235413512#heading-11" target="_blank" rel="noopener">Nginx 从入门到实践，万字详解！</a></p><hr><h1 id="其它功能和技巧"><a href="#其它功能和技巧" class="headerlink" title="其它功能和技巧"></a>其它功能和技巧</h1><h3 id="代理缓存"><a href="#代理缓存" class="headerlink" title="代理缓存"></a>代理缓存</h3><p>nginx 的 http_proxy 模块，提供类似于 Squid 的缓存功能，使用 proxy_cache_path 来配置。</p><p>nginx 可以对访问过的内容在 nginx 服务器本地建立副本，这样在一段时间内再次访问该数据，就不需要通过 nginx 服务器再次向后端服务器发出请求，减小数据传输延迟，提高访问速度：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    proxy_cache_path usr&#x2F;local&#x2F;cache levels&#x3D;1:2 keys_zone&#x3D;my_cache:10m;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  test.com;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_cache my_cache;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;127.0.0.1:8888;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>上面的配置表示：nginx 提供一块 10m 的内存用于缓存，名字为 my_cache，levels 等级为1:2，缓存存放的路径为 <code>usr/local/cache</code> 。</p><h3 id="访问日志"><a href="#访问日志" class="headerlink" title="访问日志"></a>访问日志</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    http &#123;</span><br><span class="line">    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">                    &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">                    &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">    access_log  logs&#x2F;access.log  main;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>错误日志放在 main 全局区块中，打开 nginx.conf 就可以看见在配置文件中和下面一样的代码了：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#error_log  logs&#x2F;error.log;</span><br><span class="line">#error_log  logs&#x2F;error.log  notice;</span><br><span class="line">#error_log  logs&#x2F;error.log  info;</span><br></pre></td></tr></table></figure></p><p>nginx 错误日志默认配置为：<code>error_log logs/error.log error;</code> </p><h3 id="静态资源服务器"><a href="#静态资源服务器" class="headerlink" title="静态资源服务器"></a>静态资源服务器</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  static.bin;</span><br><span class="line">    charset utf-8;    # 防止中文文件名乱码</span><br><span class="line"></span><br><span class="line">    location &#x2F;download &#123;</span><br><span class="line">        alias          &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;static;  # 静态资源目录</span><br><span class="line"></span><br><span class="line">        autoindex               on;    # 开启静态资源列目录，浏览目录权限</span><br><span class="line">        autoindex_exact_size    off;   # on(默认)显示文件的确切大小，单位是byte；off显示文件大概大小，单位KB、MB、GB</span><br><span class="line">        autoindex_localtime     off;   # off(默认)时显示的文件时间为GMT时间；on显示的文件时间为服务器时间</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="禁止指定-user-agent"><a href="#禁止指定-user-agent" class="headerlink" title="禁止指定 user_agent"></a>禁止指定 user_agent</h3><p>nginx 可以禁止指定的浏览器和爬虫框架的访问：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># http_user_agent 为浏览器标识</span><br><span class="line"># 禁止 user_agent 为baidu、360和sohu，~*表示不区分大小写匹配</span><br><span class="line">if ($http_user_agent ~* &#39;baidu|360|sohu&#39;) &#123;</span><br><span class="line">    return 404;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 禁止 Scrapy 等工具的抓取</span><br><span class="line">if ($http_user_agent ~* (Scrapy|Curl|HttpClient)) &#123;</span><br><span class="line">    return 403;</span><br></pre></td></tr></table></figure></code></pre><h3 id="请求过滤"><a href="#请求过滤" class="headerlink" title="请求过滤"></a>请求过滤</h3><h4 id="根据请求类型过滤"><a href="#根据请求类型过滤" class="headerlink" title="根据请求类型过滤"></a>根据请求类型过滤</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 非指定请求全返回 403</span><br><span class="line">if ( $request_method !~ ^(GET|POST|HEAD)$ ) &#123;</span><br><span class="line">    return 403;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h4 id="根据状态码过滤"><a href="#根据状态码过滤" class="headerlink" title="根据状态码过滤"></a>根据状态码过滤</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">error_page 502 503 &#x2F;50x.html;</span><br><span class="line">location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">    root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>这样实际上是一个内部跳转，当访问出现 502、503 的时候就能返回 50x.html 中的内容，这里需要注意是否可以找到 50x.html 页面，所以加了个 location 保证找到你自定义的 50x 页面。</p><h4 id="根据-URL-名称过滤"><a href="#根据-URL-名称过滤" class="headerlink" title="根据 URL 名称过滤"></a>根据 URL 名称过滤</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    if ($host &#x3D; zy.com&#39; ) &#123;</span><br><span class="line">    #其中$1是取自regex部分()里的内容,匹配成功后跳转到的URL。</span><br><span class="line">    rewrite ^&#x2F;(.*)$  http:&#x2F;&#x2F;www.zy.com&#x2F;$1  permanent；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location &#x2F;test &#123;</span><br><span class="line">    &#x2F;&#x2F; &#x2F;test 全部重定向到首页</span><br><span class="line">    rewrite  ^(.*)$ &#x2F;index.html  redirect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h4 id="ab-命令"><a href="#ab-命令" class="headerlink" title="ab 命令"></a>ab 命令</h4><p>ab命令全称为：Apache bench，是 Apache 自带的压力测试工具，也可以测试 Nginx、IIS 等其它 Web 服务器：</p><pre><code>*   -n总共的请求数*   -c并发的请求数*   -t测试所进行的最大秒数，默认值为 50000*   -p包含了需要的 POST 的数据文件*   -T POST数据所使用的 Content-type 头信息</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ab -n 1000 -c 5000 http:&#x2F;&#x2F;127.0.0.1&#x2F; # 每次发送1000并发的请求数，请求数总数为5000。</span><br></pre></td></tr></table></figure><p>测试前需要安装 httpd-tools：<code>yum install httpd_tools</code> </p><h4 id="泛域名路径分离"><a href="#泛域名路径分离" class="headerlink" title="泛域名路径分离"></a>泛域名路径分离</h4><p>这是一个非常使用的技能，经常有时候我们可能需要配置一些二级或者三级域名，希望通过 nginx 自动指向对应目录，比如：</p><ol><li>test1.doc.test.club 自动指向 /usr/local/html/doc/test1 服务器地址；</li><li>test2.doc.test.club 自动指向 /usr/local/html/doc/test2 服务器地址； <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  ~^([\w-]+)\.doc\.test\.club$;</span><br><span class="line"></span><br><span class="line">    root &#x2F;usr&#x2F;local&#x2F;html&#x2F;doc&#x2F;$1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="泛域名转发"><a href="#泛域名转发" class="headerlink" title="泛域名转发"></a>泛域名转发</h4><p>和之前的功能类似，有时候我们希望把二级或者三级域名链接重写到我们希望的路径，让后端，就可以根据路由解析不同的规则：</p><ol><li>test1.serv.test.club/api?name=a 自动转发到 127.0.0.1:8080/test1/api?name=a</li><li>test2.serv.test.club/api?name=a 自动转发到 127.0.0.1:8080/test2/api?name=a <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name ~^([\w-]+)\.serv\.test\.club$;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_set_header        X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header        Host $http_host;</span><br><span class="line">        proxy_set_header        X-NginX-Proxy true;</span><br><span class="line">        proxy_pass              http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;$1$request_uri;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h3 id="nginx-中怎么设置变量"><a href="#nginx-中怎么设置变量" class="headerlink" title="nginx 中怎么设置变量"></a>nginx 中怎么设置变量</h3><p>或许你不知道， nginx 的配置文件使用的是一门微型编程语言。既然是编程语言，一般也就少不了“变量“这种东西，但是在 nginx 配置中，变量只能存放一种类型的值，因为也只存在一种类型的值，那就是字符串。</p><p>例如我们在 nginx.conf 中有这样一行配置：<code>set $name &quot;chroot&quot;;</code> </p><p>上面使用了 set 配置指令对变量 <code>$name</code> 进行了赋值操作，把“chroot” 赋值给了 <code>$name</code> 。<br>nginx 变量名前面有一个 <code>$</code> 符号，这是记法上的要求。所有的 Nginx 变量在 Nginx 配置文件中引用时都须带上 <code>$</code> 前缀。这种表示方法和 Perl、PHP 这些语言是相似的。</p><p>这种表示方法的用处在那里呢，那就是可以直接把变量嵌入到字符串常量中以构造出新的字符串，例如你需要进行一个字符串拼接：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  test.com;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        set $temp hello;</span><br><span class="line">        return &quot;$temp world&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上当匹配成功的时候就会返回字符串“hello world”了。需要注意的是，当引用变量名之后紧跟着变量名的构成字符时（比如后面跟字母、数字以及下划线），我们就需要使用特别的记法来消除歧义，例如：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  test.com;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        set $temp &quot;hello &quot;;</span><br><span class="line">        return &quot;$&#123;temp&#125;world&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里，我们在配置指令的参数值中引用变量 <code>$temp</code> 的时候，后面紧跟着 <code>world</code> 这个单词，所以如果直接写作 <code>$tempworld</code> 则 nginx 的计算引擎会将之识别为引用了变量 <code>$tempworld</code> ，为了解决这个问题， nginx 的字符串支持使用花括号在 <code>$</code> 之后把变量名围起来，比如这里的 <code>${temp}</code> ，所以上面这个例子返回的还是“hello world”：<br><code>curl  &#39;http://test.com/&#39;</code></p><p>还需要注意的是，若是向输出 <code>$</code> 符号本身，可以这样做：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    geo $dollar &#123;</span><br><span class="line">    default &quot;$&quot;;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  test.com;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        set $temp &quot;hello &quot;;</span><br><span class="line">        return &quot;$&#123;temp&#125;world: $dollar&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>上面用到了标准模块的 ngx_geo 提供的配置指令 geo 来为变量 <code>$dollar</code> 赋予字符串， <code>$</code> ，这样，这里的返回值就是 “hello world：$” 了。</p><hr><h1 id="附-nginx-内置预定义变量"><a href="#附-nginx-内置预定义变量" class="headerlink" title="附 nginx 内置预定义变量"></a>附 nginx 内置预定义变量</h1><ul><li>按字母顺序，变量名对应定义<blockquote><ul><li><code>$arg_PARAMETER</code>  #GET 请求中变量名 PARAMETER 参数的值</li><li><code>$args</code>  #这个变量等于 GET 请求中的参数，例如，foo=123&amp;bar=blahblah;这个变量可以被修改</li><li><code>$binary_remote_addr</code>  #二进制码形式的客户端地址</li><li><code>$body_bytes_sent</code>  #传送页面的字节数</li><li><code>$content_length</code>  #请求头中的 Content-length 字段</li><li><code>$content_type</code>  #请求头中的 Content-Type 字段</li><li><code>$cookie_COOKIE</code>  #cookie COOKIE 的值</li><li><code>$document_root</code>  #当前请求在 root 指令中指定的值</li><li><code>document_uri</code>  #与 $uri 相同</li><li><code>$host</code>  #请求中的主机头(Host)字段，如果请求中的主机头不可用或者空，则为处理请求的server 名称(处理请求的 server 的 server_name 指令的值)。值为小写，不包含端口</li><li><code>$hostname</code>  #机器名使用 gethostname 系统调用的值</li><li><code>$http_HEADER</code>  #HTTP 请求头中的内容，HEADER 为 HTTP 请求中的内容转为小写，-变为_(破折号变为下划线)，例如：$http_user_agent(Uaer-Agent 的值)</li><li><code>$sent_http_HEADER</code>  #HTTP 响应头中的内容，HEADER 为 HTTP 响应中的内容转为小写，-变为_(破折号变为下划线)，例如：、senthttpcachecontrol、sent_http_content_type…</li><li><code>$is_args</code>  #如果 $args 设置，值为”?”，否则为””</li><li><code>$limit_rate</code>  #这个变量可以限制连接速率</li><li><code>$nginx_version</code>  #当前运行的 nginx 版本号</li><li><code>$query_string</code>  #与 $args 相同</li><li><code>$remote_addr</code>  #客户端的IP地址</li><li><code>$remote_port</code>  #客户端的端口</li><li><code>$remote_port</code>  #已经经过 Auth Basic Module 验证的用户名</li><li><code>$request_filename</code>  #当前连接请求的文件路径，由 root 或 alias 指令与 URI 请求生成</li><li><code>$request_body</code>  #这个变量（0.7.58+）包含请求的主要信息。在使用 proxy_pass 或 fastcgi_pass 指令的 location 中比较有意义</li><li><code>$request_body_file</code>  #客户端请求主体信息的临时文件名</li><li><code>$request_completion</code>  #如果请求成功，设为”OK”；如果请求未完成或者不是一系列请求中最后一部分则设为空</li><li><code>$request_method</code>  #这个变量是客户端请求的动作，通常为 GET 或 POST。包括 0.8.20 及之前的版本中，这个变量总为 main request 中的动作，如果当前请求是一个子请求，并不使用这个当前请求的动作</li><li><code>$request_uri</code>  #这个变量等于包含一些客户端请求参数的原始 URI，它无法修改，请查看 $uri 更改或重写 URI</li><li><code>$scheme</code>  #所用的协议，例如 http 或者是 https，例如 <code>rewrite ^(.+)$$scheme://example.com$1 redirect</code></li><li><code>$server_addr</code>  #服务器地址，在完成一次系统调用后可以确定这个值，如果要绕开系统调用，则必须在listen中指定地址并且使用bind参数</li><li><code>$server_name</code>  #服务器名称</li><li><code>$server_port</code>  #请求到达服务器的端口号</li><li><code>$server_protocol</code>  #请求使用的协议，通常是 HTTP/1.0、HTTP/1.1或HTTP/2</li><li><code>$uri</code>  #请求中的当前 URI(不带请求参数，参数位于 args ) ， 不 同 于 浏 览 器 传 递 的 args)，不同于浏览器传递的 args)，不同于浏览器传递的 request_uri 的值，它可以通过内部重定向，或者使用 index 指令进行修改。不包括协议和主机名，例如 /foo/bar.html</li></ul></blockquote></li></ul><hr><h1 id="附-nginx-模块"><a href="#附-nginx-模块" class="headerlink" title="附 nginx 模块"></a>附 nginx 模块</h1><h3 id="nginx-模块分类"><a href="#nginx-模块分类" class="headerlink" title="nginx 模块分类"></a>nginx 模块分类</h3><ul><li>nginx 模块分类<blockquote><ul><li>核心模块：nginx 最基本最核心的服务，如进程管理、权限控制、日志记录；</li><li>标准 HTTP 模块：nginx 服务器的标准 HTTP 功能；</li><li>可选 HTTP 模块：处理特殊的 HTTP 请求；</li><li>邮件服务模块：邮件服务；</li><li>第三方模块：作为扩展，完成特殊功能；</li></ul></blockquote></li></ul><h3 id="模块清单"><a href="#模块清单" class="headerlink" title="模块清单"></a>模块清单</h3><ul><li>模块清单<blockquote><ul><li>ngx_core</li><li>ngx_errlog</li><li>ngx_conf</li><li>ngx_events</li><li>ngx_event_core</li><li>ngx_epll</li><li>ngx_regex</li></ul></blockquote></li></ul><h3 id="标准-HTTP-模块"><a href="#标准-HTTP-模块" class="headerlink" title="标准 HTTP 模块"></a>标准 HTTP 模块</h3><ul><li>标准 HTTP 模块<blockquote><ul><li>ngx_http</li><li>ngx_http_core #配置端口，URI 分析，服务器相应错误处理，别名控制 (alias) 等</li><li>ngx_http_log #自定义 access 日志</li><li>ngx_http_upstream #定义一组服务器，可以接受来自 proxy, Fastcgi,Memcache 的重定向；主要用作负载均衡</li><li>ngx_http_static</li><li>ngx_http_autoindex #自动生成目录列表</li><li>ngx_http_index #处理以/结尾的请求，如果没有找到 index 页，则看是否开启了random_index；如开启，则用之，否则用 autoindex</li><li>ngx_http_auth_basic #基于 http 的身份认证 (auth_basic)</li><li>ngx_http_access #基于 IP 地址的访问控制 (deny,allow)</li><li>ngx_http_limit_conn #限制来自客户端的连接的响应和处理速率</li><li>ngx_http_limit_req #限制来自客户端的请求的响应和处理速率</li><li>ngx_http_geo</li><li>ngx_http_map #创建任意的键值对变量</li><li>ngx_http_split_clients</li><li>ngx_http_referer #过滤 HTTP 头中 Referer 为空的对象</li><li>ngx_http_rewrite #通过正则表达式重定向请求</li><li>ngx_http_proxy</li><li>ngx_http_fastcgi #支持 fastcgi</li><li>ngx_http_uwsgi</li><li>ngx_http_scgi</li><li>ngx_http_memcached</li><li>ngx_http_empty_gif #从内存创建一个 1×1 的透明 gif 图片，可以快速调用</li><li>ngx_http_browser #解析 http 请求头部的 User-Agent 值</li><li>ngx_http_charset #指定网页编码</li><li>ngx_http_upstream_ip_hash</li><li>ngx_http_upstream_least_conn</li><li>ngx_http_upstream_keepalive</li><li>ngx_http_write_filter</li><li>ngx_http_header_filter</li><li>ngx_http_chunked_filter</li><li>ngx_http_range_header</li><li>ngx_http_gzip_filter</li><li>ngx_http_postpone_filter</li><li>ngx_http_ssi_filter</li><li>ngx_http_charset_filter</li><li>ngx_http_userid_filter</li><li>ngx_http_headers_filter #设置 http 响应头</li><li>ngx_http_copy_filter</li><li>ngx_http_range_body_filter</li><li>ngx_http_not_modified_filter</li></ul></blockquote></li></ul><h3 id="可选-HTTP-模块"><a href="#可选-HTTP-模块" class="headerlink" title="可选 HTTP 模块"></a>可选 HTTP 模块</h3><ul><li>可选 HTTP 模块<blockquote><ul><li>ngx_http_addition #在响应请求的页面开始或者结尾添加文本信息</li><li>ngx_http_degradation #在低内存的情况下允许服务器返回 444 或者 204 错误</li><li>ngx_http_perl</li><li>ngx_http_flv #支持将 Flash 多媒体信息按照流文件传输，可以根据客户端指定的开始位置返回 Flash</li><li>ngx_http_geoip #支持解析基于 GeoIP 数据库的客户端请求</li><li>ngx_google_perftools</li><li>ngx_http_gzip #gzip 压缩请求的响应</li><li>ngx_http_gzip_static #搜索并使用预压缩的以.gz 为后缀的文件代替一般文件响应客户端请求</li><li>ngx_http_image_filter #支持改变 png，jpeg，gif 图片的尺寸和旋转方向</li><li>ngx_http_mp4 #支持.mp4,.m4v,.m4a 等多媒体信息按照流文件传输，常与 ngx_http_flv 一起使用</li><li>ngx_http_random_index #当收到 / 结尾的请求时，在指定目录下随机选择一个文件作为 index</li><li>ngx_http_secure_link #支持对请求链接的有效性检查</li><li>ngx_http_ssl #支持 https</li><li>ngx_http_stub_status</li><li>ngx_http_sub_module #使用指定的字符串替换响应中的信息</li><li>ngx_http_dav #支持 HTTP 和 WebDAV 协议中的 PUT/DELETE/MKCOL/COPY/MOVE 方法</li><li>ngx_http_xslt #将 XML 响应信息使用 XSLT 进行转换</li></ul></blockquote></li></ul><h3 id="邮件服务模块"><a href="#邮件服务模块" class="headerlink" title="邮件服务模块"></a>邮件服务模块</h3><ul><li>邮件服务模块<blockquote><ul><li>ngx_mail_core</li><li>ngx_mail_pop3</li><li>ngx_mail_imap</li><li>ngx_mail_smtp</li><li>ngx_mail_auth_http</li><li>ngx_mail_proxy</li><li>ngx_mail_ssl</li></ul></blockquote></li></ul><h3 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h3><ul><li>第三方模块<blockquote><ul><li>echo-nginx-module #支持在 nginx 配置文件中使用 echo/sleep/time/exec 等类 Shell 命令</li><li>memc-nginx-module</li><li>rds-json-nginx-module #使 nginx 支持 json 数据的处理</li><li>lua-nginx-module</li></ul></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络通讯协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker-compose搭建MySQL主从复制集群</title>
      <link href="/2020/09/02/docker-compose%E6%90%AD%E5%BB%BAMySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E9%9B%86%E7%BE%A4/"/>
      <url>/2020/09/02/docker-compose%E6%90%AD%E5%BB%BAMySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>随着应用业务数据不断的增大，应用的 响应速度不断下降，在检测过程中我们不难发现大多数的请求都是 查询操作。此时，我们可以将数据库扩展成 主从复制模式，将 读操作 和 写操作 分离开来，多台数据库 分摊请求，从而 减少单库 的 访问压力，进而应用得到优化。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h3 id="主从复制的方式"><a href="#主从复制的方式" class="headerlink" title="主从复制的方式"></a>主从复制的方式</h3><hr><p><code>MySQL 5.6</code>开始主从复制有两种方式：基于日志（<code>binlog</code>）和 基于 <code>GTID</code>（全局事务标示符）。<br>本文只涉及基于日志 <code>binlog 的</code> 主从配置。</p><h1 id="主从复制的流程"><a href="#主从复制的流程" class="headerlink" title="主从复制的流程"></a>主从复制的流程</h1><hr><p><img src= "/img/loading.gifs" data-src="/images/mysql/zhucong.jpg" alt=""><br><code>MySQL</code> 同步操作通过 <code>3</code> 个线程实现，其基本步骤如下：</p><ol><li>主从服务器将数据的更新记录到二进制日志（<code>Binary log</code>）中，用于记录二进制日志事件，这一步由主库线程完成；</li><li>从库 将 主库 的 二进制日志 复制到本地的 中继日志（<code>Relay log</code>），这一步由 从库 <code>I/O</code> 线程 完成；</li><li>从库 读取 中继日志 中的 事件，将其重放到数据中，这一步由 从库 <code>SQL</code> 线程 完成。</li></ol><h1 id="主从模式的优点"><a href="#主从模式的优点" class="headerlink" title="主从模式的优点"></a>主从模式的优点</h1><hr><ol><li><p>负载均衡<br> 通常情况下，会使用 主服务器 对数据进行 更新、删除 和 新建 等操作，而将 查询 工作落到 从库 头上。</p></li><li><p>异地容灾备份<br> 可以将主服务器上的数据同步到 异地从服务器 上，极大地提高了 数据安全性。</p></li><li><p>高可用<br> 数据库的复制功能实现了 主服务器 与 从服务器间 的数据同步，一旦主服务器出了 故障，从服务器立即担当起主服务器的角色，保障系统持续稳定运作。</p></li><li><p>高扩展性<br> 主从复制 模式支持 2 种扩展方式:</p><pre><code>scale-up    向上扩展或者 纵向扩展，主要是提供比现在服务器 性能更好 的服务器，比如 增加 CPU 和 内存 以及 磁盘阵列等，因为有多台服务器，所以可扩展性比单台更大。scale-out    向外扩展或者 横向扩展，是指增加 服务器数量 的扩展，这样主要能分散各个服务器的压力。</code></pre></li></ol><h1 id="主从模式的缺点"><a href="#主从模式的缺点" class="headerlink" title="主从模式的缺点"></a>主从模式的缺点</h1><hr><ol><li><p>成本增加<br> 搭建主从肯定会增加成本，毕竟一台服务器和两台服务器的成本完全不同，另外由于主从必须要开启 二进制日志，所以也会造成额外的 性能消耗。</p></li><li><p>数据延迟<br> 从库 从 主库 复制数据肯定是会有一定的 数据延迟 的。所以当刚插入就出现查询的情况，可能查询不出来。当然如果是插入者自己查询，那么可以直接从 主库 中查询出来，当然这个也是需要用代码来控制的。</p></li><li><p>写入更慢<br> 主从复制 主要是针对 读远大于写 或者对 数据备份实时性 要求较高的系统中。因为 主服务器 在写中需要更多操作，而且 只有一台 可以写入的 主库，所以写入的压力并不能被分散。</p></li></ol><h1 id="主从复制的前提条件"><a href="#主从复制的前提条件" class="headerlink" title="主从复制的前提条件"></a>主从复制的前提条件</h1><hr><ol><li><p>主从服务器 操作系统版本 和 位数 一致。</p></li><li><p>主数据库和从数据库的 版本 要一致。</p></li><li><p>主数据库和从数据库中的 数据 要一致。</p></li><li><p>主数据库 开启 二进制日志，主数据库和从数据库的 <code>server_id</code> 在局域网内必须 唯一。</p></li></ol><h1 id="具体配置"><a href="#具体配置" class="headerlink" title="具体配置"></a>具体配置</h1><hr><h3 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h3><table><thead><tr><th>名称</th><th>版本号</th></tr></thead><tbody><tr><td>Docker</td><td>19.03.8</td></tr><tr><td>docker-compose</td><td>1.25.4</td></tr><tr><td>MySQL</td><td>5.7.17</td></tr></tbody></table><h3 id="2-配置docker-compose-yml"><a href="#2-配置docker-compose-yml" class="headerlink" title="2. 配置docker-compose.yml"></a>2. 配置docker-compose.yml</h3><p>docker-compose.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span> </span><br><span class="line">    <span class="attr">mysql-master:</span></span><br><span class="line">        <span class="attr">build:</span> </span><br><span class="line">            <span class="attr">context:</span> <span class="string">./</span></span><br><span class="line">            <span class="attr">dockerfile:</span> <span class="string">./master/Dockerfile</span></span><br><span class="line">        <span class="attr">environment:</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="string">"MYSQL_ROOT_PASSWORD=root"</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">"MYSQL_DATABASE=replicas_db"</span></span><br><span class="line">        <span class="attr">links:</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="string">mysql-slave</span></span><br><span class="line">        <span class="attr">ports:</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="string">"33065:3306"</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">        <span class="attr">hostname:</span> <span class="string">mysql-master</span></span><br><span class="line">    <span class="attr">mysql-slave:</span></span><br><span class="line">        <span class="attr">build:</span> </span><br><span class="line">            <span class="attr">context:</span> <span class="string">./</span></span><br><span class="line">            <span class="attr">dockerfile:</span> <span class="string">./slave/Dockerfile</span></span><br><span class="line">        <span class="attr">environment:</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="string">"MYSQL_ROOT_PASSWORD=root"</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">"MYSQL_DATABASE=replicas_db"</span></span><br><span class="line">        <span class="attr">ports:</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="string">"33066:3306"</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">        <span class="attr">hostname:</span> <span class="string">mysql-slave</span></span><br></pre></td></tr></table></figure><h3 id="3-主数据库配置"><a href="#3-主数据库配置" class="headerlink" title="3. 主数据库配置"></a>3. 主数据库配置</h3><pre><code>3.1 配置DockerfileDockerfile<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> mysql:<span class="number">5.7</span>.<span class="number">17</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> ./master/my.cnf /etc/mysql/my.cnf</span></span><br></pre></td></tr></table></figure>3.2 配置my.cnf文件my.cnf<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">## 设置server_id，一般设置为IP，注意要唯一</span><br><span class="line">server_id&#x3D;100  </span><br><span class="line">## 复制过滤：也就是指定哪个数据库不用同步（mysql库一般不同步）</span><br><span class="line">binlog-ignore-db&#x3D;mysql  </span><br><span class="line">## 开启二进制日志功能，可以随便取，最好有含义（关键就是这里了）</span><br><span class="line">log-bin&#x3D;replicas-mysql-bin  </span><br><span class="line">## 为每个session分配的内存，在事务过程中用来存储二进制日志的缓存</span><br><span class="line">binlog_cache_size&#x3D;1M  </span><br><span class="line">## 主从复制的格式（mixed,statement,row，默认格式是statement）</span><br><span class="line">binlog_format&#x3D;mixed  </span><br><span class="line">## 二进制日志自动删除&#x2F;过期的天数。默认值为0，表示不自动删除。</span><br><span class="line">expire_logs_days&#x3D;7  </span><br><span class="line">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span><br><span class="line">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span><br><span class="line">slave_skip_errors&#x3D;1062</span><br></pre></td></tr></table></figure></code></pre><h3 id="4-从数据库配置"><a href="#4-从数据库配置" class="headerlink" title="4. 从数据库配置"></a>4. 从数据库配置</h3><pre><code>4.1 配置DockerfileDockerfile<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> mysql:<span class="number">5.7</span>.<span class="number">17</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> ./slave/my.cnf /etc/mysql/my.cnf</span></span><br></pre></td></tr></table></figure></code></pre><hr><pre><code>4.2 配置my.cnf文件my.cnf<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">## 设置server_id，一般设置为IP，注意要唯一</span><br><span class="line">server_id&#x3D;101  </span><br><span class="line">## 复制过滤：也就是指定哪个数据库不用同步（mysql库一般不同步）</span><br><span class="line">binlog-ignore-db&#x3D;mysql  </span><br><span class="line">## 开启二进制日志功能，以备Slave作为其它Slave的Master时使用</span><br><span class="line">log-bin&#x3D;replicas-mysql-slave1-bin  </span><br><span class="line">## 为每个session 分配的内存，在事务过程中用来存储二进制日志的缓存</span><br><span class="line">binlog_cache_size&#x3D;1M  </span><br><span class="line">## 主从复制的格式（mixed,statement,row，默认格式是statement）</span><br><span class="line">binlog_format&#x3D;mixed  </span><br><span class="line">## 二进制日志自动删除&#x2F;过期的天数。默认值为0，表示不自动删除。</span><br><span class="line">expire_logs_days&#x3D;7  </span><br><span class="line">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span><br><span class="line">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span><br><span class="line">slave_skip_errors&#x3D;1062  </span><br><span class="line">## relay_log配置中继日志</span><br><span class="line">relay_log&#x3D;replicas-mysql-relay-bin  </span><br><span class="line">## log_slave_updates表示slave将复制事件写进自己的二进制日志</span><br><span class="line">log_slave_updates&#x3D;1  </span><br><span class="line">## 防止改变数据(除了特殊的线程)</span><br><span class="line">read_only&#x3D;1</span><br></pre></td></tr></table></figure></code></pre><h3 id="5-创建容器"><a href="#5-创建容器" class="headerlink" title="5. 创建容器"></a>5. 创建容器</h3><p>进入 <code>docker</code> 目录，运行 <code>docker-compose</code> 启动命令。<br>    <code>docker-compose up -d</code></p><p>如图所示，<code>MySQL</code> 主数据库和从数据库的容器创建成功。</p><p><img src= "/img/loading.gifs" data-src="/images/mysql/docker-compose_up-success.jpg" alt=""></p><p>分别配置主数据库和从数据库的连接信息如下：</p><ul><li>主数据库<br><img src= "/img/loading.gifs" data-src="/images/mysql/navicat-master-success.jpg" alt=""></li></ul><hr><ul><li>从数据库<br><img src= "/img/loading.gifs" data-src="/images/mysql/navicat-slave-success.jpg" alt=""></li></ul><h3 id="6-配置从数据库"><a href="#6-配置从数据库" class="headerlink" title="6. 配置从数据库"></a>6. 配置从数据库</h3><p>检查从库的起始状态<br>    <code>show master status;</code></p><p>如图所示，从数据库处于未同步复制状态。<br><img src= "/img/loading.gifs" data-src="/images/mysql/show-master-status.jpg" alt=""></p><p>检查主库状态<br>    <code>show master status;</code></p><p>记录从数据库 <code>binary-log</code> 的文件名和数据同步起始位置。<br>        *   File: replicas-mysql-bin.000003<br>        *   Position: 154<br>        <img src= "/img/loading.gifs" data-src="/images/mysql/binary-log.jpg" alt=""></p><p>从库配置主库信息</p><p>在从数据库上运行主数据库的相关配置 <code>sql</code> 进行主从关联</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CHANGE</span> <span class="keyword">MASTER</span> <span class="keyword">TO</span></span><br><span class="line">    MASTER_HOST=<span class="string">'mysql-master'</span>,</span><br><span class="line">    MASTER_USER=<span class="string">'root'</span>,</span><br><span class="line">    MASTER_PASSWORD=<span class="string">'root'</span>,</span><br><span class="line">    MASTER_LOG_FILE=<span class="string">'replicas-mysql-bin.000003'</span>,</span><br><span class="line">    MASTER_LOG_POS=<span class="number">154</span>;</span><br></pre></td></tr></table></figure><p>重新启动 <code>slave</code> 服务</p><p><code>stop slave;</code><br><code>start slave;</code></p><p>进一步检查从数据库的状态信息，两者已经进行数据同步关联。<br><img src= "/img/loading.gifs" data-src="/images/mysql/show-slave-status.jpg" alt=""></p><h3 id="7-创建目标表"><a href="#7-创建目标表" class="headerlink" title="7. 创建目标表"></a>7. 创建目标表</h3><p>在主数据库中创建一张测试数据表 <code>course</code> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for course</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`course`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`course`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`lesson_period`</span> <span class="keyword">double</span>(<span class="number">5</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`score`</span> <span class="keyword">double</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br></pre></td></tr></table></figure><p>主数据库和从数据库的数据处于同步状态，主从复制集群搭建完成。<br><img src= "/img/loading.gifs" data-src="/images/mysql/master-slave.jpg" alt=""></p><h1 id="MySQL的复制类型"><a href="#MySQL的复制类型" class="headerlink" title="MySQL的复制类型"></a>MySQL的复制类型</h1><h3 id="基于语句的复制"><a href="#基于语句的复制" class="headerlink" title="基于语句的复制"></a>基于语句的复制</h3><p>主服务器上面执行的语句在从服务器上面再执行一遍，在 MySQL-3.23 版本以后支持。<br><code>问题：时间上可能不完全同步造成偏差，执行语句的用户也可能是不同一个用户。</code></p><h3 id="基于行的复制"><a href="#基于行的复制" class="headerlink" title="基于行的复制"></a>基于行的复制</h3><p>把主服务器上面改变后的内容直接复制过去，而不关心到底改变该内容是由哪条语句引发的，在 MySQL-5.0 版本以后引入。<br><code>问题：比如一个工资表中有一万个用户，我们把每个用户的工资+1000，那么基于行的复制则要复制一万行的内容，由此造成的开销比较大，而基于语句的复制仅仅一条语句就可以了。</code></p><h3 id="混合类型的复制"><a href="#混合类型的复制" class="headerlink" title="混合类型的复制"></a>混合类型的复制</h3><p><code>MySQL</code> 默认使用 基于语句的复制，当 基于语句的复制 会引发问题的时候就会使用 基于行的复制，<code>MySQL</code> 会自动进行选择。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis集群 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个故事讲完https</title>
      <link href="/2020/08/08/%E4%B8%80%E4%B8%AA%E6%95%85%E4%BA%8B%E8%AE%B2%E5%AE%8Chttps/"/>
      <url>/2020/08/08/%E4%B8%80%E4%B8%AA%E6%95%85%E4%BA%8B%E8%AE%B2%E5%AE%8Chttps/</url>
      
        <content type="html"><![CDATA[<h1 id="1-序言"><a href="#1-序言" class="headerlink" title="1. 序言"></a>1. 序言</h1><p>在开始之前，我们来虚构两个人物， 一个是位于中国的张大胖（怎么又是你？！）， 还有一个是位于米国的Bill (怎么还是你？！)。<br>这俩哥们隔着千山万水，通过网络联系上了， 两个人臭味相投，聊得火热。<br>此时正值米国大选， 张大胖亲切地“致电”Bill, 对米国总统大选的情况表示强烈地关注。 Bill则回电说谢谢关心米国人的事情我们米国人自己做主，不用你们歪果仁瞎操心……</p><p>张大胖继续“致电”说其实我们支持特朗普， 因为希拉里太情绪化，太难打交道了， 我们挺希望看到特朗普上台这样米国就会变成 <code>The Divided State of America ......</code></p><p>Bill 回电： 拉倒你吧你， 我们米国的政体有着强大的纠错性， 虽然有时候发展得慢， 有时候会走上岔路， 但很快就会回到正途，几百年来稳定得很，不像你们像坐了过山车一样…..</p><p>两个人越聊越投机，天南地北，海阔天空，还夹杂着不少隐私的话题。</p><h1 id="2-总是有一种被偷看的感觉"><a href="#2-总是有一种被偷看的感觉" class="headerlink" title="2. 总是有一种被偷看的感觉"></a>2. 总是有一种被偷看的感觉</h1><p>有一天， Bill 突然意识到： 坏了， 我们的通信是明文的， 这简直就是网络上裸奔啊， 任何一个不怀好意的家伙都可以监听我们通信，打开我们发送的数据包，窥探我们的隐私啊。</p><p>张大胖说： “你不早点说，我刚才是不是把我的微信号给你发过去了？ 我是不是告诉你我上周去哪儿旅游了?   估计已经被人截取了吧！”</p><p>Bill  提议： “要不我们做个数据的加密？ 每次传输之前， 你把消息用一个加密算法加密， 然后发到我这里以后我再解密， 这样别人就无法偷窥了，像这样： ”</p><p><img src= "/img/loading.gifs" data-src="/images/posts/tu1.png" alt=""></p><p>张大胖冰雪聪明，一看就明白了， 这<code>加密和解密算法是公开的，那个密钥是保密的</code>， 只有两人才知道， 这样生成的加密消息（密文） 别人就无法得知了。 他说： “Bill 老兄，你生成一个密钥， 然后把密钥发给我， 咱们这就开启加密消息， 让那些偷窥狂人们哭去吧！”</p><p>（码农翻身注：这叫<code>对称加密算法</code>， 因为加密和解密用的是同一个密钥）</p><p>一炷香功夫过去了， Bill 还是没有回音， 张大胖忍不住地催促： “快发啊？！！！”</p><p>Bill 终于回复了： “ 我感觉有一双眼睛正在虎视眈眈地盯着我们的通话， 如果我把密钥发给你， 也被他截取了， 那加密岂不白费工夫？”</p><p>张大胖沉默了， 是啊， 网络是不安全的， 这密钥怎么安全地发过来啊 ？　</p><p>“奥，对了，我下周要去米国旅游，到时候我们见一面，把密码确定下来，写到纸上，谁也偷不走， 这不就结了？”　</p><p>“哈哈， 这倒是终极解决之道 ”  Bill 笑了， “不过，我不仅仅和你聊天， 我还要和易卜拉欣，阿卜杜拉， 弗拉基米尔，克里斯托夫，玛格丽特， 桥本龙太郎， 李贤俊， 许木木，郭芙蓉，吕秀才等人通信， 我总不能打着飞的，满世界的和人交换密码吧？ ”</p><p>张大胖心里暗自佩服Bill同学的好友竟然遍布全球，看来他对加密通信的要求更加强烈啊！</p><p>可是这个加密解密算法需要的密钥双方必须得知道啊， 但是密钥又无法通过网络发送， 这该死的偷窥者！</p><h1 id="3-RSA-非对称加密"><a href="#3-RSA-非对称加密" class="headerlink" title="3. RSA : 非对称加密"></a>3. RSA : 非对称加密</h1><p>Bill 和 张大胖的通信无法加密，说话谨慎了不少， 直到有一天， 他们听说了一个叫做RSA的<code>非对称加密算法</code>，一下子来了灵感。</p><p>这个<code>RSA算法</code>非常有意思，它不是像之前的算法， 双方必须协商一个保密的密钥， 而是有一对儿钥匙， 一个是保密的，称为<code>私钥</code>，另外一个是公开的，称为<code>公钥</code>。</p><p>更有意思的是，<code>用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据， 只有对应的私钥才能解密。</code></p><p><img src= "/img/loading.gifs" data-src="/images/posts/tu2.png" alt=""></p><p>有了这两个漂亮的特性， 当张大胖给Bill发消息的时候， 就可以先用Bill的公钥去加密（反正Bill的公钥是公开的，地球人都知道）， 等到消息被Bill 收到后， 他就可以用自己的私钥去解密（只有Bill才能解开，私钥是保密的 ）</p><p><img src= "/img/loading.gifs" data-src="/images/posts/tu3.png" alt=""></p><p>反过来也是如此， 当Bill 想给张大胖发消息的时候，就用张大胖的公钥加密， 张大胖收到后，就用自己的私钥解密。</p><p>这样以来，通信安全固若金汤， 没有任何人能窥探他们的小秘密了。</p><h1 id="4-非对称加密-对称加密"><a href="#4-非对称加密-对称加密" class="headerlink" title="4. 非对称加密+对称加密"></a>4. 非对称加密+对称加密</h1><p>两人实验了几次，  张大胖说： “Bill  , 你有没有感觉这个RSA的加密和解密有点慢啊？”</p><p>Bill叹了口气 ：“是啊， 我也注意到了， 刚才搜了一下，这个RSA算法比之前的对称密钥算法要慢上百倍。我们就是加个密而已，现在搞得都没法用了”</p><p>“回到咱们最初的问题，我们想用一个密钥来加密通信，那个对称加密算法是非常快的，但是苦于密钥无法安全传输， 现在有了RSA ,我想可以结合一下， 分两步走　<code>(1) 我生成一个对称加密算法的密钥， 用RSA的方式安全发给你，  (2) 我们随后就不用RSA了， 只用这个密钥，利用对称加密算法来通信,  如何？ ”</code></p><p>Bill 说： “你小子可以啊， 这样以来既解决了密钥的传递问题， 又解决了RSA速度慢的问题，不错。”　</p><p>于是两人就安全地传递了对称加密的密钥， 用它来加密解密，果然快多了！</p><h1 id="5-中间人攻击"><a href="#5-中间人攻击" class="headerlink" title="5. 中间人攻击"></a>5. 中间人攻击</h1><p>张大胖把和Bill 聊天的情况给老婆汇报了一次。</p><p>老婆告诫他说： “你要小心啊， 你确定网络那边坐着的确实是Bill ?”</p><p>张大胖着急地辩解说：“肯定是他啊，我都有他的公钥，我们俩的通信都是加密的。”</p><p>老婆提醒道：＂假如啊，Bill给你发公钥的时候， 有个中间人，截取了Bill的公钥， 然后把自己的公钥发给了你，冒充Bill ，你发的消息就用中间人的公钥加了密，　那中间人不就可以解密看到消息了？＂</p><p>张大胖背后出汗了，是啊，这个中间人解密以后，还可以用Bill的公钥加密，发给Bill ,  Bill和我根本都意识不到， 还以为我们在安全传输呢！</p><p><img src= "/img/loading.gifs" data-src="/images/posts/tu4.png" alt=""></p><p><code>看来问题出现在公钥的分发上！</code>  虽然这个东西是公开的， 但是在别有用心的人看来，截取以后还可以干坏事 ！</p><h1 id="6-你到底是谁？"><a href="#6-你到底是谁？" class="headerlink" title="6. 你到底是谁？"></a>6. 你到底是谁？</h1><p>但是怎么安全地分发公钥呢？ 似乎又回到了最初的问题： 怎么安全的保护密钥？</p><p>可是似乎和最初的问题还不一样，这一次的公钥不用保密，但是一定得有个办法<code>声明这个公钥确实是Bill的</code>， 而不是别人的。</p><p>怎么声明呢？</p><p>张大胖突然想到： 现实中有公证处，它提供的公证材料大家都信任，那在网络世界也可以建立一个这样的具备公信力的认证中心， 这个中心给大家颁发一个证书， 用于证明一个人的身份。</p><p>这个证书里除了包含一个人的基本信息之外，还有包括最关键的一环：这个人的公钥！</p><p>这样以来我拿到证书就可以安全地取到公钥了 ！ 完美！</p><p>可是Bill 马上泼了一盆冷水：证书怎么安全传输？ 要是证书传递的过程中被篡改了怎么办？</p><p>张大胖心里不由地咒骂起来： 我操， 这简直就是鸡生蛋，蛋生鸡的问题啊。</p><p>天无绝人之路， 张大胖很快就找到了突破口： <code>数字签名。</code></p><p>简单来讲是这样的， Bill可以把他的公钥和个人信息用一个Hash算法生成一个消息摘要， 这个Hash算法有个极好的特性，<code>只要输入数据有一点点变化，那生成的消息摘要就会有巨变</code>，这样就可以防止别人修改原始内容。</p><p><img src= "/img/loading.gifs" data-src="/images/posts/tu5.png" alt=""></p><p>可是作为攻击者的中间人笑了： “虽然我没办法改公钥，但是我可以把整个原始信息都替换了， 生成一个新的消息摘要， 你不还是辨别不出来？”</p><p>张大胖说你别得意的太早 ， 我们会让有公信力的认证中心<code>（简称CA）</code>用它的私钥对消息摘要加密，形成签名：</p><p><img src= "/img/loading.gifs" data-src="/images/posts/tu6.png" alt=""></p><p>这还不算， 还把原始信息和数据签名合并， 形成一个全新的东西，叫做“<code>数字证书</code>”</p><p><img src= "/img/loading.gifs" data-src="/images/posts/tu7.png" alt=""></p><p>张大胖接着说：当Bill把他的证书发给我的时候， 我就用同样的Hash 算法， 再次生成消息摘要，然后用CA的公钥对数字签名解密， 得到CA创建的消息摘要， 两者一比，就知道有没有人篡改了！</p><p>如果没人篡改， 我就可以安全的拿到Bill的公钥喽，有了公钥， 后序的加密工作就可以开始了。</p><p>虽然很费劲， 但是为了防范你们这些偷窥者，实在是没办法啊。</p><p><img src= "/img/loading.gifs" data-src="/images/posts/tu8.png" alt=""></p><p>中间人恶狠狠地说： “算你小子狠！ 等着吧，我还有别的招。 对了，我且问你， 你这个CA的公钥怎么拿到？　难道不怕我在你传输ＣＡ公钥的时候发起中间人攻击吗？　如果我成功的伪装成了ＣＡ，你这一套体系彻底玩完。”</p><p>张大胖语塞了，折腾了半天，又回到了公钥安全传输的问题！</p><p>不过转念一想，想解决鸡生蛋，蛋生鸡的问题必须得打破这个怪圈才行，我必须得信任ＣＡ，并且通过安全的的方式获取他们的公钥，这样才能把游戏玩下去。</p><p>（注：这些ＣＡ本身也有证书来证明自己的身份，并且ＣＡ的信用是像树一样分级的，高层的ＣＡ给底层的ＣＡ做信用背书，而操作系统／浏览器中会内置一些顶层的ＣＡ的证书，相当于你自动信任了他们。　这些顶层的ＣＡ证书一定得安全地放入操作系统／浏览器当中，否则世界大乱。）</p><h1 id="7-https"><a href="#7-https" class="headerlink" title="7. https"></a>7. https</h1><p>终于可以介绍https了，前面已经介绍了https的原理， 你把张大胖替换成浏览器， 把Bill 替换成某个网站就行了。</p><p>一个<code>简化的（例如下图没有包含Pre-Master Secret）https流程图</code>是这样的， 如果你理解了前面的原理，这张图就变得非常简单：</p><p><img src= "/img/loading.gifs" data-src="/images/posts/tu9.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 网络通讯协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git详解</title>
      <link href="/2020/07/24/git%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/07/24/git%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Git是什么（what）"><a href="#1-Git是什么（what）" class="headerlink" title="1. Git是什么（what）"></a>1. Git是什么（what）</h1><h2 id="（-）概述"><a href="#（-）概述" class="headerlink" title="（-）概述"></a>（-）概述</h2><p>Git是分布式版本控制系统，与SVN类似的集中化版本控制系统相比，集中化版本控制系统如果中央服务器宕机则会影响数据和协同开发。</p><p>Git是分布式的版本控制系统，客户端不只是提取最新版本的快照，而且将整个代码仓库镜像复制下来。如果任何协同工作用的服务器发生故障了，也可以用任何一个代码仓库来恢复。而且在协作服务器宕机期间，你也可以提交代码到本地仓库，当协作服务器正常工作后，你再将本地仓库同步到远程仓库。</p><h2 id="（二）特性"><a href="#（二）特性" class="headerlink" title="（二）特性"></a>（二）特性</h2><ul><li>能够对文件版本控制和多人协作开发</li><li>拥有强大的分支特性，所以能够灵活地以不同的工作流协同开发</li><li>分布式版本控制系统，即使协作服务器宕机，也能继续提交代码或文件到本地仓库，当协作服务器恢复正常工作时，再将本地仓库同步到远程仓库。</li><li>当团队中某个成员完成某个功能时，通过<code>pull request</code>操作来通知其他团队成员，其他团队成员能够<code>review code</code>后再合并代码。</li></ul><h1 id="2-为什么要用Git（why）"><a href="#2-为什么要用Git（why）" class="headerlink" title="2. 为什么要用Git（why）"></a>2. 为什么要用Git（why）</h1><ul><li>能够对文件版本控制和多人协作开发</li><li>拥有强大的分支特性，所以能够灵活地以不同的工作流协同开发</li><li>分布式版本控制系统，即使协作服务器宕机，也能继续提交代码或文件到本地仓库，当协作服务器恢复正常工作时，再将本地仓库同步到远程仓库。</li><li>当团队中某个成员完成某个功能时，通过pull request操作来通知其他团队成员，其他团队成员能够review code后再合并代码。</li></ul><h1 id="3-如何使用Git（how）"><a href="#3-如何使用Git（how）" class="headerlink" title="3. 如何使用Git（how）"></a>3. 如何使用Git（how）</h1><h2 id="（-）Git的命令"><a href="#（-）Git的命令" class="headerlink" title="（-）Git的命令"></a>（-）Git的命令</h2><p><img src= "/img/loading.gifs" data-src="/images/git/git2.png" alt=""></p><ul><li>Workspace：工作区</li><li>Index / Stage：暂存区</li><li>Repository：仓库区（或本地仓库）</li><li>Remote：远程仓库</li></ul><h3 id="3-1-新建代码库"><a href="#3-1-新建代码库" class="headerlink" title="3.1 新建代码库"></a>3.1 新建代码库</h3><p>#在当前目录新建一个Git代码库<br><code>git init</code><br>#新建一个目录，将其初始化为Git代码库<br><code>git init [project-name]</code><br>#下载一个项目和它的整个代码历史<br><code>git clone [url]</code></p><h3 id="3-2-配置"><a href="#3-2-配置" class="headerlink" title="3.2 配置"></a>3.2 配置</h3><p>Git的设置文件为.gitconfig，它可以在用户主目录行哦啊（全局配置），也可以在项目目录下（项目配置）。</p><p>#显示当前的Git配置<br><code>git config --list</code><br>#编辑Git配置文件<br><code>git config -e [--global]</code><br>#设置提交代码时的用户信息<br><code>git config [--global] user.name &quot;[name]&quot;</code><br><code>git config [--global] user.email &quot;[email address]&quot;</code></p><h3 id="3-3-增加-删除文件"><a href="#3-3-增加-删除文件" class="headerlink" title="3.3 增加/删除文件"></a>3.3 增加/删除文件</h3><p>#添加指定文件到暂存区<br><code>git add [file1] [file2] ...</code><br>#添加指定目录到暂存区，包括子目录<br><code>git add [dir]</code><br>#添加当前目录的所有文件到暂存区<br><code>git add .</code><br>#添加每个变化前，都会要求确认<br>#对于同一个文件的多处变化，可以实现分次提交<br><code>git add -p</code><br>#删除工作区文件，并且将这次删除放入暂存区<br><code>git rm [file1] [file2] ...</code><br>#停止追踪指定文件，但该文件会保留在工作区<br><code>git rm --cached [file]</code><br>#改名文件，并且将这个改名放入暂存区<br><code>git mv [file-original] [file-renamed]</code></p><h3 id="3-4-代码提交"><a href="#3-4-代码提交" class="headerlink" title="3.4 代码提交"></a>3.4 代码提交</h3><p>#提交暂存区到仓库区<br><code>git commit -m [message]</code><br>#提交暂存区的指定文件到仓库区<br><code>git commit [file1] [file2] ... -m [message]</code><br>#提交工作区自上次commit之后的变化，直接到仓库区<br><code>git commit -a</code><br>#提交时显示所有diff信息<br><code>git commit -v</code><br>#使用一次新的commit，替代上一次提交<br>#如果代码没有任何新变化，则用来改写上一次commit的提交信息<br><code>git commit --amend -m [message]</code><br>#重做上一次commit，并包括指定文件的新变化<br><code>git commit --amend [file1] [file2] ...</code></p><h3 id="3-5-分支"><a href="#3-5-分支" class="headerlink" title="3.5 分支"></a>3.5 分支</h3><p>#列出所有本地分支<br><code>git branch</code><br>#列出所有本地分支<br><code>git branch -a</code><br>#新建一个分支，但依然停留在当前分支<br><code>git branch [branch-name]</code><br>#新建一个分支，并切换到该分支<br><code>git checkout -b [branch]</code><br>#新建一个分支，指向指定commit<br><code>git branch [branch] [commit]</code><br>#新建一个分支，与指定的远程分支建立追踪关系<br><code>git branch --track [branch] [remote-branch]</code><br>#切换到指定分支，并更新工作区<br><code>git checkout [branch-name]</code><br>#切换到上一个分支<br><code>git checkout -</code><br>#建立追踪关系，在现有分支与指定的远程分支之间<br><code>git branch --set-upstream [branch] [remote-branch]</code><br>#合并指定分支到当前分支<br><code>git merge [branch]</code><br>#选择一个commit，合并进当前分支<br><code>git cherry-pick [commit]</code><br>#删除分支<br><code>git push origin --delete [branch-name]</code><br><code>git branch -dr [remote/branch]</code></p><h3 id="3-6-标签"><a href="#3-6-标签" class="headerlink" title="3.6 标签"></a>3.6 标签</h3><p>#列出所有tag<br><code>git tag</code><br>#新建一个tag在当前commit<br><code>git tag [tag]</code><br>#新建一个tag在指定commit<br><code>git tag [tag] [commit]</code><br>#删除本地tag<br><code>git tag -d [tag]</code><br>#删除远程tag<br><code>git push origin :refs/tags/[tagName]</code><br>#查看tag信息<br><code>git show [tag]</code><br>#提交指定tag<br><code>git push [remote] [tag]</code><br>#提交所有tag<br><code>git push [remote] --tags</code><br>#新建一个分支，指向某个tag<br><code>git checkout -b [branch] [tag]</code></p><h3 id="3-7-查看信息"><a href="#3-7-查看信息" class="headerlink" title="3.7 查看信息"></a>3.7 查看信息</h3><p>#列出所有tag<br><code>git tag</code><br>#新建一个tag在当前commit<br><code>git tag [tag]</code><br>#新建一个tag在指定commit<br><code>git tag [tag] [commit]</code><br>#删除本地tag<br><code>git tag -d [tag]</code><br>#删除远程tag<br><code>git push origin :refs/tags/[tagName]</code><br>#查看tag信息<br><code>git show [tag]</code><br>#提交指定tag<br><code>git push [remote] [tag]</code><br>#提交所有tag<br><code>git push [remote] --tags</code><br>#新建一个分支，指向某个tag<br><code>git checkout -b [branch] [tag]</code></p><h3 id="3-8-远程同步"><a href="#3-8-远程同步" class="headerlink" title="3.8 远程同步"></a>3.8 远程同步</h3><p>#下载远程仓库的所有变动<br><code>git fetch [remote]</code><br>#显示所有远程仓库<br><code>git remote -v</code><br>#显示某个远程仓库的信息<br><code>git remote show [remote]</code><br>#增加一个新的远程仓库，并命名<br><code>git remote add [shortname] [url]</code><br>#取回远程仓库的变化，并与本地分支合并<br><code>git pull [remote] [branch]</code><br>#上传本地指定分支到远程仓库<br><code>git push [remote] [branch]</code><br>#强行推送当前分支到远程仓库，即使有冲突<br><code>git push [remote] --force</code><br>#推送所有分支到远程仓库<br><code>git push [remote] --all</code></p><h3 id="3-9-撤销"><a href="#3-9-撤销" class="headerlink" title="3.9 撤销"></a>3.9 撤销</h3><p>#恢复暂存区的指定文件到工作区<br><code>git checkout [file]</code><br>#恢复某个commit的指定文件到暂存区和工作区<br><code>git checkout [commit] [file]</code><br>#恢复暂存区的所有文件到工作区<br><code>git checkout .</code><br>#重置暂存区的指定文件，与上一次commit保持一致，但工作区不变<br><code>git reset [file]</code><br>#重置暂存区与工作区，与上一次commit保持一致<br><code>git reset --hard</code><br>#重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变<br><code>git reset [commit]</code><br>#重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致<br><code>git reset --hard [commit]</code><br>#重置当前HEAD为指定commit，但保持暂存区和工作区不变<br><code>git reset --keep [commit]</code><br>#新建一个commit，用来撤销指定commit<br>#后者的所有变化都将被前者抵消，并且应用到当前分支<br><code>git revert [commit]</code><br>#暂时将未提交的变化移除，稍后再移入<br><code>git stash</code><br><code>git stash pop</code></p><h3 id="3-10-其他"><a href="#3-10-其他" class="headerlink" title="3.10 其他"></a>3.10 其他</h3><p>#生成一个可供发布的压缩包<br><code>git archive</code><br>#设置换行符为LF<br><code>git config --global core.autocrlf false</code><br>#拒绝提交包含混合换行符的文件<br><code>git config --global core.safecrlf true</code></p><h1 id="4-Git命令思维导图"><a href="#4-Git命令思维导图" class="headerlink" title="4. Git命令思维导图"></a>4. Git命令思维导图</h1><p><img src= "/img/loading.gifs" data-src="/images/git/git3.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> git详解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决hexo博客文章太长导致的显示不全的问题</title>
      <link href="/2020/07/24/%E8%A7%A3%E5%86%B3hexo%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%A4%AA%E9%95%BF%E5%AF%BC%E8%87%B4%E7%9A%84%E6%98%BE%E7%A4%BA%E4%B8%8D%E5%85%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2020/07/24/%E8%A7%A3%E5%86%B3hexo%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%A4%AA%E9%95%BF%E5%AF%BC%E8%87%B4%E7%9A%84%E6%98%BE%E7%A4%BA%E4%B8%8D%E5%85%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h1><p>前两天准备发布上一篇介绍<code>https</code>的文章,结果写好markdown之后本地测试发现问题:</p><ul><li>文章显示最后内容突然缺失</li><li>导航栏，底部的返回顶部按钮均异常</li><li>查看网页源代码，发现内容消失的地方之后内容全部是空格</li></ul><p>尝试解决问题,发现文章变短显示就正常,使用hexo新建blog,测试长文显示OK,换上同样的主题也没问题,说明是我的环境配置哪里出错.</p><h1 id="2-解决"><a href="#2-解决" class="headerlink" title="2. 解决"></a>2. 解决</h1><p>折腾几天,重装hexo-xx相关库,更新hexo版本,库版本,拿出错的配置和正常的去比较,终于发现问题出现在<br>package.json的“hexo-browsersync”: “^0.3.0”, 将这一行注释掉或者删除就OK<br>然后来到这个库的github的issues,发现不少人也遇到了这个问题,可惜我是找了好久才发现</p><h1 id="3-其他"><a href="#3-其他" class="headerlink" title="3. 其他"></a>3. 其他</h1><p>另外总结其他遇到的问题</p><h3 id="hexo-server报错："><a href="#hexo-server报错：" class="headerlink" title="hexo server报错："></a>hexo server报错：</h3><p><code>Cannot GET /</code></p><p>解决方案：<code>npm audit fix</code> 查看缺少哪些模块，<code>npm install xxx</code> 安装</p><h3 id="检查hexo相关库："><a href="#检查hexo相关库：" class="headerlink" title="检查hexo相关库："></a>检查hexo相关库：</h3><ul><li>npm install -g npm-check</li><li>npm-check</li><li>npm install -g npm-upgrade</li><li>npm-upgrade</li><li>npm install hexo –savess</li></ul>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo + github 快速搭建博客</title>
      <link href="/2020/07/01/hexo+github%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2020/07/01/hexo+github%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo-github-快速搭建博客"><a href="#hexo-github-快速搭建博客" class="headerlink" title="hexo + github 快速搭建博客"></a>hexo + github 快速搭建博客</h1><p>话不多说，咱们直接进入主题～</p><h2 id="1-新建城池"><a href="#1-新建城池" class="headerlink" title="1.新建城池"></a>1.新建城池</h2><p>既然要给人访问，如果没有存放代码的地方，既不是白日做梦了，首先上 全球最大同性交友网站 <code>github</code> 新建一个仓库，仓库名必须为 <code>&lt;user-name&gt;.github.io</code>, 其中 <code>&lt;user-name&gt;</code> 就是我们github的昵称，<br>注意必须一样，不能自定义，不要问我为什么，问了我也不会说。</p><h2 id="2-手握神器"><a href="#2-手握神器" class="headerlink" title="2.手握神器"></a>2.手握神器</h2><p>打开命令行，输入下面的命令，全局安装神奇 <code>hexo</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g</span><br></pre></td></tr></table></figure><h2 id="3-组建大军"><a href="#3-组建大军" class="headerlink" title="3. 组建大军"></a>3. 组建大军</h2><p><code>hexo</code> 神器使用口诀如下 急急如律令，嘿嘿哈。。。sorry sorry 跑题了，口诀如下，所有口诀掐完，紧跟 <code>hexo s</code>，之后在浏览器访问 <code>localhost:4000</code> 神器搭配，手速要快。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init &#x2F;&#x2F; 初始化</span><br><span class="line"></span><br><span class="line">hexo s &#x2F;&#x2F; 本地服务启动</span><br></pre></td></tr></table></figure><p>我们的文件夹下的文件,主要关注以下几个文件</p><ul><li>source 里面存放我们的页面和文章 _post 下都是文章，其他则为页面</li><li>themes 里面是我们下载的主题</li><li>public 里面是我们编译后的文件</li><li>_config.yml 全局的一些配置</li></ul><h2 id="4-神器，城池，大军都有，该去收割一波了"><a href="#4-神器，城池，大军都有，该去收割一波了" class="headerlink" title="4.神器，城池，大军都有，该去收割一波了"></a>4.神器，城池，大军都有，该去收割一波了</h2><p>虽然此时咱们只要默认的一篇 <code>Hello World</code>, 也不能阻止我们想做最靓的仔的决心，首先在根目录下 <code>_config.yml</code>找到 <code>deploy</code>字段，然后使用绝技 <code>copy</code> 大法</p><h4 id="注意点，-github-记得这是-SSH-key-免密登陆-就不用手动了，不会的同学下课记得补习。"><a href="#注意点，-github-记得这是-SSH-key-免密登陆-就不用手动了，不会的同学下课记得补习。" class="headerlink" title="注意点， github 记得这是 SSH key 免密登陆 就不用手动了，不会的同学下课记得补习。"></a>注意点， github 记得这是 SSH key 免密登陆 就不用手动了，不会的同学下课记得补习。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: &lt;你的仓库地址&gt; # https:&#x2F;&#x2F;github.com&#x2F;14138993&#x2F;14138993.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>施展完毕，不过我们需要喝瓶 脉动 补充下体力进行最后的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 下载自动提交的 npm 包</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>是时候向世界证明我们的存在了，下面开始公布</p><p>ps: 不想手动敲这么多命令，下方有配置教你怎么偷懒哟</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &#x2F;&#x2F; 清除 pubkic</span><br><span class="line"></span><br><span class="line">hexo g &#x2F;&#x2F; 编译</span><br><span class="line"></span><br><span class="line">hexo d &#x2F;&#x2F; 提交</span><br></pre></td></tr></table></figure><h2 id="5-收获成果"><a href="#5-收获成果" class="headerlink" title="5. 收获成果"></a>5. 收获成果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问 https:&#x2F;&#x2F;&lt;user-name&gt;.github.io&#x2F; 查看效果。</span><br></pre></td></tr></table></figure><h3 id="课外知识点"><a href="#课外知识点" class="headerlink" title="课外知识点"></a>课外知识点</h3><ol><li>如何创建新页面，新文章？</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo new post xxx(文件名) &#x2F;&#x2F; 创建新文章</span><br><span class="line"></span><br><span class="line">hexo new page xxx(文件名) &#x2F;&#x2F; 创建新页面</span><br></pre></td></tr></table></figure><p>这里提一下 关于tags link categories 这三个页面 需要在对应md文件里增type 这个属性 值就是本身名字 例如 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">title: link</span><br><span class="line">type: link</span><br></pre></td></tr></table></figure><ol start="2"><li>更换主题皮肤</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 下载主题到themes文件夹下</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;butterfly&#x2F;hexo-theme-butterfly xxx&#x2F;themes</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 修改 根目录_config.yml 配置</span><br><span class="line">theme: 你的主题名称</span><br></pre></td></tr></table></figure><ol start="3"><li>中文乱码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 修改 根目录_config.yml 配置</span><br><span class="line">language: zh-CN &#x2F;&#x2F; 改为中文</span><br></pre></td></tr></table></figure><ol start="4"><li>部署优化</li></ol><p>国际惯例，能偷懒的绝不多写一个字母😂, 修改咱们的<code>package.json</code> 在 <code>script</code> 里增加命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;dev&quot;: &quot;hexo s&quot;, &#x2F;&#x2F; 本地启动</span><br><span class="line">&quot;build&quot;: &quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo deploy&quot; &#x2F;&#x2F; 一键部署到github</span><br></pre></td></tr></table></figure><p>到此搭建博客已经完成，但是你可能觉得美中不足</p><h2 id="优化点"><a href="#优化点" class="headerlink" title="优化点"></a>优化点</h2><h3 id="个人域名解析到github域名"><a href="#个人域名解析到github域名" class="headerlink" title="个人域名解析到github域名"></a>个人域名解析到github域名</h3><ol><li>上传到github后在根目录创建 <code>CNAME</code> 里面为自己的域名地址</li><li>在域名服务商将域名解析 不会的请百度，这里就不细说了</li></ol><h3 id="主题优化，评论功能等"><a href="#主题优化，评论功能等" class="headerlink" title="主题优化，评论功能等"></a>主题优化，评论功能等</h3><ol><li>直接去hexo 官网挑选喜欢的主题，一般主题都有详细的配置教程，跟着教程做</li><li>我的博客使用的是 <code>butterfly</code> 如果你觉得喜欢，或者觉得功能满足你，不想自己琢磨，可以直接<a href="https://github.com/14138993/book-config.git" target="_blank" rel="noopener">Fork</a> 一键使用</li><li>评论系统 我使用的是 <a href="https://valine.js.org/quickstart.html" target="_blank" rel="noopener">valine</a>, 如果你是fork我的 需要在 <code>source &gt; _data &gt; butterfly.yml</code> 里 <code>valine</code> 配置你的 <code>appID</code> 和 <code>appKey</code></li></ol><p>谢谢，到此结束</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
