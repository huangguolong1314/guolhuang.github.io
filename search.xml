<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis五大经典业务问题</title>
      <link href="/2023/12/14/redis/Redis%E4%BA%94%E5%A4%A7%E7%BB%8F%E5%85%B8%E4%B8%9A%E5%8A%A1%E9%97%AE%E9%A2%98/Redis%E4%BA%94%E5%A4%A7%E7%BB%8F%E5%85%B8%E4%B8%9A%E5%8A%A1%E9%97%AE%E9%A2%98/"/>
      <url>/2023/12/14/redis/Redis%E4%BA%94%E5%A4%A7%E7%BB%8F%E5%85%B8%E4%B8%9A%E5%8A%A1%E9%97%AE%E9%A2%98/Redis%E4%BA%94%E5%A4%A7%E7%BB%8F%E5%85%B8%E4%B8%9A%E5%8A%A1%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><img src= "/img/loading.gifs" data-src="/images/redis/cover.png" alt=""></p><h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><p>缓存穿透是指当请求的数据既不在缓存中也不存在于数据库中时，请求会直接穿透缓存层，到达数据库层。这通常是由于恶意攻击或者程序错误造成的，比如攻击者故意请求不存在的大量数据，导致缓存不命中，所有的请求都会落到数据库上，从而可能对数据库造成巨大的压力，影响其性能甚至导致崩溃通常是<code>thread_running</code>飙高。<br>解决方法：</p><ol><li>布隆过滤器（Bloom Filter）：布隆过滤器是一种数据结构，可以用来检测一个元素是否在一个集合中。在请求到达缓存之前，先通过布隆过滤器进行检查，如果布隆过滤器判断数据不存在，则直接返回错误响应，避免对数据库的访问。</li><li>缓存空结果：当查询数据库后发现数据不存在时，可以将这个”空结果”也缓存起来，并设置一个较短的过期时间。这样当再次请求相同的数据时，可以直接从缓存中获取到”空结果”，避免对数据库的访问。需要注意的是，这种方法可能会导致缓存被大量无用的空结果填满，所以需要合理设置过期时间。</li><li>限制请求：对于异常频繁的访问行为，可以采取限流、封禁IP等手段进行限制。例如，可以对每个用户的访问频率、请求的速度等进行限制，超过限制则暂时封禁其请求。</li><li>接口鉴权：在接口层做好身份验证和参数校验，不允许非法请求或者格式不正确的请求访问数据库。</li><li>数据库建立合理索引：对于一些必须要访问数据库的场景，确保数据库有好的查询性能，可以通过建立合理的索引来提高查询效率。</li><li>二级缓存：使用本地缓存作为一级缓存，Redis作为二级缓存。当本地缓存不命中时再查询Redis，如果Redis也不命中，最后才去查询数据库。这样可以减少直接对Redis的查询请求，降低Redis的压力。</li><li>前端控制：在前端应用中加强校验，比如表单校验、输入内容的合法性检查等，避免发送无效请求到后端。</li></ol><h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><p>缓存雪崩是指在缓存系统中，由于大量缓存数据在同一时间过期，或者缓存服务宕机，导致所有的请求都直接落到数据库上，造成数据库瞬间承受巨大的访问压力，从而变得不稳定甚至崩溃的现象。这类似于雪崩一样，一旦发生就会导致连锁反应，导致整个系统的性能急剧下降。<br>解决方法：</p><ol><li>缓存数据的过期时间随机化：设置缓存数据的过期时间时，不要让大量的缓存数据在同一时间点过期。可以对过期时间加上一个随机值，使得缓存数据的过期时间分散开来，防止在同一时刻大面积缓存失效。</li><li>使用持久化：如果缓存服务支持持久化，比如Redis的RDB和AOF，要确保开启并合理配置这些功能。这样，即使缓存服务重启，也能从持久化的数据中恢复，减少缓存雪崩的风险。</li><li>设置热点数据永不过期：对于一些热点数据，可以设置为永不过期，或者采用手动更新缓存的策略，避免这些热点数据集体过期。</li><li>使用多级缓存策略：可以使用本地缓存（如Ehcache）和分布式缓存（如Redis）结合的多级缓存策略，即使分布式缓存不可用，本地缓存仍然可以提供服务，减少对数据库的直接压力。</li><li>提升缓存服务的高可用性：使用主从复制、哨兵机制、集群等高可用方案来确保缓存服务的稳定性。即便单个节点出现故障，也能快速切换到正常的节点，保障缓存服务不中断。</li><li>限流和熔断机制：在系统中实施限流和熔断机制，当流量或错误超过一定阈值时，暂时阻止部分请求，保护数据库和系统不被过载。</li><li>异步队列：当缓存失效后，可以将数据库的读取操作放入异步队列中，用异步处理的方式来缓解瞬时流量对数据库的冲击。</li></ol><h1 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h1><p>缓存击穿指的是缓存中没有但数据库中有的数据（一般是热点数据）在缓存失效的瞬间，同时有大量并发请求这个数据点，这些请求会直接穿透缓存，全部落到数据库上，造成数据库短时间内的高压力。这与缓存穿透不同，缓存穿透是查询不存在的数据，而缓存击穿则是查询存在但是缓存刚好失效的数据。<br>解决方法：</p><ol><li>使用互斥锁：对于同一个数据点，在缓存失效时，通过加锁或同步机制，保证不管有多少并发请求，只允许一个请求去数据库查询数据，并更新缓存，其他请求等待缓存被更新后直接从缓存中获取数据。常见的做法是使用分布式锁。</li><li>设置热点数据永不过期：对于一些访问频率非常高的热点数据，可以设置缓存永不过期，或者缓存失效后由后台维护线程负责更新，而不是由用户请求触发更新。</li><li>使用双缓存机制（Cache Aside pattern）：当缓存失效时，并不立即删除缓存，而是使用另一个缓存进行更新操作。在新缓存更新完成之前，所有的读请求仍然访问的是旧的缓存。更新完成后再进行切换。</li><li>提前更新缓存：对于即将到期的数据，可以通过定时任务来检测并更新它。当检测到缓存数据即将到期时，可以提前异步地更新缓存。</li><li>给缓存设置合理的过期时间：对于一些热点数据，根据业务场景设置合理的过期时间，避免大量并发请求在同一时刻击穿缓存。</li><li>分布式缓存+本地缓存：可以在本地实现一层缓存，以减少对分布式缓存服务的访问频率，即使分布式缓存服务的数据过期，本地缓存仍然可以提供服务。</li><li>读写分离和负载均衡：数据库使用读写分离架构和负载均衡策略，将读操作分散到多个从库，减少对主库的直接压力。</li></ol><h1 id="数据不一致"><a href="#数据不一致" class="headerlink" title="数据不一致"></a>数据不一致</h1><p>缓存和数据库数据不一致的问题通常是由于缓存层与数据库层之间的数据同步策略不当导致的。这可能发生在以下几种情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 写操作没有同时更新缓存与数据库。</span><br><span class="line">2. 缓存过期或被删除，而数据库中的数据在此期间被修改。</span><br><span class="line">3. 分布式系统中由于网络延迟或其他问题导致的数据同步延迟。</span><br><span class="line">4. 数据库事务回滚，但缓存更新已经发生。</span><br></pre></td></tr></table></figure><p>这些问题可能导致用户获取到过时的数据，影响用户体验，并可能引发更严重的数据一致性问题。<br>解决方法：</p><ol><li>缓存更新策略：<br> 缓存延迟双删：更新数据库数据后，先删除缓存，然后延迟一小段时间再次删除缓存，以确保请求在这段时间内若读取了旧数据，也会再次删除缓存，从而读到最新数据。Write/Read Through Cache：利用缓存提供的写通(Writethrough)或读取通(Read through)策略，让缓存管理器负责数据的读写，确保数据的一致性。Write Behind Caching：更新操作首先在缓存中执行，然后异步批量更新到数据库，这种策略要考虑数据丢失的风险和数据一致性的问题</li><li>数据库触发器：使用数据库触发器在数据发生变化时自动更新缓存，确保数据一致性。</li><li>事务消息：通过使用支持事务的消息队列，将缓存操作和数据库操作放到同一个事务中，确保两者要么都成功，要么都失败。</li><li>最终一致性：接受在某个时间窗口内缓存与数据库中的数据不一致，但是通过后台异步进程定期校对并同步数据，保证最终一致性。</li><li>使用分布式缓存解决方案：选择支持一致性哈希、数据同步等特性的分布式缓存解决方案，如Redis Cluster，保证数据在多个节点之间的一致性。</li><li>版本号/时间戳校验：给数据库记录添加版本号或时间戳，缓存数据时一同缓存这个版本信息，每次读取缓存数据时都检查版本或时间戳是否相符，若不符则重新从数据库加载。</li><li>强制缓存过期：设置较短的缓存过期时间，确保数据定期从数据库中刷新。</li></ol><h1 id="数据并发竞争"><a href="#数据并发竞争" class="headerlink" title="数据并发竞争"></a>数据并发竞争</h1><p>数据并发竞争访问问题，通常指的是多个客户端或线程同时对同一数据进行读写操作时，由于没有妥善的并发控制措施导致数据出现不一致或者丢失的情况。这个问题在分布式系统和多用户系统中尤为常见，尤其是在使用像Redis这样的缓存系统时也会遇到。出现问题的场景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 计数器更新：比如用Redis计数器统计网站点击量，如果多个请求同时更新计数器，可能会因为读写操作不是原子性导致计数器丢失更新。</span><br><span class="line">2. 库存扣减：在电商场景中，多个用户同时下单扣减库存，可能会导致超卖。</span><br><span class="line">3. 分布式锁：多个进程需要对同一资源进行操作时，需要使用锁来保证同时只有一个操作可以执行。</span><br><span class="line">4. Session共享：在分布式部署的Web应用中，多个服务器上的并发请求需要共享Session信息，可能导致Session数据不一致。</span><br></pre></td></tr></table></figure><p>解决方法：</p><ol><li>使用事务：Redis事务可以通过MULTI和EXEC命令来确保一系列命令的原子性执行。</li><li>使用Lua脚本：Redis可以执行Lua脚本，Lua脚本在执行过程中会被当作一个整体执行，这保证了操作的原子性。</li><li>使用分布式锁：可以实现一个基于Redis的分布式锁来控制资源的并发访问。比如使用SETNX命令实现锁的获取和释放。</li><li>乐观锁/Optimistic Locking：使用WATCH命令监视一个或多个键，如果在执行事务前这些键没有被其他命令改变，事务才会被执行。</li><li>悲观锁/Pessimistic Locking：对于关键业务，可以选择先对数据加锁，在业务处理完成后再解锁，避免其他客户端的访问。</li><li>限流措施：通过限流算法如令牌桶、漏桶等，控制对某一资源的并发访问数，减少并发冲突。</li><li>消息队列：使用消息队列将并发请求串行化处理，确保对共享资源的访问是有序的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql实战进阶-1.一条SQL查询语句是如何执行的？</title>
      <link href="/2023/12/07/mysql/MySql%E5%AE%9E%E6%88%98%E8%BF%9B%E9%98%B6/1.%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/"/>
      <url>/2023/12/07/mysql/MySql%E5%AE%9E%E6%88%98%E8%BF%9B%E9%98%B6/1.%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p><img src= "/img/loading.gifs" data-src="/images/MySql_shizhan/1/1-1.png" alt=""></p><ol><li><p>查询缓存</p><ul><li>1.1 当MySql拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句，之前执行过的语句及其结果可能会以key-value的形式被直接缓存在内存中。key是查询的语句，value是查询的结果，如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端，如果语句不在查询缓存中，就会继续后面的执行阶段，执行完成后，执行结果会被存入查询缓存中。如果命中查询缓存MySQL不需要执行后面的复杂操作就可以直接返回结果，这个效率会很高。<code>但是大多数情况下不建议使用查询缓存，因为查询缓存往往弊大于利。</code>，查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空，因此很可能费劲的把结果存起来，还没使用就被一个更新全部清空了，对于更新压力大的数据库来说，查询缓存的命中率非常低，除非你的业务就是有一张静态表，很长时间才会更新一次，比如一个系统配置表，那这张表上的查询才适合使用查询缓存。好在MySQL也提供了这种<code>按需使用</code>的方式。你可以将参数<code>query_cache_type</code>设置成DEMAND，这样对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用<code>SQL_CACHE</code>显示指定，像下面这个语句一样：<code>SELECT * SQL_CACHE * FROM T WHERE ID =10;</code>，需要注意的是，MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有这个功能了。</li></ul></li><li><p>分析器</p><ul><li>2.1 </li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAP理论&amp;BASE理论.</title>
      <link href="/2023/07/18/cap&amp;base/CAP%E7%90%86%E8%AE%BA&amp;BASE%E7%90%86%E8%AE%BA/"/>
      <url>/2023/07/18/cap&amp;base/CAP%E7%90%86%E8%AE%BA&amp;BASE%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<ol><li><p><code>C（    Consistency）</code>一致性：意思是，写操作之后的读操作，必须返回该值，举例：某条数据记录是v0，用户向G1发起一个写操作，将其改为v1，接下来，用户的读操作就会得到v1，这就叫一致性。问题是，用户有可能向G2发起该操作，由于G2的值没有发生变化，因此返回的是v1，G1和G2读操作的结果不一致，这就不满足一致性了。<br><img src= "/img/loading.gifs" data-src="/images/cap&base/1.png" alt=""><br>为了让G2也能变为G1，就要在G1写操作的时候，让G1和G2发送一条消息，要求G2页改成v1，这样的话，用户向G2发起读操作，也能得到v1。</p></li><li><p><code>A（    Availability）</code>可用性：意思是只要收到用户的请求，服务器就必须给出回应，用户可以选择向G1或G2发起读操作，不管是哪台服务器，只要收到请求，就必须告诉用户，到底是v0还是v1，否则就不满足可用性。</p></li><li><p><code>P（    Partition tolerance）</code>分区容错：大多数分布式系统都分布在多个子网络，每个子网络就叫做一个区，分区容错的意思是，区间通信可能失败，比如一台服务器放在中国，另一台服务器放在美国，这就是两个区，它们之间可能无法通信，在系统设计的时候必须考虑到这种情况。<br><img src= "/img/loading.gifs" data-src="/images/cap&base/2.png" alt=""><br><code>C（Consistency）和A（Availability）</code>的矛盾：一致性和可用性，为什么不可能同时成立？因为可能通信失败（即出现分区容错）。如果保证G2的一致性，那么G1必须在写 操作时，锁定G2的读操作和鞋操作，只有数据同步后，才能重新开放读写，锁定期间G2不能读写，没有可用性。如果保证G2的可用性，那么势必不能锁定G2，所以一致性就不成立。综上所述，G2无法同时做到一致性和可用性，系统设计时只能选择一个目标，如果追求一致性，那么无法保证所有节点的可用性；如果追求所有节点的可用性，那就没法做到一致性。<br>在什么场合，可用性高于一致性？<br>举例来说，发布一张网页到CDN，多个服务器有这张网页的副本，后来发现一个错误，需要更新网页，这时只能每个服务器都更新一遍，一般来说，网页的更新不是特别强调一致性。短时期内，一些用户拿到老版本，另一些用户拿到新版本，问题不会特别大。当然所有人最终都会看到新版本。所以这个场合就是可用性高于一致性。</p></li></ol><p><code>Consistency（一致性-节点系统中所有可用的数据）</code>：在分布式环境下，一致性是指数据在多个副本之间能否保持一致的特性。在一致性的需求下，当一个系统在数据一致的状态下执行更新操作后，应该保证系统的数据仍然处于一致的状态；<br><code>Availability（可用性-每个请求会得到一个响应）</code>：可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。这里的重点是“有限时间内”和“返回结果”；<br><code>Partition Tolerance（分区容错性-系统运作将不管可用性、分区、数据或通信的丢失）</code>：分区容错性约束了一个分布式系统具有如下特性：分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障；</p><ol start="4"><li>BASE<br><code>Basically Available（基本可用）</code>：分布式系统在出现不可预知故障的时候，允许损失部分可用性；<br><code>Soft state（软状态）</code>：软状态也称为弱状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不通节点的数据副本之间进行数据同步的过程存在延时；<br><code>Eventually consistent（最终一致性）</code>：最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性；</li></ol>]]></content>
      
      
      <categories>
          
          <category> cap&amp;base </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组与链表</title>
      <link href="/2023/07/18/data_struct/%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/07/18/data_struct/%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>线性的：就是连成一条线的结构，数组和链表就属于这一类，另外还有队列、栈等。<br>非线性的：顾名思义，数据之间的关系是非线性的，比如堆、树、图等。<br>数组是一个有限的、类型相同的数据的集合，在内存中是一段连续的内存区域。如下图：<br><img src= "/img/loading.gifs" data-src="/images/data_struct/1.png" alt=""><br>数组的下标是从0快开始的，上图数组中有6个元素，对应着下标依次是0、1、2、3、4、5，同时，数组里面存的数据的类型必须是一致的，比如上图中存的都是数字类型。数组中的全部元素是“连续”的存储在一块内存空间中的，如上图右边部分，元素与元素之间是不会有别的存储隔离的。另外，也是因为数组需要连续的内存空间，所以数组在定义的时候就需要以前指定固定大小，不能改变。</p><h2 id="1-数组"><a href="#1-数组" class="headerlink" title="1.数组"></a>1.数组</h2><h3 id="1-1-数组的访问"><a href="#1-1-数组的访问" class="headerlink" title="1.1 数组的访问"></a>1.1 数组的访问</h3><p>数组在访问操作方面有着独特的性能优势，因为数组是支持随机访问的，也就是说我们可以通过下标随机访问数组中任何一个元素，其原理是因为数组元素的存储是连续的，所以我们可以通过数组内存空间的首地址加上元素的偏移量计算出某一个元素的内存地址，如下：<br>array[n]的地址 = array数组内存空间的首地址 + 每个元素大小*n。<br>        通过上述公式可知：数组中通过下标去访问数据时并不需要遍历整个数据，因此数组的访问时间复杂度是O(1)，当然这里需要注意，如果不是通过下标去访问，而是通过内容去查找数组中的元素，则时间复杂度不是O(1)，极端情况下需要遍历整个数组的元素，时间复杂度可能是O(n)，当然通过不同的查找算法所需的时间复杂度是不一样的。</p><h3 id="1-2-数组的插入与删除"><a href="#1-2-数组的插入与删除" class="headerlink" title="1.2 数组的插入与删除"></a>1.2 数组的插入与删除</h3><p>同样是因为数组元素的连续性要求，所以导致数组在插入和删除元素的时候效率比较低。如果要在数组中间插入一个新元素，就必须要将相邻的后面的元素全部往后移动一个位置，留出空位给这个新元素。还是拿上图举例，如果需要在下标为2的地方插入一个新元素11，那就需要将原有的2、3、4、5几个下标的元素依次往后移动一位，新元素再插入下标为2的位置最后形成新的数据是：23、4、11、6、15、5、7。如果新元素是插入在数据的最开头位置，那整个原始数组都需要向后移动一位，此时的时间复杂度为最坏情况即O(n)，如果新元素要插入的位置是最末尾，则无需其他元素移动，此时时间复杂度为最好情况即O(1)，所以平均而言数组插入的时间复杂度是O(n)，数组的删除与数组的插入是类似的。所以整体而言，数组的访问效率高，插入与删除效率低。不过想改善数组的插入与删除效率也是有办法的，下面了解【链表】。</p><h2 id="2-链表"><a href="#2-链表" class="headerlink" title="2.链表"></a>2.链表</h2><p>链表是一种物理存储单元上非连续、非顺序的存储结构，数组元素的逻辑顺序是通过链表中的指针链接次序实现的，一般用于插入与删除较为频繁的场景。</p><h3 id="2-1-单向链表"><a href="#2-1-单向链表" class="headerlink" title="2.1 单向链表"></a>2.1 单向链表</h3><p><img src= "/img/loading.gifs" data-src="/images/data_struct/2.png" alt=""><br>上图是“单链表”示例，链表并不需要数组那样的连续空间，它只需要一个个零散的内存空间即可，因此对内存空间的要求也比数组低。链表的每一个节点通过“指针”链接起来，每一个节点有2部分组成，一部分是数据（上图中的Data），另一部分是后继指针（用来存储后一个节点的地址），在这条链中，最开始的节点称为Head，最末尾的节点的指针指向NULL。「链表」也分为好几种，上图是最简单的一种，它的每一个节点只有一个指针（后继指针）指向后面一个节点，这个链表称为：“单向链表”，除此之外还有：“双向链表、循环链表等”。</p><h3 id="2-2-双向链表"><a href="#2-2-双向链表" class="headerlink" title="2.2 双向链表"></a>2.2 双向链表</h3><p><img src= "/img/loading.gifs" data-src="/images/data_struct/3.png" alt=""><br>双向链表与单向链表的区别是前者是2个方向都有指针，后者只有1个方向的指针。双向链表的每一个节点都有2个指针，一个指针指向前节点，一个指向后节点。双向链表在操作的时候比单向链表的效率要高很多，但是由于多一个指针空间，所以占用内存也会多一点。</p><h3 id="2-3-循环链表"><a href="#2-3-循环链表" class="headerlink" title="2.3 循环链表"></a>2.3 循环链表</h3><p><img src= "/img/loading.gifs" data-src="/images/data_struct/4.png" alt=""><br>其实循环链表就是一种特殊的单向链表，只不过在单向链表的基础上，将末尾节点的指针指向了Head节点，使之收尾相连。</p><h4 id="2-3-1-链表的访问"><a href="#2-3-1-链表的访问" class="headerlink" title="2.3.1 链表的访问"></a>2.3.1 链表的访问</h4><p>链表的优势并不在于访问，因为链表无法通过首地址和下标去计算出某一个节点的地址，所以链表中如果要查找某个节点，则需要一个节点一个节点的遍历，因此链表的访问时间复杂度为O(n)</p><h4 id="2-3-2-链表的插入与删除"><a href="#2-3-2-链表的插入与删除" class="headerlink" title="2.3.2 链表的插入与删除"></a>2.3.2 链表的插入与删除</h4><p>也正是因为链表内存空间是非连续的，所以它对元素的插入和删除时，并不需要像数组那样移动其他元素，只需要修改指针的指向即可。<br>例如：删除一个元素E：<br><img src= "/img/loading.gifs" data-src="/images/data_struct/5.png" alt=""><br>例如：插入一个元素：<br><img src= "/img/loading.gifs" data-src="/images/data_struct/6.png" alt=""><br>既然插入与删除元素只需要改动指针，无需移动数据，那么链表的插入、删除的时间复杂度为O(1)不过这里指的是找到节点之后纯粹的插入或删除动作所需的时间复杂度。如果当前还未定位到指定的节点，只是拿到链表的Head，这个时候要去删除链表中某个固定内容的节点，则需要先查找到那个节点，这个查找的动作又是一个遍历动作了，这个遍历动作查找的时间复杂度却是O(n)，两者加起来总的时间复杂度其实是O(n)的。</p><p>其实就算是已经定位到了某个要删除的节点了，删除逻辑也不简单，以“删除上图的E节点”为例，加入当前链表指针已经定位到了E节点，删除的时候，需要将这个E节点的前面一个节点H的后继指针改为指向A节点，那么E节点就会自动脱落了，但是当前链表指针是定位在E节点上，如何去改变H节点的后继指针呢，对于“单向链表”而言，这个时候需要从头遍历一遍整个链表，找到H节点去修改其后继指针的内容，所以时间复杂度是O(n)，但如果当前是”双向链表“，则不需要遍历，直接通过前继指针即可找到H节点，时间复杂度是O(1)，这里就是”双向链表“相当于”单向链表“的优势所在。</p>]]></content>
      
      
      <categories>
          
          <category> data_struct </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法的时间复杂度与空间复杂度</title>
      <link href="/2023/07/18/data_struct/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>/2023/07/18/data_struct/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1. 时间复杂度"></a>1. 时间复杂度</h2><p>【大O表示法】，即T(n) = O(f(n))，例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (i &#x3D;1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">    j &#x3D; I;</span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过【大O符号表示法】，这段代码的时间复杂度为：<code>O(n)</code>，在时间复杂度的公式是：<code>T(n) = O(f(n))</code>，其中f(n)标识每行代码执行次数之和，而O表示正比例关系，这个公式的全称是：算法的渐进时间复杂度。</p><p>继续看上面的例子：假设每行代码的执行时间都是一样的，我们用1颗粒时间来表示，那么这个例子的第一行耗时是1个颗粒时间，第三行的执行时间是n个颗粒时间，第四行的执行时间也是n个颗粒时间（第二行和第五行是符号，暂时忽略），那么总时间就是1颗粒时间+n颗粒时间+n颗粒时间，即（1+2n）个颗粒时间，即：<code>T(n) = (1+2n)*颗粒时间</code>，从这个结果可以看出，这个算法的耗时是随着n的变化而变化，因此，我们可以简化的将这个算法的时间复杂度表示为：<code>T(n) = O(n)</code>。因为大O符号表示法并不是用来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的。所以上面的例子中，如果n无限大的时候，<code>T(n) = time(1+2n)</code>中的常量1就没有意义了，倍数2也意义不大，因此直接简化为<code>T(n) = O(n)</code>就可以了。</p><h3 id="1-1-常见的时间复杂度量级有"><a href="#1-1-常见的时间复杂度量级有" class="headerlink" title="1.1 常见的时间复杂度量级有"></a>1.1 常见的时间复杂度量级有</h3><ul><li>常数阶O(1)</li><li>对数阶O(logN)</li><li>线性阶O(n)</li><li>线性对数阶O(nlogN)</li><li>平方阶O(n²)</li><li>立方阶O(n³)</li><li>K次方阶O(n^k)</li><li>指数阶(2^n)<br>上面从上至下依次的时间复杂度越来越大，执行的效率越来越低。</li></ul><h3 id="1-2-下面选取一些较为常用的来讲解一下"><a href="#1-2-下面选取一些较为常用的来讲解一下" class="headerlink" title="1.2 下面选取一些较为常用的来讲解一下"></a>1.2 下面选取一些较为常用的来讲解一下</h3><ul><li>常阶数O(1)<br>无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，如：<br><code>int i = 1;</code><br><code>int j = 2;</code><br><code>i++;</code><br><code>j++;</code><br><code>int m = i + j;</code><br>上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。</li><li>线性阶O(n)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (I&#x3D;1; i&lt;&#x3D;n; ++i) &#123;</span><br><span class="line">    j &#x3D; I;</span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度。</li><li>对数阶O(logN)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D;1;</span><br><span class="line">while (i &lt; n) &#123;</span><br><span class="line">    i &#x3D; i * 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>从上面代码可以看到，在while循环里面，每次都将i乘以2，乘完之后，i距离n就越来越近了。假设循环x次之后，i就大于2了，因此这个循环就退出了，也就是说2的x次方等于n，那么<code>x = log2^n</code>也就是说当循环<code>log2^n</code>次以后，这个代码就结束了。因此这个代码的时间复杂度为：<code>O(logn)</code></li><li>线性对数阶O(nlogN)<br>线性对数阶O(nlogN)其实非常容易理解，将时间复杂度为<code>O(logn)</code>的代码循环N遍的话，那么它的时间复杂度就是<code>n * O(logN)</code>，也就是了<code>O(nlogN)</code>。拿上面代码修改一点来举例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (m &#x3D; 1; m &lt; n; m++) &#123;</span><br><span class="line">    i &#x3D; 1;</span><br><span class="line">    while ( i &lt; n) &#123;</span><br><span class="line">        i &#x3D; i * 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>平方阶O(n²)<br>平方阶<code>O(n²)</code>就更容易理解了，如果把O(n)的代码再嵌套循环一遍，它的时间复杂度就是<code>O(n²)</code>了，举例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for ( x &#x3D; 1; i &lt;&#x3D; n; x++) &#123;</span><br><span class="line">    for ( i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        j &#x3D; I;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这段代码其实就是嵌套了2层n循环，它的时间复杂度就是<code>O(n*n)</code>，即<code>O(n²)</code>，如果将其中一层循环的n改成m，即：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for ( x &#x3D; 1; i &lt;&#x3D; m; x++) &#123;</span><br><span class="line">    for ( i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        j &#x3D; i;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>那它的时间复杂度就变成了<code>O(m*n)</code>。</li><li>立方阶<code>O(n³)</code>、K次方阶<code>O(m*n)</code><br>参考上面的<code>O(n²)</code>去理解就好了，<code>O(n³)</code>相当于三层n循环，其它的类似。<br>除此之外，其实还有平均时间复杂度、均摊时间复杂度、最坏时间复杂度、最好时间复杂度的分析方法。</li></ul>]]></content>
      
      
      <categories>
          
          <category> data_struct </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>入门-mysql学习笔记</title>
      <link href="/2023/07/18/mysql/%E5%85%A5%E9%97%A8-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
      <url>/2023/07/18/mysql/%E5%85%A5%E9%97%A8-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
      
        <content type="html"><![CDATA[<ol><li>mysql函数<ol><li>IFNULL：遇到空值运算给0补充，例如字段age为NULL，age<em>18=NULL，使用IFNULL后，则IFNULL(age,0)，变成age</em>0=0；</li><li>DISTINCT：去重（效率较低，底层实现原理会生成一张临时表）；</li><li>WHERE：过滤条件；</li><li>&lt;&gt;：不等于也可以是（!=）；</li><li>BETWEEN … AND … ：比较运算符包含边界（等价于AND），例如查询年龄18-20之间的数据：select * from emp where age between 18 and 20;</li><li>IN：等于值列表中任意一个即可，例如：where age in(18,20)；</li><li>LIKE：模糊查询，例如：where name LIKE ‘黄%’（向后匹配，如果向前匹配则把%放前面即可）；<ol><li>LIKE <em>：表示一个任意字符，如查询名字中第二个字带国字的数据（如需查询第几位则前面就用几个_代替，如需查询中间含有_的数据则需在下划线前增加一个转义字符即可，例如：’%\</em>%’，如果不想要\来做转义字符的话，则可通过关键字ESCAPE ‘$’来处理，例如：like ‘%$_%’ ESCAPE ‘$’ 即可），例如：select * from emp where name like ‘_国%’;</li></ol></li><li>ORDER BY … ASC：升序排序（不指定排序方式，默认为ASC升序排序）；</li><li>ORDER BY … DESC：降序排序；<ol><li>多列排序，select id,name,score from emp where age between 18 and 30 order by age desc,name,score desc （查询emp表中年龄在18岁到30岁之间的数据，并根据age进行降序排序，如果有重复的则根据name进行升序排序，还有重复的则根据score进行倒序排序）；</li></ol></li><li>INNER JOIN：内连接（只查询满足连接条件的数据）；</li><li>外连接<ol><li>LEFT JOIN（左外连接）：不仅将多个表中满足条件的数据查出，还将”左表“中不满足条件的数据也查出；</li><li>RIGHT JOIN（左外连接）：不仅将多个表中满足条件的数据查出，还将”右表“中不满足条件的数据也查出；</li><li>UNION JOIN（满外连接）：不仅将多个表中满足条件的数据查出，还将”多个表“中不满足条件的数据也查出；</li></ol></li><li>CONCAT()：字符串拼接，例如：select CONCAT(name,’works for’, name)每个字符串用”,”隔开利用CONCAT函数把所有字符串都拼接起来；</li><li>自连接<ol><li>CONCAT函数（拼接一个或多个字符串）：例如：select CONCAT(last_name, ‘works for ‘, last_name)，利用CONCAT函数把所有的字符串串接到一起形成一列（跟编程语言中的字符串拼接类似）。</li><li>自连接的技巧就是，把同一张表看做成两张不同的表进行连接查询。</li></ol></li><li>等值连接<ol><li>例如：select e.id,e.city from emp e, demp d where e.id=d.id（等值连接就是查询连接的条件值是相等的或等于等于的）；</li></ol></li><li>非等值连接<ol><li>例如：select e.id,e.city from emp e, demp d where e.id BETWEEN d.lowset_sal AND d.highest_sal （非等值连接就是查询的连接条件是不相等的，比如上面例子就是查询的条件是取的范围值没有直接的等于等于的情况就是非等值连接）</li></ol></li><li>条件表达式<ol><li>CASE … THEN …：例如：select emp_ID, last_name,salary,depa_id, CASE depa_id WHEN 10 THEN salary *1.1  WHEN 20 THEN salary * 1.2 END “new_salary” from employ;（查询emp_ID，last_name，depa_id，salary，使用CASE关键字来判断，如果depa_id=10的话，那么salary * 1.1，在如果depa_id=20的话那么salary * 1.2注意条件结束时需要加上关键字END来结束这个表达式，如果都不等于10或者20的话则使用ELSE关键字，类似于if …else …）</li></ol></li><li>分组函数、多行行数（MAX-最大，MIN-最小，AVG（平均），COUNT-总数，SUM（总和））</li><li>子查询解决组函数嵌套的问题<ol><li>例如：select MAX(avg_sal) from (select AVG(salary) avg_sal from emp GROUP BY demp_id) e; 把子查询查出来的结果看作为一张零时的表或列，然后再外层通过MAX函数查出最大值；</li><li>例如：查询出谁的工资比Abel工资高：select emp_id, last_name,salary from emp where salary &gt; (select salary from emp where last_name=‘Abel’)，解释：先利用子查询查询出Abel的工资，然后在用外层查询比Abel工资高的人即可；</li></ol></li><li>MySQL的语句的执行顺序： SELECT-6、FROM-1（会先将表加载到内存中）、JOIN ON-2（表之间的连接条件，将满足条件的数据都加载到内存中，然后再对内存中的表中的数据进行过滤满足条件留下，不满足条件的则过滤掉）、WHERE-3（对内存中的表进行过滤）、GROUP BY-4（分组效率最低-底层是需要生成临时表的，通常情况下过滤条件能写在where后面就尽量写在where后面，通过where过滤掉部分数据后再进行分组，注意：出现在SELECT子句后的非分组函数，必须出现在GROUP BY子句后）、HAVING-5、ORDER BY-7（将select查询出来的数据最后在通过order by进行排序）；</li><li>使用ANY关键字（多行操作符，满足值列表中任意一个条件即可，有点类似或者…或者..的意思）来进行多行子查询，例如：select emp_id, last_name,job_id,salary from emp where salary &lt; ANY (select salary from emp where job_id=‘IT_PROG’)；题目解析：返回其它部门中比job_id为IT_PROG部门任一工资低的员工的员工号、姓名、job_id以及salary；</li><li>使用ALL关键字（多行操作符，满足值列表中所有的条件才可以，有点类似并且…并且…的意思）来进行多行子查询，例如：select emp_id, last_name,job_id,salary from emp where salary &lt; ALL (select salary from emp where job_id=‘IT_PROG’)；题目解析：返回其它部门中比job_id为IT_PROG部门所有工资都低的员工的员工号、姓名、job_id以及salary；</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux命令总结</title>
      <link href="/2022/05/16/linux/linux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
      <url>/2022/05/16/linux/linux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是linux"><a href="#什么是linux" class="headerlink" title="什么是linux"></a>什么是linux</h1><p><img src= "/img/loading.gifs" data-src="/images/linux/page1.jpg" alt=""><br>Linux 系统内核与 Linux 发行套件的区别</p><ul><li><code>Linux</code> 系统内核指的是由 <code>Linus Torvalds</code> 负责维护，提供硬件抽象层、硬盘及文件系统控制及多任务功能的系统核心程序。</li><li><code>Linux</code> 发行套件系统是我们常说的 <code>Linux</code> 操作系统，也即是由 <code>Linux</code> 内核与各种常用软件的集合产品。<br>总结：真正的 <code>Linux</code> 指的是系统内核，而我们常说的 <code>Linux</code> 指的是“发行版完整的包含一些基础软件的操作系统”。</li></ul><h2 id="Linux-对比-Windows"><a href="#Linux-对比-Windows" class="headerlink" title="Linux 对比 Windows"></a>Linux 对比 Windows</h2><ol><li>稳定且有效率；</li><li>免费（或少许费用）；</li><li>漏洞少且快速修补；</li><li>多任务多用户；</li><li>更加安全的用户与文件权限策略；</li><li>适合小内核程序的嵌入系统；</li><li>相对不耗资源。</li></ol><h2 id="Linux-系统种类"><a href="#Linux-系统种类" class="headerlink" title="Linux 系统种类"></a>Linux 系统种类</h2><ul><li>红帽企业版  <code>Linux</code> ： <code>RHEL</code> 是全世界内使用最广泛的 <code>Linux</code> 系统。它具有极强的性能与稳定性，是众多生成环境中使用的（收费的）系统。</li><li><code>Fedora</code>  ：由红帽公司发布的桌面版系统套件，用户可以免费体验到最新的技术或工具，这些技术或工具在成熟后会被加入到 <code>RHEL</code> 系统中，因此 <code>Fedora</code><br>也成为 <code>RHEL</code> 系统的试验版本</li><li><code>CentOS</code>  ：通过把 <code>RHEL</code> 系统重新编译并发布给用户免费使用的 <code>Linux</code> 系统，具有广泛的使用人群。</li><li><code>Deepin</code> ：中国发行，对优秀的开源成品进行集成和配置。</li><li><code>Debian</code> ：稳定性、安全性强，提供了免费的基础支持，在国外拥有很高的认可度和使用率。</li><li><code>Ubuntu</code>  ：是一款派生自 <code>Debian</code> 的操作系统，对新款硬件具有极强的兼容能力。<code>Ubuntu</code> 与 <code>Fedora</code> 都是极其出色的 <code>Linux</code> 桌面系统，而且 Ubuntu 也可用于服务器领域。</li></ul><hr><h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><p><code>Shell</code> 这个单词的原意是“外壳”，跟 <code>kernel</code>（内核）相对应，比喻内核外面的一层，即用户跟内核交互的对话界面。</p><ul><li><code>Shell</code> 是一个程序，提供一个与用户对话的环境。这个环境只有一个命令提示符，让用户从键盘输入命令，所以又称为命令行环境（ <code>command line interface</code> ，简写为 <code>CLI</code> ）。<code>Shell</code> 接收到用户输入的命令，将命令送入操作系统执行，并将结果返回给用户。</li><li><code>Shell</code> 是一个命令解释器，解释用户输入的命令。它支持变量、条件判断、循环操作等语法，所以用户可以用 <code>Shell</code> 命令写出各种小程序，又称为 <code>Shell</code> 脚本。这些脚本都通过 <code>Shell</code> 的解释执行，而不通过编译。</li><li><code>Shell</code> 是一个工具箱，提供了各种小工具，供用户方便地使用操作系统的功能。</li></ul><h2 id="Shell-的种类"><a href="#Shell-的种类" class="headerlink" title="Shell 的种类"></a>Shell 的种类</h2><p><code>Shell</code> 有很多种，只要能给用户提供命令行环境的程序，都可以看作是 <code>Shell</code> 。<br>历史上，主要的 <code>Shell</code> 有下面这些：</p><ul><li>Bourne Shell（sh）</li><li>Bourne Again shell（bash）</li><li>C Shell（csh）</li><li>TENEX C Shell（tcsh）</li><li>Korn shell（ksh）</li><li>Z Shell（zsh）</li><li>Friendly Interactive Shell（fish）<br>其中 <code>Bash</code> 是目前最常用的 <code>Shell</code> 。<code>MacOS</code> 中的默认 <code>Shell</code> 就是 <code>Bash</code> 。<br>通过执行 <code>echo $SHELL</code> 命令可以查看到当前正在使用的 <code>Shell</code> 。还可以通过 <code>cat /etc/shells</code> 查看当前系统安装的所有 <code>Shell</code> 种类。</li></ul><hr><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><h2 id="命令行提示符"><a href="#命令行提示符" class="headerlink" title="命令行提示符"></a>命令行提示符</h2><p>进入命令行环境以后，用户会看到 <code>Shell</code> 的提示符。提示符往往是一串前缀，最后以一个美元符号 <code>$</code> 结尾，用户可以在这个符号后面输入各种命令。<br>执行一个简单的命令 <code>pwd</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@guolhuang ~]# pwd</span><br><span class="line">&#x2F;root</span><br></pre></td></tr></table></figure><p>命令解析：</p><ul><li><code>root</code>：表示用户名；</li><li><code>guolhuang</code>：表示主机名；</li><li><code>~</code>：表示目前所在目录为家目录，其中 <code>root</code> 用户的家目录是 <code>/root</code> 普通用户的家目录在 <code>/home</code> 下</li><li><code>#</code>：指示你所具有的权限（ <code>root</code> 用户为 <code>#</code> ，普通用户为 <code>$</code> ）。</li><li>执行 <code>whoami</code> 命令可以查看当前用户名；</li><li>执行 <code>hostname</code> 命令可以查看当前主机名；<br>关于如何创建、切换、删除用户，在后面的用户与权限会具体讲解，这里先使用 <code>root</code> 用户进行演示。<br>[备注] <code>root</code> 是超级用户，具备操作系统的一切权限。</li></ul><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command parameters（命令 参数）</span><br></pre></td></tr></table></figure><h2 id="长短参数"><a href="#长短参数" class="headerlink" title="长短参数"></a>长短参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">单个参数：ls -a（a 是英文 all 的缩写，表示“全部”）</span><br><span class="line">多个参数：ls -al（全部文件 + 列表形式展示）</span><br><span class="line">单个长参数：ls --all</span><br><span class="line">多个长参数：ls --reverse --all</span><br><span class="line">长短混合参数：ls --all -l</span><br></pre></td></tr></table></figure><h2 id="参数值"><a href="#参数值" class="headerlink" title="参数值"></a>参数值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">短参数：command -p 10（例如：ssh root@121.42.11.34 -p 22）</span><br><span class="line">长参数：command --paramters&#x3D;10（例如：ssh root@121.42.11.34 --port&#x3D;22）</span><br></pre></td></tr></table></figure><hr><h1 id="快捷方式"><a href="#快捷方式" class="headerlink" title="快捷方式"></a>快捷方式</h1><p>在开始学习 <code>Linux</code> 命令之前，有这么一些快捷方式，是必须要提前掌握的，它将贯穿整个 <code>Linux</code> 使用生涯。</p><ul><li>通过上下方向键 ↑ ↓ 来调取过往执行过的 <code>Linux</code> 命令；</li><li>命令或参数仅需输入前几位就可以用 <code>Tab</code> 键补全；</li><li><code>Ctrl + R</code> ：用于查找使用过的命令（<code>history</code> 命令用于列出之前使用过的所有命令，然后输入 <code>!</code> 命令加上编号( <code>!2</code> )就可以直接执行该历史命令）；</li><li><code>Ctrl + L</code>：清除屏幕并将当前行移到页面顶部；</li><li><code>Ctrl + C</code>：中止当前正在执行的命令；</li><li><code>Ctrl + U</code>：从光标位置剪切到行首；</li><li><code>Ctrl + K</code>：从光标位置剪切到行尾</li><li><code>Ctrl + W</code>：剪切光标左侧的一个单词；</li><li><code>Ctrl + Y</code>：粘贴 <code>Ctrl + U | K | Y</code> 剪切的命令；</li><li><code>Ctrl + A</code>：光标跳到命令行的开头；</li><li><code>Ctrl + E</code>：光标跳到命令行的结尾</li><li><code>Ctrl + D</code>：关闭 <code>Shell</code> 会话；</li></ul><hr><h1 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h1><h2 id="文件的组织"><a href="#文件的组织" class="headerlink" title="文件的组织"></a>文件的组织</h2><p><img src= "/img/loading.gifs" data-src="/images/linux/page2.jpeg" alt=""></p><h2 id="查看路径"><a href="#查看路径" class="headerlink" title="查看路径"></a>查看路径</h2><h3 id="1-pwd"><a href="#1-pwd" class="headerlink" title="1. pwd"></a>1. pwd</h3><p>显示当前目录的路径<br><img src= "/img/loading.gifs" data-src="/images/linux/3.jpeg" alt=""></p><h3 id="2-which"><a href="#2-which" class="headerlink" title="2. which"></a>2. which</h3><p>查看命令的可执行文件所在路径， <code>Linux</code> 下，每一条命令其实都对应一个可执行程序，在终端中输入命令，按回车的时候，就是执行了对应的那个程序， <code>which</code> 命令本身对应的程序也存在于 <code>Linux</code> 中。<br>总的来说一个命令就是一个可执行程序。<br><img src= "/img/loading.gifs" data-src="/images/linux/4.jpeg" alt=""></p><h2 id="浏览和切换目录"><a href="#浏览和切换目录" class="headerlink" title="浏览和切换目录"></a>浏览和切换目录</h2><h3 id="1-ls"><a href="#1-ls" class="headerlink" title="1. ls"></a>1. ls</h3><p>列出文件和目录，它是 <code>Linux</code> 最常用的命令之一。<br>【常用参数】<br>    *   <code>-a</code> 显示所有文件和目录包括隐藏的<br>    *   <code>-l</code> 显示详细列表<br>    *   <code>-h</code> 适合人类阅读的<br>    *   <code>-t</code> 按文件最近一次修改时间排序<br>    *   <code>-i</code> 显示文件的 <code>inode</code> （ <code>inode</code> 是文件内容的标识）<br><img src= "/img/loading.gifs" data-src="/images/linux/5.jpeg" alt=""></p><h3 id="2-cd"><a href="#2-cd" class="headerlink" title="2. cd"></a>2. cd</h3><p><code>cd</code> 是英语 <code>change directory</code> 的缩写，表示切换目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F; --&gt; 跳转到根目录</span><br><span class="line">cd ~ --&gt; 跳转到家目录</span><br><span class="line">cd .. --&gt; 跳转到上级目录</span><br><span class="line">cd .&#x2F;home --&gt; 跳转到当前目录的home目录下</span><br><span class="line">cd &#x2F;home&#x2F;lion --&gt; 跳转到根目录下的home目录下的lion目录</span><br><span class="line">cd --&gt; 不添加任何参数，也是回到家目录</span><br></pre></td></tr></table></figure><p>[注意] 输入<code>cd /ho</code> + 单次 <code>tab</code> 键会自动补全路径 + 两次 <code>tab</code> 键会列出所有可能的目录列表。</p><h3 id="3-du"><a href="#3-du" class="headerlink" title="3. du"></a>3. du</h3><p>列举目录大小信息。<br>【常用参数】<br>    *   <code>-h</code> 适合人类阅读的；<br>    *   <code>-a</code> 同时列举出目录下文件的大小信息；<br>    *   <code>-s</code> 只显示总计大小，不显示具体信息。</p><h2 id="浏览和创建文件"><a href="#浏览和创建文件" class="headerlink" title="浏览和创建文件"></a>浏览和创建文件</h2><h3 id="1-cat"><a href="#1-cat" class="headerlink" title="1. cat"></a>1. cat</h3><p>一次性显示文件所有内容，更适合查看小的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat cloud-init.log</span><br></pre></td></tr></table></figure><p>【常用参数】<br>    *   <code>-n</code> 显示行号。</p><h3 id="2-less"><a href="#2-less" class="headerlink" title="2. less"></a>2. less</h3><p>分页显示文件内容，更适合查看大的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less cloud-init.log</span><br></pre></td></tr></table></figure><p>【快捷操作】<br>    *   空格键：前进一页（一个屏幕）；<br>    *   <code>b</code> 键：后退一页；<br>    *   回车键：前进一行；<br>    *   <code>y</code> 键：后退一行；<br>    *   上下键：回退或前进一行；<br>    *   <code>d</code> 键：前进半页；<br>    *   <code>u</code> 键：后退半页；<br>    *   <code>q</code> 键：停止读取文件，中止 <code>less</code> 命令；<br>    *   <code>=</code> 键：显示当前页面的内容是文件中的第几行到第几行以及一些其它关于本页内容的详细信息；<br>    *   <code>h</code> 键：显示帮助文档；<br>    *   <code>/</code> 键：进入搜索模式后，按 <code>n</code> 键跳到一个符合项目，按 <code>N</code> 键跳到上一个符合项目，同时也可以输入正则表达式匹配。</p><h3 id="3-head"><a href="#3-head" class="headerlink" title="3. head"></a>3. head</h3><p>显示文件的开头几行（默认是10行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head cloud-init.log</span><br></pre></td></tr></table></figure><p>【参数】<br>    *   -n 指定行数 head cloud-init.log -n 2</p><h3 id="4-tail"><a href="#4-tail" class="headerlink" title="4. tail"></a>4. tail</h3><p>显示文件的结尾几行（默认是10行）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail cloud-init.log</span><br></pre></td></tr></table></figure><p>【参数】<br>    *   <code>-n</code> 指定行数 <code>tail cloud-init.log -n 2</code><br>    *   <code>-f</code> 会每过1秒检查下文件是否有更新内容，也可以用 <code>-s</code> 参数指定间隔时间 <code>tail -f -s 4 xxx.log</code></p><h3 id="5-touch"><a href="#5-touch" class="headerlink" title="5. touch"></a>5. touch</h3><p>创建一个文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch new_file</span><br></pre></td></tr></table></figure><h3 id="6-mkdir"><a href="#6-mkdir" class="headerlink" title="6. mkdir"></a>6. mkdir</h3><p>创建一个目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir new_folder</span><br></pre></td></tr></table></figure><p>【常用参数】<br>    *   <code>-p</code> 递归的创建目录结构 <code>mkdir -p one/two/three</code></p><h2 id="文件的复制和移动"><a href="#文件的复制和移动" class="headerlink" title="文件的复制和移动"></a>文件的复制和移动</h2><h3 id="1-cp"><a href="#1-cp" class="headerlink" title="1. cp"></a>1. cp</h3><p>拷贝文件和目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp file file_copy --&gt; file 是目标文件，file_copy 是拷贝出来的文件cp file one --&gt; 把 file 文件拷贝到 one 目录下，并且文件名依然为 filecp file one&#x2F;file_copy --&gt; 把 file 文件拷贝到 one 目录下，文件名为file_copycp *.txt folder --&gt; 把当前目录下所有 txt 文件拷贝到 folder</span><br></pre></td></tr></table></figure><p>【常用参数】<br>    *   <code>-r</code> 递归的拷贝，常用来拷贝一整个目</p><h3 id="2-mv"><a href="#2-mv" class="headerlink" title="2. mv"></a>2. mv</h3><p>移动（重命名）文件或目录，与cp命令用法相似。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mv file one --&gt; 将 file 文件移动到 one 目录下mv new_folder one --&gt; 将 new_folder 文件夹移动到one目录下mv *.txt folder --&gt; 把当前目录下所有 txt 文件移动到 folder 目录下mv file new_file --&gt; file 文件重命名为 new_file</span><br></pre></td></tr></table></figure><h2 id="文件的删除和链接"><a href="#文件的删除和链接" class="headerlink" title="文件的删除和链接"></a>文件的删除和链接</h2><h3 id="1-rm"><a href="#1-rm" class="headerlink" title="1. rm"></a>1. rm</h3><p>删除文件和目录，由于 <code>Linux</code> 下没有回收站，一旦删除非常难恢复，因此需要谨慎操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm new_file  --&gt; 删除 new_file 文件rm f1 f2 f3  --&gt; 同时删除 f1 f2 f3 3个文件</span><br></pre></td></tr></table></figure><p>【常用参数】<br>    *   <code>-i</code> 向用户确认是否删除；<br>    *   <code>-f</code> 文件强制删除；<br>    *   <code>-r</code> 递归删除文件夹，著名的删除操作 <code>rm -rf</code> 。</p><h3 id="2-ln"><a href="#2-ln" class="headerlink" title="2. ln"></a>2. ln</h3><p>英文 <code>Link</code> 的缩写，表示创建链接。<br>学习创建链接之前，首先要理解链接是什么，我们先来看看 <code>Linux</code> 的文件是如何存储的：<br><code>Linux</code> 文件的存储方式分为3个部分，文件名、文件内容以及权限，其中文件名的列表是存储在硬盘的其它地方和文件内容是分开存放的，每个文件名通过 inode 标识绑定到文件内容。<br>Linux 下有两种链接类型：硬链接和软链接。</p><h3 id="3-硬链接"><a href="#3-硬链接" class="headerlink" title="3. 硬链接"></a>3. 硬链接</h3><p>使链接的两个文件共享同样文件内容，就是同样的 <code>inode</code> ，一旦文件1和文件2之间有了硬链接，那么修改任何一个文件，修改的都是同一块内容，它的缺点是，只能创建指向文件的硬链接，不能创建指向目录的（其实也可以，但比较复杂）而软链接都可以，因此软链接使用更加广泛。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln file1 file2  --&gt; 创建 file2 为 file1 的硬链接</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gifs" data-src="/images/linux/6.jpeg" alt=""><br>如果我们用 <code>rm file1</code> 来删除 <code>file1</code> ，对 <code>file2</code> 没有什么影响，对于硬链接来说，删除任意一方的文件，共同指向的文件内容并不会从硬盘上删除。只有同时删除了 <code>file1</code> 与<code>file2</code> 后，它们共同指向的文件内容才会消失。</p><h3 id="4-软链接"><a href="#4-软链接" class="headerlink" title="4. 软链接"></a>4. 软链接</h3><p>软链接就类似 <code>windows</code> 下快捷方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s file1 file2</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gifs" data-src="/images/linux/7.jpeg" alt=""><br>执行 <code>ls -l</code> 命名查看当前目录下文件的具体信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">total 0-rw-r--r-- 1 root root 0 Jan 14 06:29 file1lrwxrwxrwx 1 root root 5 Jan 14 06:42 file2 -&gt; file1  # 表示file2 指向 file1</span><br></pre></td></tr></table></figure><p>其实 <code>file2</code> 只是 <code>file1</code> 的一个快捷方式，它指向的是 <code>file1</code> ，所以显示的是 <code>file1</code> 的内容，但其实 <code>file2</code> 的 <code>inode</code> 与 <code>file1</code> 并不相同。如果我们删除了 <code>file2</code> 的话， <code>file1</code>是不会受影响的，但如果删除 <code>file1</code> 的话， <code>file2</code> 就会变成死链接，因为指向的文件不见了。</p><hr><h1 id="用户与权限"><a href="#用户与权限" class="headerlink" title="用户与权限"></a>用户与权限</h1><h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><p><code>Linux</code> 是一个多用户的操作系统。在 <code>Linux</code> 中，理论上来说，我们可以创建无数个用户，但是这些用户是被划分到不同的群组里面的，有一个用户，名叫 <code>root</code> ，是一个很特殊的用户，它是超级用户，拥有最高权限。<br><img src= "/img/loading.gifs" data-src="/images/linux/8.jpeg" alt=""><br>自己创建的用户是有限权限的用户，这样大大提高了 <code>Linux</code> 系统的安全性，有效防止误操作或是病毒攻击，但是我们执行的某些命令需要更高权限时可以使用 <code>sudo</code> 命令。</p><h3 id="1-sudo"><a href="#1-sudo" class="headerlink" title="1. sudo"></a>1. sudo</h3><p>以 <code>root</code> 身份运行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo date  --&gt; 当然查看日期是不需要sudo的这里只是演示，sudo 完之后一般还需要输入用户密码的</span><br></pre></td></tr></table></figure><p>useradd + passwd<br>    *   <code>useradd</code> 添加新用户<br>    *   <code>passwd</code> 修改用户密码<br>这两个命令需要 <code>root</code> 用户权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd lion --&gt; 添加一个lion用户，添加完之后在 &#x2F;home 路径下可以查看passwd lion --&gt; 修改lion用户的密码</span><br></pre></td></tr></table></figure><h3 id="2-userdel"><a href="#2-userdel" class="headerlink" title="2. userdel"></a>2. userdel</h3><p>删除用户，需要 <code>root</code> 用户权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel lion --&gt; 只会删除用户名，不会从&#x2F;home中删除对应文件夹userdel lion -r --&gt; 会同时删除&#x2F;home下的对应文件夹</span><br></pre></td></tr></table></figure><h3 id="3-su"><a href="#3-su" class="headerlink" title="3. su"></a>3. su</h3><p>切换用户，需要 <code>root</code> 用户权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo su --&gt; 切换为root用户（exit 命令或 CTRL + D 快捷键都可以使普通用户切换为 root 用户）su lion --&gt; 切换为普通用户su - --&gt; 切换为root用户</span><br></pre></td></tr></table></figure><h2 id="群组的管理"><a href="#群组的管理" class="headerlink" title="群组的管理"></a>群组的管理</h2><p><code>Linux</code> 中每个用户都属于一个特定的群组，如果你不设置用户的群组，默认会创建一个和它的用户名一样的群组，并且把用户划归到这个群组。</p><h3 id="1-groupadd"><a href="#1-groupadd" class="headerlink" title="1. groupadd"></a>1. groupadd</h3><p>创建群组，用法和 <code>useradd</code> 类似。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd friends</span><br></pre></td></tr></table></figure><h3 id="2-groupdel"><a href="#2-groupdel" class="headerlink" title="2. groupdel"></a>2. groupdel</h3><p>删除一个已存在的群组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupdel foo  --&gt; 删除foo群组</span><br></pre></td></tr></table></figure><h3 id="3-groups"><a href="#3-groups" class="headerlink" title="3. groups"></a>3. groups</h3><p>查看用户所在群组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groups lion  --&gt; 查看 lion 用户所在的群组</span><br></pre></td></tr></table></figure><h3 id="4-usermod"><a href="#4-usermod" class="headerlink" title="4. usermod"></a>4. usermod</h3><p>用于修改用户的账户。<br>【常用参数】<br>    *   <code>-l</code> 对用户重命名。需要注意的是 <code>/home</code> 中的用户家目录的名字不会改变，需要手动修改。<br>    *   <code>-g</code> 修改用户所在的群组，例如 <code>usermod -g friends lion</code>修改 <code>lion</code> 用户的群组为 <code>friends</code><br>    *   <code>-G</code> 一次性让用户添加多个群组，例如 <code>usermod -G friends,foo,bar lion</code> 。<br>    *   <code>-a -G</code> 会让你离开原先的群组，如果你不想这样做的话，就得再添加 <code>-a</code> 参数，意味着<code>append</code> 追加的意思。</p><h3 id="5-chgrp"><a href="#5-chgrp" class="headerlink" title="5. chgrp"></a>5. chgrp</h3><p>用于修改文件的群组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp bar file.txt --&gt; file.txt文件的群组修改为bar</span><br></pre></td></tr></table></figure><h3 id="6-chown"><a href="#6-chown" class="headerlink" title="6. chown"></a>6. chown</h3><p>改变文件的所有者，需要 <code>root</code> 身份才能运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown lion file.txt --&gt; 把其它用户创建的file.txt转让给lion用户chown lion:bar file.txt --&gt; 把file.txt的用户改为lion，群组改为bar</span><br></pre></td></tr></table></figure><p>【常用参数】<br>    *   <code>-R</code> 递归设置子目录和子文件， <code>chown -R lion:lion /home/frank</code> 把 <code>frank</code> 文件夹的用户和群组都改为 <code>lion</code> 。</p><h2 id="文件权限管理"><a href="#文件权限管理" class="headerlink" title="文件权限管理"></a>文件权限管理</h2><h3 id="1-chmod"><a href="#1-chmod" class="headerlink" title="1. chmod"></a>1. chmod</h3><p>修改访问权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 740 file.txt</span><br></pre></td></tr></table></figure><p>【常用参数】<br>    *   <code>-R</code> 可以递归地修改文件访问权限，例如 <code>chmod -R 777 /home/lion</code>修改权限的确简单，但是理解其深层次的意义才是更加重要的。下面我们来系统的学习<code>Linux</code> 的文件权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@lion ~]# ls -ldrwxr-xr-x 5 root root 4096 Apr 13  2020 climblrwxrwxrwx 1 root root    7 Jan 14 06:41 hello2.c -&gt; hello.c-rw-r--r-- 1 root root  149 Jan 13 06:14 hello.c</span><br></pre></td></tr></table></figure><p>其中 <code>drwxr-xr-x</code> 表示文件或目录的权限。让我们一起来解读它具体代表什么？<br>    *   <code>d</code> ：表示目录，就是说这是一个目录，普通文件是 <code>-</code> ，链接是 <code>l</code><br>    *   <code>r</code> ：<code>read</code> 表示文件可读。<br>    *   <code>w</code> ：<code>write</code> 表示文件可写，一般有写的权限，就有删除的权限。<br>    *   <code>x</code> ：<code>execute</code> 表示文件可执行。<br>    *   <code>-</code> ：表示没有相应权限。<br>权限的整体是按用户来划分的，如下图所示：<br><img src= "/img/loading.gifs" data-src="/images/linux/9.jpeg" alt=""><br>现在再来理解这句权限 <code>drwxr-xr-x</code> 的意思：<br>    *   它是一个文件夹；<br>    *   它的所有者具有：读、写、执行权限；<br>    *   它的群组用户具有：读、执行的权限，没有写的权限；<br>    *   它的其它用户具有：读、执行的权限，没有写的权限。<br>现在理解了权限，我们使用 <code>chmod</code> 来尝试修改权限。<code>chmod</code> 它不需要是 <code>root</code> 用户才能运行的，只要你是此文件所有者，就可以用 <code>chmod</code> 来修改文件的访问权限。</p><ul><li>数字分配权限<table><thead><tr><th>权限</th><th>数字</th></tr></thead><tbody><tr><td>r</td><td>4</td></tr><tr><td>w</td><td>2</td></tr><tr><td>x</td><td>1</td></tr></tbody></table></li></ul><p>因此要改变权限，只要做一些简单的加法就行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 640 hello.c # 分析6 &#x3D; 4 + 2 + 0 表示所有者具有 rw 权限4 &#x3D; 4 + 0 + 0 表示群组用户具有 r 权限0 &#x3D; 0 + 0 + 0 表示其它用户没有权限对应文字权限为：-rw-r-----</span><br></pre></td></tr></table></figure><p>用字母来分配权限<br>    *   <code>u</code> ：<code>user</code> 的缩写，用户的意思，表示所有者。<br>    *   <code>g</code> ：<code>group</code> 的缩写，群组的意思，表示群组用户。<br>    *   <code>o</code> ：<code>other</code> 的缩写，其它的意思，表示其它用户<br>    *   <code>a</code> ：<code>all</code> 的缩写，所有的意思，表示所有用户。<br>    *   <code>+</code> ：加号，表示添加权限。<br>    *   <code>-</code> ：减号，表示去除权限。<br>    *   <code>=</code> ：等于号，表示分配权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+rx file --&gt; 文件file的所有者增加读和运行的权限chmod g+r file --&gt; 文件file的群组用户增加读的权限chmod o-r file --&gt; 文件file的其它用户移除读的权限chmod g+r o-r file --&gt; 文件file的群组用户增加读的权限，其它用户移除读的权限chmod go-r file --&gt; 文件file的群组和其他用户移除读的权限chmod +x file --&gt; 文件file的所有用户增加运行的权限chmod u&#x3D;rwx,g&#x3D;r,o&#x3D;- file --&gt; 文件file的所有者分配读写和执行的权限，群组其它用户分配读的权限，其他用户没有任何权限</span><br></pre></td></tr></table></figure><hr><h1 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h1><h2 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h2><p>搜索包含关键字的所有文件和目录。后接需要查找的文件名，也可以用正则表达式。</p><h3 id="1-安装-locate"><a href="#1-安装-locate" class="headerlink" title="1. 安装 locate"></a>1. 安装 locate</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install mlocate --&gt; 安装包updatedb --&gt; 更新数据库复制代码locate file.txtlocate fil*.txt</span><br></pre></td></tr></table></figure><p>[注意] <code>locate</code> 命令会去文件数据库中查找命令，而不是全磁盘查找，因此刚创建的文件并不会更新到数据库中，所以无法被查找到，可以执行 <code>updatedb</code> 命令去更新数据库。</p><h3 id="2-find"><a href="#2-find" class="headerlink" title="2. find"></a>2. find</h3><p>用于查找文件，它会去遍历你的实际硬盘进行查找，而且它允许我们对每个找到的文件进行后续操作，功能非常强大。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &lt;何处&gt; &lt;何物&gt; &lt;做什么&gt;</span><br></pre></td></tr></table></figure><pre><code>*   何处：指定在哪个目录查找，此目录的所有子目录也会被查找。*   何物：查找什么，可以根据文件的名字来查找，也可以根据其大小来查找，还可以根据其最近访问时间来查找。*   做什么：找到文件后，可以进行后续处理，如果不指定这个参数， find 命令只会显示找到的文件。</code></pre><h3 id="3-根据文件名查找"><a href="#3-根据文件名查找" class="headerlink" title="3. 根据文件名查找"></a>3. 根据文件名查找</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -name &quot;file.txt&quot; --&gt; 当前目录以及子目录下通过名称查找文件find . -name &quot;syslog&quot; --&gt; 当前目录以及子目录下通过名称查找文件find &#x2F; -name &quot;syslog&quot; --&gt; 整个硬盘下查找syslogfind &#x2F;var&#x2F;log -name &quot;syslog&quot; --&gt; 在指定的目录&#x2F;var&#x2F;log下查找syslog文件find &#x2F;var&#x2F;log -name &quot;syslog*&quot; --&gt; 查找syslog1、syslog2 ... 等文件，通配符表示所有find &#x2F;var&#x2F;log -name &quot;*syslog*&quot; --&gt; 查找包含syslog的文件</span><br></pre></td></tr></table></figure><p>[注意] <code>find</code> 命令只会查找完全符合 “何物” 字符串的文件，而 <code>locate</code> 会查找所有包含关键字的文件。</p><h3 id="4-根据文件大小查找"><a href="#4-根据文件大小查找" class="headerlink" title="4. 根据文件大小查找"></a>4. 根据文件大小查找</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F;var -size +10M --&gt; &#x2F;var 目录下查找文件大小超过 10M 的文件find &#x2F;var -size -50k --&gt; &#x2F;var 目录下查找文件大小小于 50k 的文件find &#x2F;var -size +1G --&gt; &#x2F;var 目录下查找文件大小查过 1G 的文件find &#x2F;var -size 1M --&gt; &#x2F;var 目录下查找文件大小等于 1M 的文件</span><br></pre></td></tr></table></figure><h3 id="5-根据文件最近访问时间查找"><a href="#5-根据文件最近访问时间查找" class="headerlink" title="5. 根据文件最近访问时间查找"></a>5. 根据文件最近访问时间查找</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -name &quot;*.txt&quot; -atime -7  --&gt; 近 7天内访问过的.txt结尾的文件</span><br></pre></td></tr></table></figure><h3 id="6-仅查找目录或文件"><a href="#6-仅查找目录或文件" class="headerlink" title="6. 仅查找目录或文件"></a>6. 仅查找目录或文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;file&quot; -type f  --&gt; 只查找当前目录下的file文件find . -name &quot;file&quot; -type d  --&gt; 只查找当前目录下的file目录</span><br></pre></td></tr></table></figure><h3 id="7-操作查找结果"><a href="#7-操作查找结果" class="headerlink" title="7. 操作查找结果"></a>7. 操作查找结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -name &quot;*.txt&quot; -printf &quot;%p - %u\n&quot; --&gt; 找出所有后缀为txt的文件，并按照 %p - %u\n 格式打印，其中%p&#x3D;文件名，%u&#x3D;文件所有者find -name &quot;*.jpg&quot; -delete --&gt; 删除当前目录以及子目录下所有.jpg为后缀的文件，不会有删除提示，因此要慎用find -name &quot;*.c&quot; -exec chmod 600 &#123;&#125; \; --&gt; 对每个.c结尾的文件，都进行 -exec 参数指定的操作，&#123;&#125; 会被查找到的文件替代，\; 是必须的结尾find -name &quot;*.c&quot; -ok chmod 600 &#123;&#125; \; --&gt; 和上面的功能一直，会多一个确认提示</span><br></pre></td></tr></table></figure><h1 id="软件仓库"><a href="#软件仓库" class="headerlink" title="软件仓库"></a>软件仓库</h1><p><code>Linux</code> 下软件是以包的形式存在，一个软件包其实就是软件的所有文件的压缩包，是二进制的形式，包含了安装软件的所有指令。<code>Red Hat</code> 家族的软件包后缀名一般为 <code>.rpm</code> ，<code>Debian</code> 家族的软件包后缀是 <code>.deb</code> 。</p><p><code>Linux</code> 的包都存在一个仓库，叫做软件仓库，它可以使用 <code>yum</code> 来管理软件包， <code>yum</code> 是 <code>CentOS</code> 中默认的包管理工具，适用于 <code>Red Hat</code> 一族。可以理解成 <code>Node.js</code> 的 <code>npm</code> 。</p><h2 id="yum-常用命令"><a href="#yum-常用命令" class="headerlink" title="yum 常用命令"></a>yum 常用命令</h2><h3 id="1-命令"><a href="#1-命令" class="headerlink" title="1. 命令"></a>1. 命令</h3><pre><code>*   `yum update | yum upgrade` 更新软件包*   `yum search xxx` 搜索相应的软件包*   `yum install xxx` 安装软件包*   `yum remove xxx` 删除软件包</code></pre><h2 id="切换-CentOS-软件源"><a href="#切换-CentOS-软件源" class="headerlink" title="切换 CentOS 软件源"></a>切换 CentOS 软件源</h2><p>有时候 <code>CentOS</code> 默认的 <code>yum</code> 源不一定是国内镜像，导致 <code>yum</code> 在线安装及更新速度不是很理想。这时候需要将 <code>yum</code> 源设置为国内镜像站点。国内主要开源的镜像站点是网易和阿里云。<br>1、首先备份系统自带 <code>yum</code> 源配置文件 <code>mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</code><br>2、下载阿里云的 <code>yum</code> 源配置文件到 <code>/etc/yum.repos.d/CentOS7</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repo</span><br></pre></td></tr></table></figure><p>3、生成缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum makecache</span><br></pre></td></tr></table></figure><hr><h1 id="阅读手册"><a href="#阅读手册" class="headerlink" title="阅读手册"></a>阅读手册</h1><p><code>Linux</code> 命令种类繁杂，我们凭借记忆不可能全部记住，因此学会查用手册是非常重要的。</p><h3 id="1-man"><a href="#1-man" class="headerlink" title="1. man"></a>1. man</h3><p>安装更新 man</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y man-pages --&gt; 安装sudo mandb --&gt; 更新</span><br></pre></td></tr></table></figure><h4 id="man-手册种类"><a href="#man-手册种类" class="headerlink" title="man 手册种类"></a>man 手册种类</h4><ol><li>可执行程序或 <code>Shell</code> 命令；</li><li>系统调用（ <code>Linux</code> 内核提供的函数）；</li><li>库调用（程序库中的函数）；</li><li>文件（例如 <code>/etc/passwd</code> ）</li><li>特殊文件（通常在 <code>/dev</code> 下）；</li><li>游戏；</li><li>杂项（ <code>man(7)</code> ，<code>groff(7)</code> ）；</li><li>系统管理命令（通常只能被 <code>root</code> 用户使用）；</li><li>内核子程序。</li></ol><h4 id="man-数字-命令"><a href="#man-数字-命令" class="headerlink" title="man + 数字 + 命令"></a>man + 数字 + 命令</h4><p>输入 man + 数字 + 命令/函数，可以查到相关的命令和函数，若不加数字， <code>man</code> 默认从数字较小的手册中寻找相关命令和函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man 3 rand  --&gt; 表示在手册的第三部分查找 rand 函数man ls    --&gt; 查找 ls 用法手册</span><br></pre></td></tr></table></figure><p>man 手册核心区域解析：(以 <code>man pwd</code> 为例)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NAME # 命令名称和简单描述     pwd -- return working directory nameSYNOPSIS # 使用此命令的所有方法     pwd [-L | -P]DESCRIPTION # 包括所有参数以及用法     The pwd utility writes the absolute pathname of the current working directory to the standard output.     Some shells may provide a builtin pwd command which is similar or identical to this utility.  Consult the builtin(1) manual page.     The options are as follows:     -L      Display the logical current working directory.     -P      Display the physical current working directory (all symbolic links resolved).     If no options are specified, the -L option is assumed.SEE ALSO # 扩展阅读相关命令     builtin(1), cd(1), csh(1), sh(1), getcwd(3)</span><br></pre></td></tr></table></figure><h3 id="2-help"><a href="#2-help" class="headerlink" title="2. help"></a>2. help</h3><p><code>man</code> 命令像新华词典一样可以查询到命令或函数的详细信息，但其实我们还有更加快捷的方式去查询， <code>command --help</code> 或 · ，它没有 <code>man</code> 命令显示的那么详细，但是它更加易于阅读。</p><hr><h1 id="Linux-进阶"><a href="#Linux-进阶" class="headerlink" title="Linux 进阶"></a>Linux 进阶</h1><h1 id="文本操作"><a href="#文本操作" class="headerlink" title="文本操作"></a>文本操作</h1><h3 id="1-grep"><a href="#1-grep" class="headerlink" title="1. grep"></a>1. grep</h3><p>全局搜索一个正则表达式，并且打印到屏幕。简单来说就是，在文件中查找关键字，并显示关键字所在行。<br>基础语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep text file # text代表要搜索的文本，file代表供搜索的文件# 实例[root@lion ~]# grep path &#x2F;etc&#x2F;profilepathmunge () &#123;    pathmunge &#x2F;usr&#x2F;sbin    pathmunge &#x2F;usr&#x2F;local&#x2F;sbin    pathmunge &#x2F;usr&#x2F;local&#x2F;sbin after    pathmunge &#x2F;usr&#x2F;sbin afterunset -f pathmunge</span><br></pre></td></tr></table></figure><p>常用参数<br>    *   <code>-i</code> 忽略大小写， <code>grep -i path /etc/profile</code><br>    *   <code>-n</code> 显示行号，<code>grep -n path /etc/profile</code><br>    *   <code>-v</code> 只显示搜索文本不在的那些行，<code>grep -v path /etc/profile</code><br>    *   <code>-r</code> 递归查找， <code>grep -r hello /etc</code> ，<code>Linux</code> 中还有一个 <code>rgrep</code> 命令，作用相当于 <code>grep -r</code></p><p>高级用法<br><code>grep</code> 可以配合正则表达式使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E path &#x2F;etc&#x2F;profile --&gt; 完全匹配pathgrep -E ^path &#x2F;etc&#x2F;profile --&gt; 匹配path开头的字符串grep -E [Pp]ath &#x2F;etc&#x2F;profile --&gt; 匹配path或Path</span><br></pre></td></tr></table></figure><h3 id="2-sort"><a href="#2-sort" class="headerlink" title="2. sort"></a>2. sort</h3><p>对文件的行进行排序。<br>基础语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort name.txt # 对name.txt文件进行排序</span><br></pre></td></tr></table></figure><p>实例用法<br>为了演示方便，我们首先创建一个文件 <code>name.txt</code> ，放入以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ChristopherShawnTedRockNoahZacharyBella</span><br></pre></td></tr></table></figure><p>执行 <code>sort name.txt</code> 命令，会对文本内容进行排序。<br>常用参数<br>    *   <code>-o</code> 将排序后的文件写入新文件， <code>sort -o name_sorted.txt name.txt</code> ；<br>    *   <code>-r</code> 倒序排序， <code>sort -r name.txt</code> ；<br>    *   <code>-R</code> 随机排序， <code>sort -R name.txt</code> ；<br>    *   <code>-n</code> 对数字进行排序，默认是把数字识别成字符串的，因此 138 会排在 25 前面，如果添加了 <code>-n</code> 数字排序的话，则 25 会在 138 前面。</p><h3 id="3-wc"><a href="#3-wc" class="headerlink" title="3. wc"></a>3. wc</h3><p><code>word count</code> 的缩写，用于文件的统计。它可以统计单词数目、行数、字符数，字节数等。<br>基础语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc name.txt # 统计name.txt</span><br></pre></td></tr></table></figure><p>实例用法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@lion ~]# wc name.txt 13 13 91 name.txt</span><br></pre></td></tr></table></figure><pre><code>*   第一个13，表示行数；*   第二个13，表示单词数；*   第三个91，表示字节数。</code></pre><p>常用参数<br>    *   <code>-l</code> 只统计行数， <code>wc -l name.txt</code> ；<br>    *   <code>-w</code> 只统计单词数， <code>wc -w name.txt</code> ；<br>    *   <code>-c</code> 只统计字节数， <code>wc -c name.txt</code> ；<br>    *   <code>-m</code> 只统计字符数， <code>wc -m name.txt</code> 。</p><h3 id="4-uniq"><a href="#4-uniq" class="headerlink" title="4. uniq"></a>4. uniq</h3><p>删除文件中的重复内容。<br>基础语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uniq name.txt # 去除name.txt重复的行数，并打印到屏幕上uniq name.txt uniq_name.txt # 把去除重复后的文件保存为 uniq_name.txt</span><br></pre></td></tr></table></figure><p>【注意】它只能去除连续重复的行数。</p><p>常用参数<br>    *   <code>-c</code> 统计重复行数， <code>uniq -c name.txt</code> ；<br>    *   <code>-d</code> 只显示重复的行数， <code>uniq -d name.txt</code> 。</p><h3 id="5-cut"><a href="#5-cut" class="headerlink" title="5. cut"></a>5. cut</h3><p>剪切文件的一部分内容。<br>基础语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut -c 2-4 name.txt # 剪切每一行第二到第四个字符</span><br></pre></td></tr></table></figure><p>常用参数<br>    *   <code>-d</code> 用于指定用什么分隔符（比如逗号、分号、双引号等等） <code>cut -d , name.txt</code> ；<br>    *   <code>-f</code> 表示剪切下用分隔符分割的哪一块或哪几块区域， <code>cut -d , -f 1 name.txt</code> 。</p><hr><h1 id="重定向管道流"><a href="#重定向管道流" class="headerlink" title="重定向管道流"></a>重定向管道流</h1><p>在 <code>Linux</code> 中一个命令的去向可以有3个地方：终端、文件、作为另外一个命令的入参。<br><img src= "/img/loading.gifs" data-src="/images/linux/10.jpeg" alt=""><br>命令一般都是通过键盘输入，然后输出到终端、文件等地方，它的标准用语是 <code>stdin</code> 、 <code>stdout</code> 以及 <code>stderr</code> 。<br>    *   标准输入 <code>stdin</code> ，终端接收键盘输入的命令，会产生两种输出；<br>    *   标准输出 <code>stdout</code> ，终端输出的信息（不包含错误信息）；<br>    *   标准错误输出 <code>stderr</code> ，终端输出的错误信息。<br>    <img src= "/img/loading.gifs" data-src="/images/linux/11.jpeg" alt=""></p><h3 id="1-重定向"><a href="#1-重定向" class="headerlink" title="1. 重定向"></a>1. 重定向</h3><p>把本来要显示在终端的命令结果，输送到别的地方（到文件中或者作为其他命令的输入）。</p><h4 id="输出重定向-gt"><a href="#输出重定向-gt" class="headerlink" title="输出重定向 &gt;"></a>输出重定向 &gt;</h4><p><code>&gt;</code>表示重定向到新的文件， <code>cut -d , -f 1 notes.csv &gt; name.csv</code> ，它表示通过逗号剪切<code>notes.csv</code> 文件（剪切完有3个部分）获取第一个部分，重定向到 <code>name.csv</code> 文件。</p><p>我们来看一个具体示例，学习它的使用，假设我们有一个文件 <code>notes.csv</code> ，文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mark1,951&#x2F;100,很不错1Mark2,952&#x2F;100,很不错2Mark3,953&#x2F;100,很不错3Mark4,954&#x2F;100,很不错4Mark5,955&#x2F;100,很不错5Mark6,956&#x2F;100,很不错6</span><br></pre></td></tr></table></figure><p>执行命令：<code>cut -d , -f 1 notes.csv &gt; name.csv</code> 最后输出如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mark1Mark2Mark3Mark4Mark5Mark6</span><br></pre></td></tr></table></figure><p>【注意】使用 <code>&gt;</code> 要注意，如果输出的文件不存在它会新建一个，如果输出的文件已经存在，则会覆盖。因此执行这个操作要非常小心，以免覆盖其它重要文件。</p><h4 id="输出重定向-gt-gt"><a href="#输出重定向-gt-gt" class="headerlink" title="输出重定向 &gt;&gt;"></a>输出重定向 &gt;&gt;</h4><p>表示重定向到文件末尾，因此它不会像 <code>&gt;</code> 命令这么危险，它是追加到文件的末尾（当然如果文件不存在，也会被创建）。</p><p>再次执行 <code>cut -d , -f 1 notes.csv &gt;&gt; name.csv</code> ，则会把名字追加到 <code>name.csv</code> 里面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mark1Mark2Mark3Mark4Mark5Mark6Mark1Mark2Mark3Mark4Mark5Mark6</span><br></pre></td></tr></table></figure><p>我们平时读的 <code>log</code> 日志文件其实都是用这个命令输出的。</p><h4 id="输出重定向-2-gt"><a href="#输出重定向-2-gt" class="headerlink" title="输出重定向 2&gt;"></a>输出重定向 2&gt;</h4><p>标准错误输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat not_exist_file.csv &gt; res.txt 2&gt; errors.log</span><br></pre></td></tr></table></figure><p>【注意】：<br>    *   当我们 <code>cat</code> 一个文件时，会把文件内容打印到屏幕上，这个是标准输出；<br>    *   当使用了 <code>&gt; res.txt</code> 时，则不会打印到屏幕，会把标准输出写入文件 res.txt 文件中；<br>    *   2&gt; errors.log 当发生错误时会写入 <code>errors.log</code> 文件中。</p><h4 id="输出重定向-2-gt-gt"><a href="#输出重定向-2-gt-gt" class="headerlink" title="输出重定向 2&gt;&gt;"></a>输出重定向 2&gt;&gt;</h4><p>标准错误输出（追加到文件末尾）同 <code>&gt;&gt;</code> 相似。</p><p>输出重定向 2&gt;&amp;1<br>标准输出和标准错误输出都重定向都一个地方</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat not_exist_file.csv &gt; res.txt 2&gt;&amp;1  # 覆盖输出cat not_exist_file.csv &gt;&gt; res.txt 2&gt;&amp;1 # 追加输出</span><br></pre></td></tr></table></figure><p>目前为止，我们接触的命令的输入都来自命令的参数，其实命令的输入还可以来自文件或者键盘的输入。<br><img src= "/img/loading.gifs" data-src="/images/linux/12.jpeg" alt=""></p><h4 id="输入重定向-lt"><a href="#输入重定向-lt" class="headerlink" title="输入重定向 &lt;"></a>输入重定向 &lt;</h4><p><code>&lt;</code> 符号用于指定命令的输入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &lt; name.csv # 指定命令的输入为 name.csv</span><br></pre></td></tr></table></figure><p>虽然它的运行结果与 <code>cat name.csv</code> 一样，但是它们的原理却完全不同。<br>    *   <code>cat name.csv</code> 表示 <code>cat</code> 命令接收的输入是 <code>notes.csv</code> 文件名，那么要先打开这个文件，然后打印出文件内容。<br>    *   <code>cat &lt; name.csv</code> 表示 <code>cat</code> 命令接收的输入直接是 <code>notes.csv</code> 这个文件的内容， <code>cat</code>命令只负责将其内容打印，打开文件并将文件内容传递给 <code>cat</code> 命令的工作则交给终端完成。</p><h4 id="输入重定向-lt-lt"><a href="#输入重定向-lt-lt" class="headerlink" title="输入重定向 &lt;&lt;"></a>输入重定向 &lt;&lt;</h4><p>将键盘的输入重定向为某个命令的输入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort -n &lt;&lt; END # 输入这个命令之后，按下回车，终端就进入键盘输入模式，其中END为结束命令（这个可以自定义）wc -m &lt;&lt; END # 统计输入的单词</span><br></pre></td></tr></table></figure><ol><li>管道 |<br>把两个命令连起来使用，一个命令的输出作为另外一个命令的输入，英文是 <code>pipeline</code> ，可以想象一个个水管连接起来，管道算是重定向流的一种。<br><img src= "/img/loading.gifs" data-src="/images/linux/13.jpeg" alt=""></li></ol><p>举几个实际用法案例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut -d , -f 1 name.csv | sort &gt; sorted_name.txt # 第一步获取到的 name 列表，通过管道符再进行排序，最后输出到sorted_name.txtdu | sort -nr | head # du 表示列举目录大小信息# sort 进行排序,-n 表示按数字排序，-r 表示倒序# head 前10行文件grep log -Ir &#x2F;var&#x2F;log | cut -d : -f 1 | sort | uniq# grep log -Ir &#x2F;var&#x2F;log 表示在log文件夹下搜索 &#x2F;var&#x2F;log 文本，-r 表示递归，-I 用于排除二进制文件# cut -d : -f 1 表示通过冒号进行剪切，获取剪切的第一部分# sort 进行排序# uniq 进行去重</span><br></pre></td></tr></table></figure><ol start="2"><li>流<br>流并非一个命令，在计算机科学中，流 <code>stream</code> 的含义是比较难理解的，记住一点即可：流就是读一点数据, 处理一点点数据。其中数据一般就是二进制格式。 上面提及的重定向或管道，就是把数据当做流去运转的。</li></ol><p>到此我们就接触了，流、重定向、管道等 <code>Linux</code> 高级概念及指令。其实你会发现关于流和管道在其它语言中也有广泛的应用。<code>Angular</code> 中的模板语法中可以使用管道。<code>Node.js</code> 中也有<code>stream</code> 流的概念。</p><hr><h1 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h1><p>在 <code>Windows</code> 中通过 <code>Ctrl + Alt + Delete</code> 快捷键查看软件进程。</p><ol><li><p>w<br>帮助我们快速了解系统中目前有哪些用户登录着，以及他们在干什么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@lion ~]# w 06:31:53 up 25 days,  9:53,  1 user,  load average: 0.00, 0.01, 0.05USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHATroot     pts&#x2F;0    118.31.243.53    05:56    1.00s  0.02s  0.00s w 06:31:53：表示当前时间up 25 days, 9:53：表示系统已经正常运行了“25天9小时53分钟”1 user：表示一个用户load average: 0.00, 0.01, 0.05：表示系统的负载，3个值分别表示“1分钟的平均负载”，“5分钟的平均负载”，“15分钟的平均负载” USER：表示登录的用于 TTY：登录的终端名称为pts&#x2F;0 FROM：连接到服务器的ip地址 LOGIN@：登录时间 IDLE：用户有多久没有活跃了 JCPU：该终端所有相关的进程使用的 CPU 时间，每当进程结束就停止计时，开始新的进程则会重新计时 PCPU：表示 CPU 执行当前程序所消耗的时间，当前进程就是在 WHAT 列里显示的程序 WHAT：表示当下用户正运行的程序是什么，这里我运行的是</span><br></pre></td></tr></table></figure></li><li><p>ps<br>用于显示当前系统中的进程， <code>ps</code> 命令显示的进程列表不会随时间而更新，是静态的，是运行 ps 命令那个时刻的状态或者说是一个进程快照。<br>基础语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@lion ~]# ps  PID TTY          TIME CMD 1793 pts&#x2F;0    00:00:00 bash 4756 pts&#x2F;0    00:00:00 ps  PID：进程号，每个进程都有唯一的进程号 TTY：进程运行所在的终端 TIME：进程运行时间 CMD：产生这个进程的程序名，如果在进程列表中看到有好几行都是同样的程序名，那么就是同样的程序产生了不止一个进程</span><br></pre></td></tr></table></figure><p>常用参数</p><ul><li><code>-ef</code> 列出所有进程;</li><li><code>-efH</code> 以乔木状列举出所有进程;</li><li><code>-u</code> 列出此用户运行的进程;</li><li><code>-aux</code> 通过 <code>CPU</code> 和内存使用来过滤进程 <code>ps -aux | less</code> ;</li><li><code>-aux --sort -pcpu</code> 按 <code>CPU</code> 使用降序排列， <code>-aux --sort -pmem</code> 表示按内存使用降序排列;</li><li><code>-axjf</code> 以树形结构显示进程， <code>ps -axjf 它和 pstree</code> 效果类似。</li></ul></li><li><p>top<br>获取进程的动态列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top - 07:20:07 up 25 days, 10:41,  1 user,  load average: 0.30, 0.10, 0.07Tasks:  67 total,   1 running,  66 sleeping,   0 stopped,   0 zombie%Cpu(s):  0.7 us,  0.3 sy,  0.0 ni, 99.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 stKiB Mem :  1882072 total,   552148 free,   101048 used,  1228876 buff&#x2F;cacheKiB Swap:        0 total,        0 free,        0 used.  1594080 avail Mem   PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                                                                                         956 root      10 -10  133964  15848  10240 S  0.7  0.8 263:13.01 AliYunDun                                                                                                         1 root      20   0   51644   3664   2400 S  0.0  0.2   3:23.63 systemd                                                                                                           2 root      20   0       0      0      0 S  0.0  0.0   0:00.05 kthreadd                                                                                                          4 root       0 -20       0      0      0 S  0.0  0.0   0:00.00 kworker&#x2F;0:0H</span><br></pre></td></tr></table></figure><p>【注意】</p><ul><li><code>top - 07:20:07 up 25 days, 10:41, 1 user, load average: 0.30, 0.10, 0.07</code> 相当 <code>w</code>命令的第一行的信息。</li><li>展示的这些进程是按照使用处理器 <code>%CPU</code> 的使用率来排序的。</li></ul></li><li><p>kill<br>结束一个进程， <code>kill + PID</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill 956 # 结束进程号为956的进程kill 956 957 # 结束多个进程kill -9 7291 # 强制结束进程</span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="管理进程"><a href="#管理进程" class="headerlink" title="管理进程"></a>管理进程</h1><h3 id="1-进程状态"><a href="#1-进程状态" class="headerlink" title="1. 进程状态"></a>1. 进程状态</h3><p>主要是切换进程的状态。我们先了解下 <code>Linux</code> 下进程的五种状态：<br>    1. 状态码 <code>R</code> ：表示正在运行的状态；<br>    2. 状态码 <code>S</code> ：表示中断（休眠中，受阻，当某个条件形成后或接受到信号时，则脱离该状态）；<br>    3. 状态码 <code>D</code> ：表示不可中断（进程不响应系统异步信号，即使用kill命令也不能使其中断）；<br>    4. 状态码 <code>Z</code> ：表示僵死（进程已终止，但进程描述符依然存在，直到父进程调用 <code>wait4()</code>系统函数后将进程释放）；<br>    5. 状态码 <code>T</code> ：表示停止（进程收到 <code>SIGSTOP</code> 、 <code>SIGSTP</code> 、 <code>SIGTIN</code> 、 <code>SIGTOU</code> 等停止信号后停止运行）。</p><h3 id="2-前台进程-amp-后台进程"><a href="#2-前台进程-amp-后台进程" class="headerlink" title="2.前台进程 &amp; 后台进程"></a>2.前台进程 &amp; 后台进程</h3><p>默认情况下，用户创建的进程都是前台进程，前台进程从键盘读取数据，并把处理结果输出到显示器。例如运行 top 命令，这就是一个一直运行的前台进程。</p><p>后台进程的优点是不必等待程序运行结束，就可以输入其它命令。在需要执行的命令后面添加&amp; 符号，就表示启动一个后台进程。</p><h4 id="2-1-amp"><a href="#2-1-amp" class="headerlink" title="2.1 &amp;"></a>2.1 &amp;</h4><p>启动后台进程，它的缺点是后台进程与终端相关联，一旦关闭终端，进程就自动结束了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp name.csv name-copy.csv &amp;</span><br></pre></td></tr></table></figure><h4 id="2-2-nohup"><a href="#2-2-nohup" class="headerlink" title="2.2 nohup"></a>2.2 nohup</h4><p>使进程不受挂断（关闭终端等动作）的影响。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup cp name.csv name-copy.csv</span><br></pre></td></tr></table></figure><p><code>nohup</code> 命令也可以和 <code>&amp;</code> 结合使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup cp name.csv name-copy.csv &amp;</span><br></pre></td></tr></table></figure><h4 id="2-3-bg"><a href="#2-3-bg" class="headerlink" title="2.3 bg"></a>2.3 bg</h4><p>使一个“后台暂停运行”的进程，状态改为“后台运行”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bg %1 # 不加任何参数的情况下，bg命令会默认作用于最近的一个后台进程，如果添加参数则会作用于指定标号的进</span><br></pre></td></tr></table></figure><p>实际案例1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 执行 grep -r &quot;log&quot; &#x2F; &gt; grep_log 2&gt;&amp;1 命令启动一个前台进程，并且忘记添加 &amp; 符号2. ctrl + z 使进程状态转为后台暂停3. 执行 bg 将命令转为后台运行</span><br></pre></td></tr></table></figure><p>实际案例2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">前端开发时我们经常会执行 yarn start 启动项目此时我们执行 ctrl + z 先使其暂停然后执行 bg 使其转为后台运行这样当前终端就空闲出来可以干其它事情了，如果想要唤醒它就使用 fg 命令即可（后面会讲）</span><br></pre></td></tr></table></figure><h4 id="2-4-jobs"><a href="#2-4-jobs" class="headerlink" title="2.4 jobs"></a>2.4 jobs</h4><p>显示当前终端后台进程状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@lion ~]# jobs[1]+  Stopped                 top[2]-  Running                 grep --color&#x3D;auto -r &quot;log&quot; &#x2F; &gt; grep_log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><h4 id="2-5-fg"><a href="#2-5-fg" class="headerlink" title="2.5 fg"></a>2.5 fg</h4><p><code>fg</code> 使进程转为前台运行，用法和 <code>bg</code> 命令类似。<br>我们用一张图来表示前后台进程切换：<br><img src= "/img/loading.gifs" data-src="/images/linux/15.jpeg" alt=""><br>我们可以使程序在后台运行，成为后台进程，这样在当前终端中我们就可以做其他事情了，而不必等待此进程运行结束。</p><hr><h1 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h1><p>一个运行起来的程序被称为进程。在 <code>Linux</code> 中有些进程是特殊的，它不与任何进程关联，不论用户的身份如何，都在后台运行，这些进程的父进程是 <code>PID</code> 为1的进程， <code>PID</code> 为1的进程只在系统关闭时才会被销毁。它们会在后台一直运行等待分配工作。我们将这类进程称之为守护进程 <code>daemon</code> 。</p><p>守护进程的名字通常会在最后有一个 <code>d</code> ，表示 <code>daemon</code> 守护的意思，例如 <code>systemd、httpd</code> 。</p><h3 id="1-systemd"><a href="#1-systemd" class="headerlink" title="1. systemd"></a>1. systemd</h3><p><code>systemd</code> 是一个 <code>Linux</code> 系统基础组件的集合，提供了一个系统和服务管理器，运行为 <code>PID 1</code> 并负责启动其它程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MMANDroot         1  0.0  0.2  51648  3852 ?        Ss   Feb01   1:50 &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;systemd --switched-root --system --deserialize 22</span><br></pre></td></tr></table></figure><p>通过命令也可以看到 <code>PID</code> 为1的进程就是 <code>systemd</code> 的系统进程。</p><p><code>systemd</code> 常用命令（它是一组命令的集合）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx # 启动服务systemctl stop nginx # 停止服务systemctl restart nginx # 重启服务systemctl status nginx # 查看服务状态systemctl reload nginx # 重载配置文件(不停止服务的情况)systemctl enable nginx # 开机自动启动服务systemctl disable nginx # 开机不自动启动服务systemctl is-enabled nginx # 查看服务是否开机自动启动systemctl list-unit-files --type&#x3D;service # 查看各个级别下服务的启动和禁用情况</span><br></pre></td></tr></table></figure><hr><h1 id="文件压缩解压"><a href="#文件压缩解压" class="headerlink" title="文件压缩解压"></a>文件压缩解压</h1><pre><code>*   打包：是将多个文件变成一个总的文件，它的学名叫存档、归档。*   压缩：是将多个文件变成一个总的文件，它的学名叫存档、归档。</code></pre><p>我们常常使用 tar 将多个文件归档为一个总的文件，称为 archive 。然后用 gzip 或 bzip2 命令将 archive 压缩为更小的文件。<br><img src= "/img/loading.gifs" data-src="/images/linux/16.jpeg" alt=""></p><h3 id="1-tar"><a href="#1-tar" class="headerlink" title="1. tar"></a>1. tar</h3><p>创建一个 <code>tar</code> 归档。</p><p>基础用法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf sort.tar sort&#x2F; # 将sort文件夹归档为sort.tartar -cvf archive.tar file1 file2 file3 # 将 file1 file2 file3 归档为archive.tar</span><br></pre></td></tr></table></figure><p>常用参数<br>    *   <code>-cvf</code> 表示 <code>create</code>（创建）+ <code>verbose</code>（细节）+ <code>file</code>（文件），创建归档文件并显示操作细节；<br>    *   <code>-tf</code> 显示归档里的内容，并不解开归档；<br>    *   <code>-rvf</code> 追加文件到归档， <code>tar -rvf archive.tar file.txt</code> ；<br>    *   <code>-xvf</code> 解开归档， <code>tar -xvf archive.tar</code> 。</p><h3 id="2-gzip-gunzip"><a href="#2-gzip-gunzip" class="headerlink" title="2. gzip / gunzip"></a>2. gzip / gunzip</h3><p>“压缩/解压”归档，默认用 <code>gzip</code> 命令，压缩后的文件后缀名为 <code>.tar.gz</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip archive.tar # 压缩gunzip archive.tar.gz # 解压</span><br></pre></td></tr></table></figure><h3 id="3-tar-归档-压缩"><a href="#3-tar-归档-压缩" class="headerlink" title="3. tar 归档+压缩"></a>3. tar 归档+压缩</h3><p>可以用 tar 命令同时完成归档和压缩的操作，就是给 tar 命令多加一个选项参数，使之完成归档操作后，还是调用 gzip 或 bzip2 命令来完成压缩操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zcvf archive.tar.gz archive&#x2F; # 将archive文件夹归档并压缩tar -zxvf archive.tar.gz # 将archive.tar.gz归档压缩文件解压</span><br></pre></td></tr></table></figure><h3 id="4-zcat、zless、zmore"><a href="#4-zcat、zless、zmore" class="headerlink" title="4. zcat、zless、zmore"></a>4. zcat、zless、zmore</h3><p>之前讲过使用 <code>cat less more</code> 可以查看文件内容，但是压缩文件的内容是不能使用这些命令进行查看的，而要使用 <code>zcat、zless、zmore</code> 进行查看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcat archive.tar.gz</span><br></pre></td></tr></table></figure><h3 id="5-zip-unzip"><a href="#5-zip-unzip" class="headerlink" title="5. zip/unzip"></a>5. zip/unzip</h3><p>“压缩/解压” <code>zip</code> 文件（ <code>zip</code> 压缩文件一般来自 <code>windows</code> 操作系统）。</p><p>命令安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># Red Hat 一族中的安装方式yum install zip yum install unzip</span><br></pre></td></tr></table></figure><p>基础用法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip archive.zip # 解压 .zip 文件unzip -l archive.zip # 不解开 .zip 文件，只看其中内容zip -r sort.zip sort&#x2F; # 将sort文件夹压缩为 sort.zip，其中-r表示递归</span><br></pre></td></tr></table></figure><hr><h1 id="编译安装软件"><a href="#编译安装软件" class="headerlink" title="编译安装软件"></a>编译安装软件</h1><p>之前我们学会了使用 <code>yum</code> 命令进行软件安装，如果碰到 <code>yum</code> 仓库中没有的软件，我们就需要会更高级的软件安装“源码编译安装”。</p><h3 id="1-编译安装"><a href="#1-编译安装" class="headerlink" title="1. 编译安装"></a>1. 编译安装</h3><p>简单来说，编译就是将程序的源代码转换成可执行文件的过程。大多数 <code>Linux</code> 的程序都是开放源码的，可以编译成适合我们的电脑和操纵系统属性的可执行文件。</p><p>基本步骤如下：<br>    1. 下载源代码<br>    2. 解压压缩包<br>    3. 配置<br>    4. 编译<br>    5. 安装<br>实际案例</p><h4 id="1、-下载"><a href="#1、-下载" class="headerlink" title="1、 下载"></a>1、 下载</h4><p>我们来编译安装 <code>htop</code> 软件，首先在它的官网下载源码：<code>bintray.com/htop/source…[1]</code><br>下载好的源码在本机电脑上使用如下命令同步到服务器上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp 文件名 用户名@服务器ip:目标路径scp ~&#x2F;Desktop&#x2F;htop-3.0.0.tar.gz root@121.42.11.34:.</span><br></pre></td></tr></table></figure><p>也可以使用 <code>wegt</code> 进行下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wegt+下载地址wegt https:&#x2F;&#x2F;bintray.com&#x2F;htop&#x2F;source&#x2F;download_file?file_path&#x3D;htop-3.0.0.tar.gz</span><br></pre></td></tr></table></figure><h4 id="2、解压文件"><a href="#2、解压文件" class="headerlink" title="2、解压文件"></a>2、解压文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf htop-3.0.0.tar.gz # 解压cd htop-3.0.0 # 进入目录</span><br></pre></td></tr></table></figure><h4 id="3、配置"><a href="#3、配置" class="headerlink" title="3、配置"></a>3、配置</h4><p>执行 <code>./configure</code> ，它会分析你的电脑去确认编译所需的工具是否都已经安装了。</p><h4 id="4、编译"><a href="#4、编译" class="headerlink" title="4、编译"></a>4、编译</h4><p>执行 <code>make</code> 命令</p><h4 id="5、安装"><a href="#5、安装" class="headerlink" title="5、安装"></a>5、安装</h4><p>执行 <code>make install</code> 命令，安装完成后执行 <code>ls /usr/local/bin/</code> 查看是否有 <code>htop</code> 命令。如果有就可以执行 <code>htop</code> 命令查看系统进程了。</p><hr><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h3 id="1-ifconfig"><a href="#1-ifconfig" class="headerlink" title="1. ifconfig"></a>1. ifconfig</h3><p>查看 <code>ip</code> 网络相关信息，如果命令不存在的话， 执行命令 <code>yum install net-tools</code> 安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00:16:3e:04:9c:cd  txqueuelen 1000  (Ethernet)        RX packets 1592318  bytes 183722250 (175.2 MiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 1539361  bytes 154044090 (146.9 MiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0lo: flags&#x3D;73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536        inet 127.0.0.1  netmask 255.0.0.0        loop  txqueuelen 1000  (Local Loopback)        RX packets 0  bytes 0 (0.0 B)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 0  bytes 0 (0.0 B)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><p>参数解析：<br>    *   <code>eth0</code> 对应有线连接（对应你的有线网卡），就是用网线来连接的上网。<code>eth</code> 是 <code>Ethernet</code> 的缩写，表示“以太网”。有些电脑可能同时有好几条网线连着，例如服务器，那么除了<code>eht0</code> ，你还会看到 <code>eth1</code> 、 <code>eth2</code> 等。<br>    *   <code>lo</code> 表示本地回环（ <code>Local Loopback</code> 的缩写，对应一个虚拟网卡）可以看到它的 <code>ip</code> 地址是 <code>127.0.0.1</code> 。每台电脑都应该有这个接口，因为它对应着“连向自己的链接”。这也是被称之为“本地回环”的原因。所有经由这个接口发送的东西都会回到你自己的电脑。看起来好像并没有什么用，但有时为了某些缘故，我们需要连接自己。例如用来测试一个网络程序，但又不想让局域网或外网的用户查看，只能在此台主机上运行和查看所有的网络接口。例如在我们启动一个前端工程时，在浏览器输入 <code>127.0.0.1:3000</code> 启动项目就能查看到自己的 <code>web</code> 网站，并且它只有你能看到。<br>    *   <code>wlan0</code> 表示无线局域网（上面案例并未展示）。</p><h3 id="2-host"><a href="#2-host" class="headerlink" title="2. host"></a>2. host</h3><p><code>ip</code> 地址和主机名的互相转换。</p><p>软件安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install bind-utils</span><br></pre></td></tr></table></figure><p>基础用法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@lion ~]# host github.combaidu.com has address 13.229.188.59 [root@lion ~]# host 13.229.188.5959.188.229.13.in-addr.arpa domain name pointer ec2-13-229-188-59.ap-southeast-1.compute.amazonaws.com.</span><br></pre></td></tr></table></figure><h3 id="3-ssh-连接远程服务器"><a href="#3-ssh-连接远程服务器" class="headerlink" title="3. ssh 连接远程服务器"></a>3. ssh 连接远程服务器</h3><p>通过非对称加密以及对称加密的方式（同 <code>HTTPS</code> 安全连接原理相似）连接到远端服务器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh 用户@ip:port1、ssh root@172.20.10.1:22 # 端口号可以省略不写，默认是22端口2、输入连接密码后就可以操作远端服务器了</span><br></pre></td></tr></table></figure><h4 id="3-1-配置ssh"><a href="#3-1-配置ssh" class="headerlink" title="3.1 配置ssh"></a>3.1 配置ssh</h4><p><code>config</code> 文件可以配置 <code>ssh</code> ，方便批量管理多个 <code>ssh</code> 连接。<br>配置文件分为以下几种：<br>    *   全局 <code>ssh</code> 服务端的配置：<code>/etc/ssh/sshd_config</code> ；<br>    *   全局 <code>ssh</code> 客户端的配置：<code>/etc/ssh/ssh_config</code>（很少修改）；<br>    *   当前用户 <code>ssh</code> 客户端的配置：<code>~/.ssh/config</code> 。<br>    【服务端 <code>config</code> 文件的常用配置参数】<br>        |       服务端 config 参数         |       作用      |<br>    |       —-        |      —-        |<br>    |   Port    |      sshd 服务端口号（默认是22）     |<br>    |   PermitRootLogin    |  是否允许以 root 用户身份登录（默认是可以）     |<br>    |   PasswordAuthentication    |  是否允许密码验证登录（默认是可以）     |<br>    |   PubkeyAuthentication    |  是否允许公钥验证登录（默认是可以）     |<br>    |   PermitEmptyPasswords    |     是否允许空密码登录（不安全，默认不可以）      |<br>    <code>[注意]</code> 修改完服务端配置文件需要重启服务 <code>systemctl restart sshd</code></p><pre><code>【客户端 config 文件的常用配置参数】|       客户端 config 参数         |       作用      | |       ----        |      ----        ||     Host          |         别名          ||     HostName          |         远程主机名（或 IP 地址）          ||     Port          |    连接到远程主机的端口           ||     User          |    用户名           |</code></pre><p>配置当前用户的 <code>config</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 创建configvim ~&#x2F;.ssh&#x2F;config# 填写一下内容Host lion # 别名 HostName 172.x.x.x # ip 地址  Port 22 # 端口  User root # 用户</span><br></pre></td></tr></table></figure><p>这样配置完成后，下次登录时，可以这样登录 <code>ssh lion</code> 会自动识别为 <code>root</code> 用户。</p><p><code>[注意]</code> 这段配置不是在服务器上，而是你自己的机器上，它仅仅是设置了一个别名。</p><h4 id="3-2-免密登录"><a href="#3-2-免密登录" class="headerlink" title="3.2 免密登录"></a>3.2 免密登录</h4><p><code>ssh</code> 登录分两种，一种是基于口令（账号密码），另外一种是基于密钥的方式。<br>基于口令，就是每次登录输入账号和密码，显然这样做是比较麻烦的，今天主要学习如何基于密钥实现免密登录。</p><h4 id="3-3-基于密钥验证原理"><a href="#3-3-基于密钥验证原理" class="headerlink" title="3.3 基于密钥验证原理"></a>3.3 基于密钥验证原理</h4><p>客户机生成密钥对（公钥和私钥），把公钥上传到服务器，每次登录会与服务器的公钥进行比较，这种验证登录的方法更加安全，也被称为“公钥验证登录”。</p><h4 id="3-4-具体实现步骤"><a href="#3-4-具体实现步骤" class="headerlink" title="3.4 具体实现步骤"></a>3.4 具体实现步骤</h4><p>1、在客户机中生成密钥对（公钥和私钥） <code>ssh-keygen</code>（默认使用 RSA 非对称加密算法）</p><p>运行完 <code>ssh-keygen</code> 会在 <code>~/.ssh/</code> 目录下，生成两个文件：<br>    *   <code>id_rsa.pub</code> ：公钥<br>    *   <code>id_rsa</code> ：私钥<br>2、把客户机的公钥传送到服务</p><p>执行 <code>ssh-copy-id root@172.x.x.x</code>（<code>ssh-copy-id</code> 它会把客户机的公钥追加到服务器 <code>~/.ssh/authorized_keys</code> 的文件中）。</p><p>执行完成后，运行 <code>ssh root@172.x.x.x</code> 就可以实现免密登录服务器了。</p><p>配合上面设置好的别名，直接执行 <code>ssh lion</code> 就可以登录，是不是非常方便。</p><h4 id="3-5-wget"><a href="#3-5-wget" class="headerlink" title="3.5 wget"></a>3.5 wget</h4><p>可以使我们直接从终端控制台下载文件，只需要给出文件的HTTP或FTP地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget [参数][URL地址]wget http:&#x2F;&#x2F;www.minjieren.com&#x2F;wordpress-3.1-zh_CN.zip</span><br></pre></td></tr></table></figure><p><code>wget</code> 非常稳定，如果是由于网络原因下载失败， <code>wget</code> 会不断尝试，直到整个文件下载完毕。<br>常用参数<br>    *   <code>-c</code> 继续中断的下载。</p><hr><h1 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h1><h3 id="1-scp"><a href="#1-scp" class="headerlink" title="1. scp"></a>1. scp</h3><p>它是 <code>Secure Copy</code> 的缩写，表示安全拷贝。<code>scp</code> 可以使我们通过网络，把文件从一台电脑拷贝到另一台电脑。<br><code>scp</code> 是基于 <code>ssh</code> 的原理来运作的， <code>ssh</code> 会在两台通过网络连接的电脑之间创建一条安全通信的管道， <code>scp</code> 就利用这条管道安全地拷贝文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp source_file destination_file # source_file 表示源文件，destination_file 表示目标文件</span><br></pre></td></tr></table></figure><p>其中 <code>source_file</code> 和 <code>destination_file</code> 都可以这样表示：<code>user@ip:file_name</code> ， <code>user</code> 是登录名， <code>ip</code> 是域名或 <code>ip</code> <code>地址。file_name</code> 是文件路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp file.txt root@192.168.1.5:&#x2F;root # 表示把我的电脑中当前文件夹下的 file.txt 文件拷贝到远程电脑scp root@192.168.1.5:&#x2F;root&#x2F;file.txt file.txt # 表示把远程电脑上的 file.txt 文件拷贝到本机</span><br></pre></td></tr></table></figure><h3 id="2-rsync"><a href="#2-rsync" class="headerlink" title="2. rsync"></a>2. rsync</h3><p><code>rsync</code> 命令主要用于远程同步文件。它可以同步两个目录，不管它们是否处于同一台电脑。它应该是最常用于“增量备份”的命令了。它就是智能版的 <code>scp</code> 命令。</p><h4 id="2-1-软件安装"><a href="#2-1-软件安装" class="headerlink" title="2.1 软件安装"></a>2.1 软件安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install rsync</span><br></pre></td></tr></table></figure><h4 id="2-2-基础用法"><a href="#2-2-基础用法" class="headerlink" title="2.2 基础用法"></a>2.2 基础用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -arv Images&#x2F; backups&#x2F; # 将Images 目录下的所有文件备份到 backups 目录下rsync -arv Images&#x2F; root@192.x.x.x:backups&#x2F; # 同步到服务器的backups目录下</span><br></pre></td></tr></table></figure><p>常用参数<br>    *  <code>-a</code> 保留文件的所有信息，包括权限，修改日期等；<br>    *  <code>-r</code> 递归调用，表示子目录的所有文件也都包括；<br>    *   <code>-v</code> 冗余模式，输出详细操作信息。<br>默认地， <code>rsync</code> 在同步时并不会删除目标目录的文件，例如你在源目录中删除一个文件，但是用 <code>rsync</code> 同步时，它并不会删除同步目录中的相同文件。如果向删除也可以这么做：<code>rsync -arv --delete Images/ backups/</code> 。</p><hr><h1 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h1><h3 id="1-halt"><a href="#1-halt" class="headerlink" title="1. halt"></a>1. halt</h3><p>关闭系统，需要 <code>root</code> 身份。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">halt</span><br></pre></td></tr></table></figure><h3 id="2-reboot"><a href="#2-reboot" class="headerlink" title="2. reboot"></a>2. reboot</h3><p>重启系统，需要 <code>root</code> 身份。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><h3 id="3-poweroff"><a href="#3-poweroff" class="headerlink" title="3. poweroff"></a>3. poweroff</h3><p>直接运行即可关机，不需要 <code>root</code> 身份。</p><hr><h1 id="Vim-编辑器"><a href="#Vim-编辑器" class="headerlink" title="Vim 编辑器"></a>Vim 编辑器</h1><h1 id="Vim-是什么？"><a href="#Vim-是什么？" class="headerlink" title="Vim 是什么？"></a>Vim 是什么？</h1><p><code>Vim</code> 是从 <code>vi</code> 发展出来的一个文本编辑器。其代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。和 <code>Emacs</code> 并列成为类 <code>Unix</code> 系统用户最喜欢的编辑器。</p><h1 id="Vim-常用模式"><a href="#Vim-常用模式" class="headerlink" title="Vim 常用模式"></a>Vim 常用模式</h1><pre><code>详解：    *   交互模式    *   插入模式    *   命令模式    *   可视模式</code></pre><h3 id="1-交互模式"><a href="#1-交互模式" class="headerlink" title="1. 交互模式"></a>1. 交互模式</h3><p>也成为正常模式，这是 <code>Vim</code> 的默认模式，每次运行 <code>Vim</code> 程序的时候，就会进入这个模式。</p><p>例如执行 <code>vim name.txt</code> 则会进入交互模式。<br>交互模式特征：<br>    *   在这个模式下，你不能输入文本；<br>    *   它可以让我们在文本间移动，删除一行文本，复制黏贴文本，跳转到指定行，撤销操作，等等。</p><h3 id="2-插入模式"><a href="#2-插入模式" class="headerlink" title="2. 插入模式"></a>2. 插入模式</h3><p>这个模式是我们熟悉的文本编辑器的模式，就是可以输入任何你想输入的内容。进入这个模式有几种方法，最常用的方法是按字母键 <code>i</code> （ <code>i</code>、<code>I</code>、<code>a</code>、<code>A</code>、<code>o</code>、<code>O</code> 都可以进入插入模式，只是所处的位置不同），退出这种模式，只需要按下 <code>Esc</code> 键<br>    *   <code>i</code>, <code>I</code> 进入输入模式 <code>Insert mode</code> ：<code>i</code> 为“从目前光标所在处输入”， <code>I</code> 为“在目前所在行的第一个非空格符处开始输入”；<br>    *   <code>a</code>, <code>A</code> 进入输入模式 <code>Insert mode</code> ：<code>a</code> 为“从目前光标所在的下一个字符处开始输入”，<code>A</code> 为“从光标所在行的最后一个字符处开始输入”；<br>    *   <code>o</code>, <code>O</code> 进入输入模式 <code>Insert mode</code> ：<code>o</code> 为“在目前光标所在的下一行处输入新的一行”；<code>O</code> 为在目前光标所在处的上一行输入新的一行。</p><h3 id="3-命令模式"><a href="#3-命令模式" class="headerlink" title="3. 命令模式"></a>3. 命令模式</h3><p>命令模式也称为底线命令模式，这个模式下可以运行一些命令例如“退出”，“保存”，等动作。</p><p>也可以用这个模式来激活一些 <code>Vim</code> 配置，例如语法高亮，显示行号，等。甚至还可以发送一些命令给终端命令行，例如 <code>ls``、cp</code> 。</p><p>为了进入命令模式，首先要进入交互模式，再按下冒号键。</p><p>用一张图表示三种模式如何切换：<br><img src= "/img/loading.gifs" data-src="/images/linux/17.jpeg" alt=""></p><hr><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h3 id="1-打开-Vim"><a href="#1-打开-Vim" class="headerlink" title="1. 打开 Vim"></a>1. 打开 Vim</h3><p>在终端命令行中输入 <code>vim</code> 回车后 <code>Vim</code> 就会被运行起来，也可以用 <code>Vim</code> 来打开一个文件，只需要在 <code>vim</code> 后面再加文件名。如 <code>vim file.name</code> ，如果文件不存在，那么会被创建。</p><h3 id="2-插入"><a href="#2-插入" class="headerlink" title="2. 插入"></a>2. 插入</h3><p>进入文件之后，此时处于交互模式，可以通过输入 <code>i</code> 进入插入模式。</p><h3 id="3-移动"><a href="#3-移动" class="headerlink" title="3. 移动"></a>3. 移动</h3><p>在 <code>Vim</code> 的交互模式下，我们可以在文本中移动光标。<br>    *   <code>h</code> 向左移动一个字符<br>    *   <code>j</code> 向下移动一个字符<br>    *   <code>k</code> 向上移动一个字符<br>    *   <code>i</code> 向右移动一个字符<br>当然也可以使用四个方向键进行移动，效果是一样的。</p><h3 id="4-跳至行首和行末"><a href="#4-跳至行首和行末" class="headerlink" title="4. 跳至行首和行末"></a>4. 跳至行首和行末</h3><p>详解：<br>    *   行首：在交互模式下，为了将光标定位到一行的开始位置，只需要按下数字键 <code>0</code> 即可，键盘上的 <code>Home</code> 键也有相同效果。<br>    *   行末：在交互模式下，为了将光标定位到一行的末尾，只需要按下美元符号键 <code>$</code> 即可，键盘上的 <code>End</code> 键也有相同效果。</p><h3 id="5-按单词移动"><a href="#5-按单词移动" class="headerlink" title="5. 按单词移动"></a>5. 按单词移动</h3><p>在交互模式下，按字母键 <code>w</code> 可以一个单词一个单词的移动。</p><h3 id="6-退出文件"><a href="#6-退出文件" class="headerlink" title="6. 退出文件"></a>6. 退出文件</h3><p>在交互模式下，按下冒号键 <code>:</code> 进入命令模式，再按下 <code>q</code> 键，就可以退出了。</p><p>如果在退出之前又修改了文件，就直接想用 <code>:q</code> 退出 <code>Vim</code> ，那么 <code>Vim</code> 会显示一个红字标明错误信息。此时我们有两个选择：<br>    *   1. 保存并退出 <code>:wq</code> 或 <code>:x</code> ；<br>    *   2. 不保存且退出 <code>:q!</code> 。</p><hr><h1 id="标准操作"><a href="#标准操作" class="headerlink" title="标准操作"></a>标准操作</h1><h3 id="1-删除字符"><a href="#1-删除字符" class="headerlink" title="1. 删除字符"></a>1. 删除字符</h3><p>在交互模式下，将光标定位到一个你想要删除的字符上，按下字母键 <code>x</code> 你会发现这个字符被删除了。</p><p>也可以一次性删除多个字符，只需要在按 <code>x</code> 键之前输入数字即可。</p><h3 id="2-删除（剪切）单词，行"><a href="#2-删除（剪切）单词，行" class="headerlink" title="2. 删除（剪切）单词，行"></a>2. 删除（剪切）单词，行</h3><p>详解：<br>    *   删除一行：连按两次 <code>d</code> 来删除光标所在的那一行。<br>    *   删除多行：例如先输入数字 <code>2</code> ，再按下 <code>dd</code> ，就会删除从光标所在行开始的两行<br>    *   删除一个单词：将光标置于一个单词的首字母处，然后按下 <code>dw</code><br>    *   删除多个单词：例如先按数字键 <code>2</code> 再按 <code>dw</code> 就可以删除两个单词了。<br>    *   从光标所在位置删除至行首：<code>d0</code> 。<br>    *   从光标所在位置删除至行末：<code>d$</code> 。</p><h3 id="3-复制单词，行"><a href="#3-复制单词，行" class="headerlink" title="3. 复制单词，行"></a>3. 复制单词，行</h3><p>详解：<br>    *   复制行：按两次 <code>y</code> 会把光标所在行复制到内存中，和 <code>dd</code> 类似， <code>dd</code> 用于“剪切”光标所在行。<br>    *   复制单词：<code>yw</code> 会复制一个单词。<br>    *   复制到行末：<code>y$</code> 是复制从光标所在处到行末的所有字符。<br>    *   复制到行首：<code>y0</code> 是复制光标所在处到行首的所有字符。</p><h3 id="4-粘贴"><a href="#4-粘贴" class="headerlink" title="4. 粘贴"></a>4. 粘贴</h3><p>如果之前用 <code>dd</code> 或者 <code>yy</code> 剪切复制过来的，可以使用 <code>p</code> 来粘贴。同样也可以使用 <code>数字+p</code> 来表示复制多次。</p><h3 id="5-替换一个字符"><a href="#5-替换一个字符" class="headerlink" title="5. 替换一个字符"></a>5. 替换一个字符</h3><p>在交互模式下，将光标置于想要替换的字符上。按下 r 键，接着输入你要替换的字符即可。</p><h3 id="6-撤销操作"><a href="#6-撤销操作" class="headerlink" title="6. 撤销操作"></a>6. 撤销操作</h3><p>如果要撤销最近的修改，只需要按下 <code>u</code> 键，如果想要撤销最近四次修改，可以按下4，再按下 <code>u</code> 。</p><h3 id="7-重做"><a href="#7-重做" class="headerlink" title="7. 重做"></a>7. 重做</h3><p>取消撤销，也就是重做之前的修改使用 <code>ctrl + r</code> 。</p><h3 id="8-跳转到指定行"><a href="#8-跳转到指定行" class="headerlink" title="8. 跳转到指定行"></a>8. 跳转到指定行</h3><p><code>Vim</code> 编辑的文件中，每一行都有一个行号，行号从1开始，逐一递增。</p><p>行号默认是不显示，如果需要它显示的话，可以进入命令模式，然后输入 <code>set nu</code> ，如果要隐藏行号的话，使用 <code>set nonu</code> 。<br>    *   跳转到指定行：<code>数字+gg</code> ，例如 <code>7gg</code> ，表示跳转到第7行。<br>    *   要跳转到最后一行，按下 <code>G</code> 。<br>    *   要跳转到第一行，按下 <code>gg</code> 。</p><hr><h1 id="高级操作"><a href="#高级操作" class="headerlink" title="高级操作"></a>高级操作</h1><h3 id="1-查找"><a href="#1-查找" class="headerlink" title="1. 查找"></a>1. 查找</h3><p>处于交互模式下，按下 <code>/</code> 键，那么就进入查找模式，输入你要查找的字符串，然后按下回车。光标就会跳转到文件中下一个查找到的匹配处。如果字符串不存在，那么会显示 <code>&quot;pattern not found&quot;</code> 。<br>    *   <code>n</code> 跳转到下一个匹配项；<br>    *   <code>N</code> 跳转到上一个匹配项。<br><code>[注意]</code> 用斜杠来进行的查找是从当前光标处开始向文件尾搜索，如果你要从当前光标处开始，向文件头搜索则使用 <code>?</code> ，当然也可以先按下 <code>gg</code> 跳转到第一行在进行全文搜索。</p><h3 id="2-查找并替换"><a href="#2-查找并替换" class="headerlink" title="2. 查找并替换"></a>2. 查找并替换</h3><p>替换光标所在行第一个匹配的字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 语法:s&#x2F;旧字符串&#x2F;新字符串# 实例:s&#x2F;one&#x2F;two</span><br></pre></td></tr></table></figure><p>替换光标所在行所有旧字符串为新字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 语法:s&#x2F;旧字符串&#x2F;新字符串&#x2F;g</span><br></pre></td></tr></table></figure><p>替换第几行到第几行中所有字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 语法:n,m s&#x2F;旧字符串&#x2F;新字符串&#x2F;g# 实例:2,4 s&#x2F;one&#x2F;two&#x2F;g</span><br></pre></td></tr></table></figure><p>最常用的就是全文替换了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 语法:%s&#x2F;旧字符串&#x2F;新字符串&#x2F;g</span><br></pre></td></tr></table></figure><h3 id="3-合并文件"><a href="#3-合并文件" class="headerlink" title="3. 合并文件"></a>3. 合并文件</h3><p>可以用冒号 <code>+r ( :r )</code> 实现在光标处插入一个文件的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:r filename # 可以用Tab键来自动补全另外一个文件的路径</span><br></pre></td></tr></table></figure><h3 id="4-分屏"><a href="#4-分屏" class="headerlink" title="4. 分屏"></a>4. 分屏</h3><p><code>Vim</code> 有一个特别便捷的功能那就是分屏，可以同时打开好几个文件，分屏之后，屏幕每一块被称为一个 <code>viewport</code> ，表示“视口”。<br>    *   横向分屏 <code>:sp 文件名</code><br>    *   垂直分屏 <code>:vsp 文件名</code></p><p>分屏模式下的快捷键：<br>    *   <code>Ctrl + w</code> 再加 <code>Ctrl + w</code> ，表示从一个 <code>viewport</code> 移动光标到另外一个 <code>viewport</code> ；<br>    *   <code>Ctrl + w</code> 再加 “方向键”，就可以移动到这个方向所处的下一个视口了；<br>    *   <code>Ctrl + w</code> 再加 <code>+</code> 号，表示扩大当前视口；<br>    *   <code>Ctrl + w</code> 再加 <code>-</code> 号，表示缩小当前视口；<br>    *   <code>Ctrl + w</code> 再加 <code>=</code> 号，表示平均当前视口；<br>    *   <code>Ctrl + w</code> 再加 <code>r</code> 键，会反向调换视口位置；<br>    *   <code>Ctrl + w</code> 再加 <code>q</code> 键，会关闭当前视口；<br>    *   <code>Ctrl + w</code> 再加 <code>o</code> 键，会关闭除当前视口以外的所有视口；</p><h3 id="5-运行外部命令"><a href="#5-运行外部命令" class="headerlink" title="5. 运行外部命令 :!"></a>5. 运行外部命令 :!</h3><p>在 <code>Vim</code> 中可以运行一些终端命令，只要先输入 <code>:!</code> ，然后接命令名称。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:!ls # 在Vim中打开的文件所在的目录运行ls命令</span><br></pre></td></tr></table></figure><h3 id="6-可视模式"><a href="#6-可视模式" class="headerlink" title="6. 可视模式"></a>6. 可视模式</h3><p>前面只讲了 <code>Vim</code> 的三种模式，其实还有一种模式叫做可视模式。</p><p>进入它的三种方式（都是从交互模式开始）：<br>    *   <code>v</code> 字符可视模式，进入后配合方向键选中字符后，然后再按 <code>d</code> 键可以删除选中。<br>    *   <code>V</code> 行可视模式，进入后光标所在行默认被选中，然后再按 <code>d</code> 键可以删除所在行。<br>    *   <code>Ctrl + v</code> 块可视模式，它是可视模式最有用的功能了，配合 <code>d</code> 和 <code>I</code> 键可以实现删除选中的内容和插入内容。<br>同时选中多行，并在选中行头部插入内容的具体操作步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. ctrl + v 进入块可视模式</span><br><span class="line">2. 使用方向键进行选中（上下左右）假设选中5行</span><br><span class="line">3. 输入 I 键进行多行同时插入操作</span><br><span class="line">4. 插入完成后连续按两下 esc 键，实现多行同时插入相同字符</span><br></pre></td></tr></table></figure><p>进入可视模式之后的操作键：<br>    *   <code>d</code> 键，表示删除选中；<br>    *   <code>I</code> 键，表示在选中之前插入；<br>    *   <code>u</code> 键，表示选中变为小写；<br>    *   <code>U</code> 键，表示选中变为大写；</p><hr><h1 id="Vim-配置"><a href="#Vim-配置" class="headerlink" title="Vim 配置"></a>Vim 配置</h1><h3 id="1-选项参数"><a href="#1-选项参数" class="headerlink" title="1. 选项参数"></a>1. 选项参数</h3><p>在 <code>Vim</code> 被启动后，可以运行一些指令来激活一些选项参数，但是这些选项参数的配置在退出<code>Vim</code> 时会被忘记，例如前面讲解的激活行号。如果希望所在的配置是永久性的，那么需要在家目录（ <code>cd ~</code>）创建一个 <code>Vim</code> 的配置文件 <code>.vimrc</code> 。</p><h3 id="2-vimrc"><a href="#2-vimrc" class="headerlink" title="2. .vimrc"></a>2. .vimrc</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set number &quot; 显示行号</span><br><span class="line">syntax on &quot; 激活语法高亮</span><br><span class="line">set showcmd &quot; 实时看到输入的命令</span><br><span class="line">set ignorecase &quot; 搜索时不区分大小写</span><br><span class="line">set mouse&#x3D;a &quot; 激活鼠标，用鼠标选中时相当于进入可视模式</span><br></pre></td></tr></table></figure><p><code>Vim</code> 配置非常丰富，我们可以通过个性化配置把 <code>Vim</code> 打造成属于自己的 <code>IDE</code> 等等。在 <code>github</code> 上也可以搜索到一些强大的 <code>Vim</code> 配置文件。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>相信通过本文的学习，你应该会对 <code>Linux</code> 有一个更加全面的认识。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql学习 —— 子查询(where、from、exists) 及 连接查询(left join、right join、inner join、union join)</title>
      <link href="/2022/02/09/mysql/%E5%85%A5%E9%97%A8-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
      <url>/2022/02/09/mysql/%E5%85%A5%E9%97%A8-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li>子查询<ul><li>1、where型子查询：把内层查询的结果作为外层查询的比较条件</li><li>2、from型子查询：把内层的查询结果当成临时表，供外层sql再次查询。查询结果集可以当成表看待。临时表要使用一个别名</li><li>3、exists型子查询：把外层sql的结果，拿到内层sql去测试，如果内层的sql成立，则该行取出。内层查询是exists后的查询</li><li>4、any，in子查询</li><li>5、子查询总结</li></ul></li><li>连接查询<ul><li>1、全相乘（不是全连接、连接查询），全相乘是做笛卡尔积</li><li>2、左连接查询 left join … on …</li><li>3、右连接查询 right join … on …</li><li>4、内连接 inner join … on …</li><li>5、全连接 full join … on …</li><li>6、联合查询 union</li><li>7、连接查询总结</li></ul></li></ul><hr><p><code>注：该mysql系列博客仅为个人学习笔记。</code></p><p>使用goods表来练习子查询，表结构如下：<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/1.png" alt=""></p><p>所有数据(cat_id与category.cat_id关联)：<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/2.png" alt=""></p><p>类别表：<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/3.png" alt=""></p><p>mingoods(连接查询时作测试)：<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/4.png" alt=""></p><hr><h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><h3 id="1、where型子查询：把内层查询的结果作为外层查询的比较条件"><a href="#1、where型子查询：把内层查询的结果作为外层查询的比较条件" class="headerlink" title="1、where型子查询：把内层查询的结果作为外层查询的比较条件"></a>1、<code>where型子查询：把内层查询的结果作为外层查询的比较条件</code></h3><p>1.1 查询id最大的一件商品（使用排序+分页实现）<br>    mysql&gt; SELECT goods_id,goods_name,shop_price FROM goods ORDER BY goods_id DESC LIMIT 1;<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/5.png" alt=""></p><p>1.2 查询id最大的一件商品（使用where子查询实现）<br>    mysql&gt; SELECT goods_id,goods_name,shop_price FROM goods WHERE goods_id = (SELECT MAX(goods_id) FROM goods);<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/6.png" alt=""></p><p>1.3 查询每个类别下id最大的商品（使用where子查询实现）<br>    mysql&gt; SELECT goods_id,goods_name,cat_id,shop_price FROM goods WHERE goods_id IN (SELECT MAX(goods_id) FROM goods GROUP BY cat_id);<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/7.png" alt=""></p><h3 id="2、from型子查询：把内层的查询结果当成临时表，供外层sql再次查询。查询结果集可以当成表看待。临时表要使用一个别名。"><a href="#2、from型子查询：把内层的查询结果当成临时表，供外层sql再次查询。查询结果集可以当成表看待。临时表要使用一个别名。" class="headerlink" title="2、from型子查询：把内层的查询结果当成临时表，供外层sql再次查询。查询结果集可以当成表看待。临时表要使用一个别名。"></a>2、<code>from型子查询：把内层的查询结果当成临时表，供外层sql再次查询。查询结果集可以当成表看待。临时表要使用一个别名。</code></h3><p>2.1 查询每个类别下id最大的商品（使用from型子查询）<br>    mysql&gt; SELECT goods_id,goods_name,cat_id,shop_price FROM (SELECT goods_id,goods_name,cat_id,shop_price FROM goods ORDER BY cat_id ASC,goods_id DESC) AS tmp GROUP BY cat_id;<br>    子查询查出的结果集看第二张图，可以看到每个类别的第一条商品的id都为该类别下的最大值。然后将这个结果集作为一张临时表，巧妙的使用group by 查询出每个类别下的第一条记录，即为每个类别下商品id最大。<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/8.png" alt=""><br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/9.png" alt=""></p><h3 id="3、exists型子查询：把外层sql的结果，拿到内层sql去测试，如果内层的sql成立，则该行取出。内层查询是exists后的查询。"><a href="#3、exists型子查询：把外层sql的结果，拿到内层sql去测试，如果内层的sql成立，则该行取出。内层查询是exists后的查询。" class="headerlink" title="3、exists型子查询：把外层sql的结果，拿到内层sql去测试，如果内层的sql成立，则该行取出。内层查询是exists后的查询。"></a>3、<code>exists型子查询：把外层sql的结果，拿到内层sql去测试，如果内层的sql成立，则该行取出。内层查询是exists后的查询。</code></h3><p>3.1 从类别表中取出其类别下有商品的类别（如果改类别下没有商品，则不取出），（使用where子查询）<br>    mysql&gt; SELECT c.cat_id,c.cat_name FROM category c WHERE c.cat_id IN (SELECT g.cat_id FROM goods g GROUP BY g.cat_id);<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/10.png" alt=""></p><p>3.2 从类别表中取出其类别下有商品的类别（如果该类别下没有商品，则不取出），（使用exists子查询）<br>    mysql&gt; SELECT c.cat_id,c.cat_name FROM category c WHERE EXISTS (SELECT 1 FROM goods g WHERE g.cat_id = c.cat_id);<br>    exists子查询，如果exists后的内层查询能查询出数据，则表示存在；为空则不存在。<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/11.png" alt=""></p><h3 id="4、-any，in-子查询"><a href="#4、-any，in-子查询" class="headerlink" title="4、 any，in 子查询"></a>4、 <code>any，in 子查询</code></h3><p><code>用一张数字表作为子查询</code><br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/12.png" alt=""></p><p>4.1 使用 any 查出类别大于任何一个num值的类别。<br>    ANY关键词必须后面接一个比较操作符。ANY关键词的意思是“对于在子查询返回的列中的任一数值，如果比较结果为TRUE的话，则返回TRUE”。<br>    mysql&gt; SELECT cat_id,cat_name FROM category WHERE cat_id &gt; ANY (SELECT num FROM nums);<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/13.png" alt=""></p><p>4.2 使用 in 查出cat_id 等于 num 的类别<br>    mysql&gt; SELECT cat_id,cat_name FROM category WHERE cat_id IN (SELECT num FROM nums);<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/14.png" alt=""></p><p>4.3 in 的效果跟 =any 的效果是一样的<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/15.png" alt=""></p><p>4.4 使用 all 查询<br>    词语ALL必须接在一个比较操作符的后面。ALL的意思是“对于子查询返回的列中的所有值，如果比较结果为TRUE，则返回TRUE。”<br>    mysql&gt; SELECT cat_id,cat_name FROM category WHERE cat_id &gt; ALL (SELECT num FROM nums);<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/16.png" alt=""></p><p>4.5 not in 和 &lt;&gt; any 的效果是一样的<br>    NOT IN 不是 &lt;&gt; ANY 的别名，但是是<code>&lt;&gt; ALL的别名</code><br>    mysql&gt; SELECT cat_id,cat_name FROM category WHERE cat_id NOT IN (SELECT num FROM nums);<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/17.png" alt=""></p><h3 id="5、子查询总结"><a href="#5、子查询总结" class="headerlink" title="5、子查询总结"></a>5、<code>子查询总结</code></h3><p>5.1 where型子查询：把内层查询的结果作为外层查询的比较条件。<br>5.2 from型子查询：把内层的查询结果当成临时表，供外层sql再次查询。查询结果集可以当成表看待，<code>临时表需要一个别名</code>。<br>5.3  exists型子查询：把外层sql的结果，拿到内层sql去测试，如果内层的sql成立，则该行取出。内层sql是exists后的查询。<br>5.4 子查询也可以嵌套在其它子查询中，嵌套程度可以很深。<code>子查询必须要位于圆括号中</code>。<br>5.5 <code>子查询的主要优势</code>为:<br>    5.5.1 子查询允许结构化的查询，这样就可以把一个语句的每个部分隔离开。<br>    5.5.2 有些操作需要复杂的联合和关联。子查询提供了其它的方法来执行这些操作。<br>5.6 <code>ANY关键词必须后面接一个比较操作符</code>。ANY关键词的意思是“对于在子查询返回的列中的<code>任一数值</code>，如果比较结果为TRUE的话，则返回TRUE”。 词语 IN 是 ＝ANY 的别名，二者效果相同。NOT IN不是  &lt;&gt; ANY  的别名，但是是  &lt;&gt; ALL  的别名。<br>5.7 词语ALL必须接在一个比较操作符的后面。ALL的意思是“对于子查询返回的列中的<code>所有值</code>，如果比较结果为TRUE，则返回TRUE。”<br>5.8 <code>优化子查询</code>有些子句会影响在子查询中的行的数量和顺序，通过加一些限制条件来限制子查询查出来的条数。例如：<br>    5.8.1 SELECT * FROM t1 WHERE t1.column1 IN (SELECT column1 FROM t2 ORDER BY column1);<br>    5.8.2 SELECT * FROM t1 WHERE t1.column1 IN (SELECT DISTINCT column1 FROM t2);<br>    5.8.3 SELECT * FROM t1 WHERE EXISTS (SELECT * FROM t2 LIMIT 1);<br>    5.8.4 用子查询替换联合，例如：<br>        5.8.4.1 SELECT DISTINCT column1 FROM t1 WHERE t1.column1 IN (SELECT column1 FROM t2);<br>            <code>代替这个：</code> SELECT DISTINCT t1.column1 FROM t1, t2 WHERE t1.column1 = t2.column1;</p><h1 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h1><p>学习链接查询，先了解“笛卡尔积”，看下百度给出的解释：<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/18.png" alt=""><br><code>在数据库中，一张表就是一个集合，每一行就是集合中的一个元素</code>。表之间作联合查询既是作笛卡尔乘积，比如A表有5条数据，B表有8条数据，如果不做条件筛选，那么两表查询就有<code>5 x 8 = 40</code> 条数据。</p><p>先看下用到的测试表基本信息：我们要实现的功能就是查询商品的时候，从类别表将商品类别名称关联查询出来。<br>    行数：类别表14条，商品表4条<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/19.png" alt=""></p><pre><code>结构：商品表和类别表都有一个cat_id</code></pre><p><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/20.png" alt=""></p><pre><code>小类别表（左右连接时做对比）</code></pre><p><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/21.png" alt=""></p><h3 id="1、全相乘（不是全连接、连接查询），全相乘是作笛卡尔积"><a href="#1、全相乘（不是全连接、连接查询），全相乘是作笛卡尔积" class="headerlink" title="1、全相乘（不是全连接、连接查询），全相乘是作笛卡尔积"></a>1、<code>全相乘</code>（不是全连接、连接查询），全相乘是作笛卡尔积</h3><p>两表全相乘，就是直接从两张表里查询；从查询的截图看出，总共查出了 <code>4 x 14 = 56</code> 条记录，这些记录是笛卡尔乘积的结果，既是两两组合；<br>但是我们要的是每个商品的信息显示类别名称而已，这里却查出了56条记录，其中52条记录都是无限的数据，<code>全相乘的查询效率低</code>。<br>    mysql&gt; SELECT g,goods_name,g.cat_id, c.cat_id,c.cat_name FROM mingoods g, category c;<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/22.png" alt=""><br>    如果在两张表里有相同字段，做联合查询的时候，要区别表明，否则会报错（模糊不清）<br>    mysql&gt; SELECT goods_name,cat_id,cat_name FROM <code>mingoods,category</code>;<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/23.png" alt=""><br>    添加条件，使两表关联查询，这样查出来就是商品和类别一一对应了。虽然这里查询来4条记录，但是<code>全相乘效率低，全相乘会在内存中生成一个非常大的数据（临时表），因为有很多不必要的数据</code>。<br>    <code>如果一张表有10000条数据，另一张表有10000条数据，两表全相乘就是100W条数据，是非常消耗内存的</code>。而且，全相乘不能好好的利用索引，因为全相乘生成一张临时表，临时表是没有索引的，大大降低了查询效率。<br>    mysql&gt; SELECT g.goods_name,g.cat_id AS g_cat_id, c.cat_id AS c_cat_id, c.cat_name FROM mingoods g, category c WHERE g.cat_id = c.cat_id;<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/24.png" alt=""></p><h3 id="2、左连接查询-left-join-on"><a href="#2、左连接查询-left-join-on" class="headerlink" title="2、左连接查询 left join ... on ..."></a>2、<code>左连接查询 left join ... on ...</code></h3><p>语法：select A.filed, [A.filed2, …. ,] B.filed, [B.filed4…,] from <left table> as A  <code>left join</code> <right table> as B <code>on</code> <expression><br>假设有A、B两张表，左连接查询即 A表在左不动，B表在右滑动，A表与B表通过一个关系来关联行，B表去匹配A表。</p><p>2.1 先来看看on后的条件恒为真的情况<br>    mysql&gt; SELECT g.goods_name,g.cat_id, c.cat_id ,c.cat_name FROM mingoods g LEFT JOIN category c ON 1;<br>    跟全相乘相比，从截图可以看出，总记录数仍然不变，还是 <code>4 x 14 = 56</code> 条记录。但是这次是商品表不动，类别表去匹配，因为每次都为真，所以将所有的记录都查出来了。<code>左连接，其实就可以看成左表是主表，右表是从表</code>。<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/25.png" alt=""></p><p>2.2 根据cat_id使两表关联行<br>    mysql&gt; SELECT g.goods_name,g.cat_id,c.cat_id,c.cat_name <code>FROM mingoods g LEFT JOIN category c ON g.cat_id = c.cat_id</code>;<br>    使用左连接查询达到了同样的效果，但是不会有其他冗余数据，<code>查询速度快，消耗内存小，而且使用了索引。左连接查询效率相比于全相乘的效率快了10+倍以上</code>。<br>    左连接时，mingoods表（左表）不动，category表（右表）根据条件去一条条匹配，虽说category表也是读取一行行记录，然后判断cat_id是否跟mingoods表的相同，但是，左连接使用了索引，cat_id建立了索引的话，查询速度非常快，所以整体效率相比于全相乘要快得多，全相乘没有使用索引。<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/26.png" alt=""></p><p>2.3 查询出第四个类别下的商品，要求显示商品名称<br>    mysql&gt; SELECT g.goods_name,g.cat_id,c.cat_name,g.shop_price FROM goods g LEFT JOIN category c ON g.cat_id = c.cat_id WHERE g.cat_id = 4;<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/27.png" alt=""></p><p>2.4 对于左连接查询，如果右表中没有满足条件的行，则默认填充NULL<br>    mysql&gt; SELECT g.goods_name,g.cat_id AS g_cat_id, c.cat_id AS c_cat_id,c.cat_id FROM mingoods g LEFT JOIN mincategory c ON g.cat_id = c.cat_id;<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/28.png" alt=""></p><h3 id="3、右连接查询-right-join-on"><a href="#3、右连接查询-right-join-on" class="headerlink" title="3、右连接查询 right join ... on ..."></a>3、<code>右连接查询 right join ... on ...</code></h3><p>语法：select A.field1,A.field2,…, B.field3,B.field4  from <left table> A <code>right join</code> <right table> B <code>on</code> <expression><br>右连接查询跟左连接查询类似，只是右连接是以右表为主表，会将右表所有数据查询出来，而左表则根据条件去匹配，如果左表没有满足条件的行，则左边默认显示NULL。左右连接是可以互换的。<br>    mysql&gt; SELECT g.goods_name,g.cat_id AS g_cat_id,  c.cat_id AS c_cat_id,c.cat_name FROM mingoods g RIGHT JOIN mincategory c ON g.cat_id = c.cat_id;<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/29.png" alt=""></p><h3 id="4、内连接-inner-join-on"><a href="#4、内连接-inner-join-on" class="headerlink" title="4、内连接 inner join ... on ..."></a>4、<code>内连接 inner join ... on ...</code></h3><p>语法：select A.field1,A.field2,.., B.field3, B.field4 from <left table> A <code>inner join</code> <right table> B <code>on</code> <expression><br>内连接查询，就是取左连接和右连接的交集，如果两边不能匹配条件，则都不取出。<br>    mysql&gt; SELECT g.goods_name,g.cat_id, c.* from mingoods g INNER JOIN mincategory c ON g.cat_id = c.cat_id;<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/30.png" alt=""></p><h3 id="5、全连接-full-join-on"><a href="#5、全连接-full-join-on" class="headerlink" title="5、全连接 full join ... on ..."></a>5、<code>全连接 full join ... on ...</code></h3><p>语法：select … from <left table> <code>full join</code> <right table> <code>on</code> <expression><br>全连接会将两个表的所有数据查询出来，不满足条件的为NULL。<br>全连接查询跟全相乘查询的区别在于，如果某个项不匹配，全相乘不会查出来，全连接会查出来，而连接的另一边则为NULL。</p><h3 id="6、联合查询-union"><a href="#6、联合查询-union" class="headerlink" title="6、联合查询 union"></a>6、<code>联合查询 union</code></h3><p>语法：select A.field1 as f1, A.field2 as f2 from <table1> A <code>union</code> (select B.field3 as f1, field4 as f2 from <table2> B)<br>union是求两个查询的并集。union合并的是结果集，不区分来自于哪一张表，所以可以合并多张表查询出来的数据。<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/31.png" alt=""></p><p>6.1 将两张表的数据合并查询出来<br>    mysql&gt; SELECT id, content, user FROM comment UNION (SELECT id, msg AS content, user FROM feedback);<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/32.png" alt=""></p><p>6.2 union查询，列名不一致时，以第一条sql语句的列名对齐<br>    mysql&gt; SELECT id, content, user FROM comment UNION (SELECT id, msg, user FROM feedback);<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/33.png" alt=""></p><p>6.3 使用union查询会将重复的行过滤掉<br>    mysql&gt; SELECT content,user FROM comment UNION (SELECT msg, user FROM feedback);<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/34.png" alt=""></p><p>6.4 使用union all查询所有，重复的行不会被过滤<br>    mysql&gt; SELECT content,user FROM comment UNION ALL (SELECT msg, user FROM feedback);<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/35.png" alt=""></p><p>6.5 union查询，如果列数不相等，会报列数不相等错误<br>    mysql&gt; SELECT content,user FROM comment UNION (SELECT msg, user FROM feedback);<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/36.png" alt=""></p><p>6.6 union 后的结果集还可以再做筛选<br>    mysql&gt; SELECT id,content,user FROM comment UNION ALL (SELECT id, msg, user FROM feedback) ORDER BY id DESC;<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/37.png" alt=""></p><p><code>union查询时，order by放在内层sql中是不起作用的；因为union查出来的结果集再排序，内层的排序就没有意义了；因此，内层的order by排序，在执行期间，被mysql的代码分析器给优化掉了。</code><br>    mysql&gt; (SELECT id,content,user FROM comment ORDER BY id DESC) UNION ALL (SELECT id, msg, user FROM feedback ORDER BY id DESC);<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/38.png" alt=""></p><p><code>order by 如果和limit一起使用，就显得有意义了，就不会被优化掉</code><br>    mysql&gt; ( SELECT goods_name,cat_id,shop_price FROM goods WHERE cat_id = 3 ORDER BY shop_price DESC LIMIT 3 ) UNION ( SELECT goods_name,cat_id,shop_price FROM goods WHERE cat_id = 4 ORDER BY shop_price DESC LIMIT 2 );<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/39.png" alt=""></p><p>6.7 练习<br>    mysql&gt; SELECT name, SUM(money) FROM ( ( SELECT * FROM A ) UNION ALL ( SELECT * FROM B ) ) tmp GROUP BY name;<br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/40.png" alt=""><br><img src= "/img/loading.gifs" data-src="/images/mysql/mysql_learn/41.png" alt=""></p><h3 id="7、连接查询总结"><a href="#7、连接查询总结" class="headerlink" title="7、连接查询总结"></a>7、连接查询总结</h3><ol><li><p><code>在数据库中，一张表就是一个集合，每一行就是集合中的一个元素</code>。连接查询即是作笛卡尔积，比如A表有1W条数据，B表有1W条数据，那么两表查询就有 1W X 1W = 100W 条数据</p></li><li><p><code>如果在两张表里有相同字段，做联合查询的时候，要区别表名</code>，否则会报错误(ambiguous 模糊不清)</p></li><li><p><code>全相乘效率低，全相乘会在内存中生成一个非常大的数据(临时表)，因为有很多不必要的数据</code>。如果一张表有10000条数据，另一张表有10000条数据，两表全相乘就是100W条数据，是非常消耗内存的。而且，<code>全相乘不能好好的利用索引，因为全相乘生成一张临时表，临时表里是没有索引的，大大降低了查询效率</code>。</p></li><li><p>左连接查询时，以左表为主表，会将左表所有数据查询出来；左表不动，右表根据条件去一条条匹配，如果没有满足条件的记录，则右边返回NULL。右连接查询时，以右表为主表，会将右表所有数据查询出来，右表不动，左表则根据条件去匹配，如果左表没有满足条件的行，则左边返回NULL。左右连接是可以互换的：A left join B  ==  B right join A (都是以A为主表) 。<code>左右连接既然可以互换，出于移植兼容性方面的考虑，尽量使用左连接</code>。</p></li><li><p>连接查询时，虽说也是读取一行行记录，然后判断是否满足条件，但是，<code>连接查询使用了索引，条件列建立了索引的话，查询速度非常快，所以整体效率相比于全相乘要快得多，全相乘是没有使用索引的</code>。使用连接查询，查询速度快，消耗内存小，而且使用了索引。连接查询效率相比于全相乘的查询效率快了10+倍以上。</p></li><li><p>内连接查询，就是取左连接和右连接的<code>交集</code>，如果两边不能匹配条件，则都不取出。</p></li><li><p>MySql可以用union(联合查询)来查出左连接和右连接的<code>并集</code>。<br><code>union查询会过滤重复的行，union all 不会过滤重复的行</code>。<code>union查询时，union之间的sql列数必须相等，列名以第一条sql的列为准</code>；列类型可以不一样，但没太大意义。<code>union查询时，order by放在内层sql中是不起作用的；因为union查出来的结果集再排序，内层的排序就没有意义了；因此，内层的order by排序，在执行期间，被mysql的代码分析器给优化掉了</code>。但是，<code>order by 如果和limit一起使用</code>，就显得有意义了，会影响最终结果集，就不会被优化掉。order by会根据最终是否会影响结果集而选择性的优化。</p></li><li><p>LEFT JOIN 是 LEFT OUTER JOIN 的缩写，同理，RIGHT JOIN 是 RIGHT OUTER JOIN 的缩写；JOIN 是 INNER JOIN 的缩写。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx详解</title>
      <link href="/2021/06/21/nginx/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%90%9E%E5%AE%9Anginx%E9%85%8D%E7%BD%AE/"/>
      <url>/2021/06/21/nginx/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%90%9E%E5%AE%9Anginx%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li>安装nginx</li><li>nginx配置<ul><li>基本结构</li><li>主要配置含义</li><li>nginx.conf配置文件的语法规则</li><li>内置变量</li><li>常用命令</li><li>配置nginx开机自启</li><li>配置nginx全局可用</li></ul></li><li>nginx常用功能配置<ul><li>反向代理</li><li>访问控制</li><li>6种负载均衡策略</li><li>gzip压缩</li><li>HTTP服务器</li><li>动静分离</li><li>请求限制</li><li>正向代理</li><li>图片防盗链</li><li>适配PC或移动设备</li><li>设置耳机域名</li><li>配置HTTPS</li><li>配置HTTP转HTTPS</li><li>单页面项目history路由配置</li><li>配置最高可用集群（双机热备）</li></ul></li><li>其它功能和技巧配置<ul><li>代理缓存</li><li>访问日志</li><li>错误日志</li><li>静态资源服务器</li><li>禁止指定user_agent</li><li>请求过滤</li><li>ab命令</li><li>泛域名路径分离</li><li>泛域名转发</li></ul></li><li>附nginx模块<ul><li>nginx模块分类</li><li>模块清单</li></ul></li></ul><hr><h1 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h1><p>下载nginx的压缩包文件到根目录，官网下载地址：nginx.org/download/nginx-x.xx.xx.tar.gz<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum update  # 更新系统软件</span><br><span class="line">cd &#x2F;</span><br><span class="line">wget nginx.org&#x2F;download&#x2F;nginx-1.22.2.tar.gz</span><br></pre></td></tr></table></figure><br>解压tar.gz压缩包文件，进去nginx-1.22.2<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf nginx-1.22.2.tar.gz</span><br><span class="line">cd nginx-1.22.2</span><br></pre></td></tr></table></figure><br>进入文件夹后进行配置检查<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure</span><br></pre></td></tr></table></figure><br>通过安装前的配置检查，发现有报错，检查中发现一些依赖库没有找到，这时候需要先安装nginx的一些依赖库<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum -y install pcre  # 安装nginx支持rewrite</span><br><span class="line">yum -y install gcc-c++</span><br><span class="line">yum -y install zlib*</span><br><span class="line">yum -y install openssl openssl-devel</span><br></pre></td></tr></table></figure><br>再次进行检查操作./configure 没有发现报错显示，接下来进行编译并安装的操作<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure</span><br></pre></td></tr></table></figure><br>这里需要特别注意下，以后需要用到的功能模块是否存在，不然以后添加新的包会比较麻烦。<br>查看默认安装的模块支持<br>命令 <code>ls nginx-1.22.2</code> 查看nginx的文件列表，可以发现里面又一个auto的目录<br>在这个auto的目录种又一个options文件，这个文件里面保存的就是nginx编译过程种的所有选项配置<br>用过命令： <code>cat nginx-1.22.2/auto/options | grep YES</code> 就可以查看<br><a href="https://jingyan.baidu.com/article/454316ab354edcf7a7c03a81.html" target="_blank" rel="noopener">nginx编译安装时，怎么查看安装模块</a></p><p>编译安装<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><br>这里需要注意，模块的支持跟后续的nginx配置有关，比如SSL，gzip压缩等等，编译安装前最好检查需要配置的模块存不存在。<br>查看nginx安装后的目录，可以看到已经安装到 <code>/usr/local/nginx</code> 目录了<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">whereis nginx</span><br><span class="line">$nginx: &#x2F;usr&#x2F;local&#x2F;nginx</span><br></pre></td></tr></table></figure><br>启动nginx服务<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin</span><br><span class="line">.&#x2F;nginx</span><br></pre></td></tr></table></figure><br>服务启动的时候报错了： <code>nginx : [emerg] bind() to 0.0.0.0:80 filed (98: Address alredy in use)</code> 通过命令查看本机网络地址和端口等一些信息，<br>找到被占用的80端口 <code>netstat -ntpl</code> 的tcp连接，并杀死进程（kill 进程 pid）<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -ntpl</span><br><span class="line">kill 进程PID</span><br></pre></td></tr></table></figure><br>继续启动 nginx 服务，启动成功<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nginx</span><br></pre></td></tr></table></figure></p><hr><h1 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h1><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main        # 全局配置，对全局生效</span><br><span class="line">|-- events  # 配置影响 nginx 服务器与用户的网络连接</span><br><span class="line">|-- http    # 配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置</span><br><span class="line">|   |-- upstream        # 配置后端服务器具体地址，负载均衡配置不可或缺的部分</span><br><span class="line">|   |-- server          # 配置虚拟主机的相关参数，一个http块中可以有多个server块</span><br><span class="line">|   |-- server</span><br><span class="line">|   |   |-- location    # server块可以包含多个location块，location指令用于匹配uri</span><br><span class="line">|   |   |-- location</span><br><span class="line">|   |   |-- ...</span><br><span class="line">|   |-- ...</span><br><span class="line">|-- ...</span><br></pre></td></tr></table></figure><h3 id="主要配置含义"><a href="#主要配置含义" class="headerlink" title="主要配置含义"></a>主要配置含义</h3><pre><code>&gt;   main:nginx： 的全局配置，对全局生效；&gt;   events： 配置影响nginx服务器或与用户的网络连接；&gt;   http： 可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模版的配置；&gt;   server： 配置虚拟主机的相关参数，一个http中可以有多个server；&gt;   location： 配置请求的路由，以及各种页面的处理情况；&gt;   upstream： 配置后端服务器具体地址，负载均衡配置不可或缺的部分；</code></pre><h3 id="nginx-conf-配置文件的语法规则"><a href="#nginx-conf-配置文件的语法规则" class="headerlink" title="nginx.conf 配置文件的语法规则"></a>nginx.conf 配置文件的语法规则</h3><pre><code>&gt;   配置文件由指令与指令块构成；&gt;   每条指令以 “;“ 分号结尾，指令与参数间以空格符号分隔；&gt;   指令块以 {} 大括号将多条指令组织在一起；&gt;   include 语句允许组合多个配置文件以提升可维护性；&gt;   通过 # 符号添加注释，提高可读性；&gt;   通过 $ 符号使用变量；&gt;   部分指令的参数支持正则表达式，例如常用的 location 指令；</code></pre><h3 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h3><pre><code>|       TCP         |       UDP      | |       ----        |      ----        ||     $host      |   请求信息中的Host，如果请求中没有Host行，则等于设置的服务器名        ||     $request_method      |     客户端请求类型，如 GET、POST      ||     $remote_addr      |   客户端的 ip 地址        ||     $args      |   请求中的参数        ||     $content_length      |   请求头中的 Content-length 字段        ||     $http_user_agent      |   客户端 agent 信息        ||     $http_cookie      |    客户端 cookie 信息       ||     $remote_port      |    客户端的端口       ||     $server_protocol      |  请求使用的协议，如 HTTP/1.1         ||     $server_addr      |   服务器地址        ||     $server_name      |   服务器名称        ||     $server_port      |   服务器的端口号        |</code></pre><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>这里列举几个常用的命令<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload  # 向主进程发送信号，重新加载配置文件，热重启</span><br><span class="line">nginx -s reopen  # 重启nginx</span><br><span class="line">nginx -s stop  # 快速关闭</span><br><span class="line">nginx -s quit  # 等待工作进程处理完成后关闭</span><br><span class="line">nginx -T  # 查看当前 nginx 最终的配置</span><br><span class="line">nginx -t -c &lt;配置路径&gt;  # 检查配置是否由问题，如果预警在配置目录，则不需要 -c</span><br></pre></td></tr></table></figure><br>以上命令通过 <code>nginx -h</code> 就可以查看到，还有其它不常用的这里不在列出。</p><p>Linux 系统应用管理工具 systemd 关于 nginx 的常用命令：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx  # 启动 nginx</span><br><span class="line">systemctl stop nginx   # 停止 nginx</span><br><span class="line">systemctl restart nginx  # 重启 nginx</span><br><span class="line">systemctl reload nginx  # 重新加载 nginx，用于修改配置后</span><br><span class="line">systemctl enable nginx  # 设置开机启动 nginx</span><br><span class="line">systemctl disable nginx  # 关闭开启启动 nginx</span><br><span class="line">systemctl status nginx  # 查看 nginx 运行状态</span><br></pre></td></tr></table></figure></p><h3 id="配置-nginx-开启自启"><a href="#配置-nginx-开启自启" class="headerlink" title="配置 nginx 开启自启"></a>配置 nginx 开启自启</h3><p>利用 systemctl 命令：<br>如果用yum install 命令安装的nginx，yum命令会自动创建nginx.service文件，直接用命令：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable nginx  # 设置开机启动 nginx</span><br><span class="line">systemctl disable nginx  # 关闭开机启动 nginx</span><br></pre></td></tr></table></figure><br>就你可以设置开机自启，否则需要在系统服务目录里创建 nginx.service 文件。<br>创建并打开 nginx.service 文件：<br><code>vi /lib/systemd/system/nginx.service</code><br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">内容如下:</span><br><span class="line">        [Unit]</span><br><span class="line">        Description&#x3D;nginx</span><br><span class="line">        After&#x3D;network.target</span><br><span class="line"></span><br><span class="line">        [Service]</span><br><span class="line">        Type&#x3D;forking</span><br><span class="line">        ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx</span><br><span class="line">        ExecReload&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s reload</span><br><span class="line">        ExecStop&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s quit</span><br><span class="line">        PrivateTmp&#x3D;true</span><br><span class="line"></span><br><span class="line">        [Install]</span><br><span class="line">        WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure><br><code>:wq</code> 保存退出，运行 <code>systemctl daemon-reload</code> 使文件生效。</p><p>这样便可以通过以下命令操作nginx了：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx.service  # 启动nginx服务</span><br><span class="line">systemctl enable nginx.service  # 设置开机启动</span><br><span class="line">systemctl disable nginx.service  # 停止开机启动</span><br><span class="line">systemctl status nginx.service  # 查看服务当前状态</span><br><span class="line">systemctl restart nginx.service  # 重新启动服务</span><br><span class="line">systemctl is-enabled nginx.service  # 查询服务是否开机启动</span><br></pre></td></tr></table></figure></p><h3 id="通过开机启动命令脚本实现开机自启"><a href="#通过开机启动命令脚本实现开机自启" class="headerlink" title="通过开机启动命令脚本实现开机自启"></a>通过开机启动命令脚本实现开机自启</h3><p>创建开启启动命令脚本文件：<br><code>vi /etc/init.d/nginx</code></p><p>在这个 nginx 文件中插入以下启动脚本代码，启动脚本代码来源网络复制，实测有效：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#! &#x2F;bin&#x2F;bash</span><br><span class="line"># chkconfig: -85 15</span><br><span class="line">PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx</span><br><span class="line">DESC&#x3D;&quot;nginx daemon&quot;</span><br><span class="line">NAME&#x3D;nginx</span><br><span class="line">DAEMON&#x3D;$PATH&#x2F;sbin&#x2F;$NAME</span><br><span class="line">CONFIGFILE&#x3D;$PATH&#x2F;logs&#x2F;$NAME.pid</span><br><span class="line">scriptNAME&#x3D;&#x2F;etc&#x2F;init.d&#x2F;$NAME</span><br><span class="line">set -e</span><br><span class="line">[ -x &quot;$DAEMON&quot; ] || exit 0</span><br><span class="line">do_start() &#123;</span><br><span class="line">    $DAEMON -c $CONFIGFILE || echo -n &quot;nginx already running&quot;</span><br><span class="line">&#125;</span><br><span class="line">do_stop() &#123;</span><br><span class="line">    $DAEMON -s stop || echo -n &quot;nginx not running&quot;</span><br><span class="line">&#125;</span><br><span class="line">do_reload() &#123;</span><br><span class="line">    $DAEMON -s reload || echo -n &quot;nginx can&#39;t reload&quot;</span><br><span class="line">&#125;</span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">start()</span><br><span class="line">echo -n &quot;Starting $DESC: $NAME&quot;</span><br><span class="line">do_start</span><br><span class="line">echo &quot;.&quot;</span><br><span class="line">;;</span><br><span class="line">restart()</span><br><span class="line">echo -n &quot;Restarting $DESC: $NAME&quot;</span><br><span class="line">do_stop</span><br><span class="line">do_start</span><br><span class="line">echo &quot;.&quot;</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">echo &quot;Usage: $scriptNAME &#123;start|stop|reload|restart&#125;&quot; &gt;&amp;2</span><br><span class="line">exit 3</span><br><span class="line">;;</span><br><span class="line">esac</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><br>设置所有人都有对这个启动脚本 nginx 文件的执行权限：<br><code>chmod a+x /etc/init.d/nginx</code></p><p>把nginx加入系统服务中：<br><code>chkconfig --add nginx</code></p><p>把服务设置为开机启动<br><code>chkconfig nginx on</code></p><p>reboot 重启系统生效，可以使用上面 systemctl 方法相同的命令：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx.service  # 启动nginx服务</span><br><span class="line">systemctl enable nginx.service  # 设置开机启动</span><br><span class="line">systemctl disable nginx.service  # 停止开机启动</span><br><span class="line">systemctl status nginx.service  # 查看服务当前状态</span><br><span class="line">systemctl restart nginx.service  # 重新启动服务</span><br><span class="line">systemctl is-enabled nginx.service  # 查询服务是否开机启动</span><br></pre></td></tr></table></figure></p><p>如果服务启动的时候出现 <code>Restarting nginx daemon: nginxnginx: [error] open() &quot;/usr/local/nginx/logs/nginx.pid&quot; filed (2: No such file or directory) nginx not running</code> 的错误，通过 nginx -c 参数指定配置文件即可解决<br><code>/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/ngonx.conf</code></p><p>如果服务启动中出现 <code>nginx: [emerg] bind() to 0.0.0.0:80 filed (98: Address already in use)</code> 的错误，可以先通过 <code>service nginx stop</code> 停止服务，再启动就好。</p><h3 id="配置-nginx-全局可用"><a href="#配置-nginx-全局可用" class="headerlink" title="配置 nginx 全局可用"></a>配置 nginx 全局可用</h3><p>当你每次改了 <code>nginx.conf</code> 配置文件的内容都需要重新到 nginx 启动目录去执行命令，或者通过 -p 参数指向特定目录，会不会感觉很麻烦？</p><p>例如：直接执行 <code>nginx -s reload</code> 会报错 <code>-bash: nginx command not found</code> 需要 <code>/usr/local/nginx/sbin</code> 目录下面去执行，并且是执行 <code>./nginx -s reload</code> 。</p><p>这里有两种方式可以解决，一种是通过脚本对 nginx 命令包装，这里介绍另外一种比较简单：通过把 nginx 配置到环境变量里，用nginx执行指令即可。步骤如下：</p><p>1、编辑/etc/profile<br><code>vi /etc/profile</code></p><p>2、在最后一行添加配置，:wq 保存<br><code>export PATH=$PATH:/usr/local/nginx/sbin</code></p><p>3、使配置立即生效<br><code>source /etc/profile</code></p><p>这样就可以愉快的直接在全局使用 nginx 命令了。</p><hr><h1 id="nginx-常用功能"><a href="#nginx-常用功能" class="headerlink" title="nginx 常用功能"></a>nginx 常用功能</h1><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>我们最常说的反向代理的是通过反向代理解决跨域问题。</p><p>其实反响代理还可以用来控制缓存（代理缓存 proxy cache），进行访问控制等等，以及后面说的负载均衡其实都是通过反向代理来实现的。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen  8080;</span><br><span class="line">    # 用户访问 ip:8080&#x2F;test 下的所有路径代理到 baidu.com</span><br><span class="line">    location &#x2F;test &#123;</span><br><span class="line">        proxy_pass  https:&#x2F;&#x2F;baidu.com;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 所有 &#x2F;api 下的接口访问代理到本地的 8080 端口</span><br><span class="line">    # 例如你本地运行的 go 服务的端口是 8888，接口都是以 &#x2F;api 开头</span><br><span class="line">    location &#x2F;api &#123;</span><br><span class="line">        proxy_pass  http:&#x2F;&#x2F;localhost:8888;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    location ~ ^&#x2F;index.html &#123;</span><br><span class="line">        # 匹配 index.html 页面除了 127.0.0.1 以外都可以访问</span><br><span class="line">        deny 192.168.1.1;</span><br><span class="line">        deny 192.168.1.2;</span><br><span class="line">        allow all;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>上面命令表示禁止 192.168.1.1 和 192.168.1.2 两个 ip 访问，其它全部允许。从上到下的顺序，匹配到了便跳出，可以按你的需求设置。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>通过负载均衡充利用服务器资源，nginx 目前支持自带4中负载均衡策略，还有2种常用的第三方策略。</p><h4 id="轮训策略（默认）"><a href="#轮训策略（默认）" class="headerlink" title="轮训策略（默认）"></a>轮训策略（默认）</h4><p>每个请求按照时间顺序逐一分配到不同的后端服务器，如果有后端服务器挂掉，能自动剔除。但是如果其中某一台服务器压力太大，出现延迟，会影响所有分配在这台服务器下的用户。</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream test.com &#123;</span><br><span class="line">        server 192.168.1.12:8887;</span><br><span class="line">        server 192.168.1.13:8888;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        location &#x2F;api &#123;</span><br><span class="line">            proxy_pass  http:&#x2F;&#x2F;test.com;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h4 id="根据服务器权重"><a href="#根据服务器权重" class="headerlink" title="根据服务器权重"></a>根据服务器权重</h4><p>例如要配置：10 次请求中大概 1 次访问到 8888 端口，9 次访问到 8887 端口：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream test.com &#123;</span><br><span class="line">        server 192.168.1.12:8887 weight&#x3D;9;</span><br><span class="line">        server 192.168.1.13:8888 weight&#x3D;1;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        location &#x2F;api &#123;</span><br><span class="line">            proxy_pass  http:&#x2F;&#x2F;test.com;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="客户端-id-绑定（ip-hash）"><a href="#客户端-id-绑定（ip-hash）" class="headerlink" title="客户端 id 绑定（ip_hash）"></a>客户端 id 绑定（ip_hash）</h4><p>来自同一个 ip 的请求永远只分配一台服务器，有效解决了动态网页的 session 共享问题，例如：比如把登陆信息保存到了 session 中，那么跳转到另外一台服务器的时候就需要重新登陆了。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream test.com &#123;</span><br><span class="line">        ip_hash;</span><br><span class="line">        server 192.168.1.12:8887;</span><br><span class="line">        server 192.168.1.13:8888;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        location &#x2F;api &#123;</span><br><span class="line">            proxy_pass  http:&#x2F;&#x2F;test.com;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="最小连接数策略"><a href="#最小连接数策略" class="headerlink" title="最小连接数策略"></a>最小连接数策略</h4><p>将请求优先分配给压力较小的服务器，它可以平衡每个队列的长度，并避免向压力大的服务器添加更多的请求。</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream test.com &#123;</span><br><span class="line">        least_conn;</span><br><span class="line">        server 192.168.1.12:8887;</span><br><span class="line">        server 192.168.1.13:8888;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        location &#x2F;api &#123;</span><br><span class="line">            proxy_pass  http:&#x2F;&#x2F;test.com;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h4 id="最快响应时间策略（依赖于第三方-NGINX-Plus）"><a href="#最快响应时间策略（依赖于第三方-NGINX-Plus）" class="headerlink" title="最快响应时间策略（依赖于第三方 NGINX Plus）"></a>最快响应时间策略（依赖于第三方 NGINX Plus）</h4><p>依赖于 NGINX Plus，优先分配给响应时间最短的服务器。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream test.com &#123;</span><br><span class="line">        fair;</span><br><span class="line">        server 192.168.1.12:8887;</span><br><span class="line">        server 192.168.1.13:8888;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        location &#x2F;api &#123;</span><br><span class="line">            proxy_pass  http:&#x2F;&#x2F;test.com;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="按访问url的hash结果（第三方）"><a href="#按访问url的hash结果（第三方）" class="headerlink" title="按访问url的hash结果（第三方）"></a>按访问url的hash结果（第三方）</h4><p>按访问的 url 的 hash 结果来分配请求，使每个 url 定向到同一个后端服务器，后端服务器为缓存时比较有效。在 upstream 中加入 hash 语句，server 语句中 不能写入 weight 等其它的参数，hash_method 是使用的 hash 算法。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream test.com &#123;</span><br><span class="line">        hash $request_uri;</span><br><span class="line">        hash_method crc32;</span><br><span class="line">        server 192.168.1.12:8887;</span><br><span class="line">        server 192.168.1.13:8888;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        location &#x2F;api &#123;</span><br><span class="line">            proxy_pass  http:&#x2F;&#x2F;test.com;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>采用 HAproxy 的 loadbalance uri 或者 nginx 的 upstream_hash 模块，都可以做到针对 uri 进行哈希算法式的负载均衡转发。</p><h3 id="gzip-压缩"><a href="#gzip-压缩" class="headerlink" title="gzip 压缩"></a>gzip 压缩</h3><p>开启 gzip 压缩可以大幅减少 http 传输过程中文件的大小，可以极大的提高网站的访问速度，基本是必不可少的优化操作：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gzip    on;  # 开启 gzip 压缩</span><br><span class="line"># gzip_types</span><br><span class="line"># gzip_static on;</span><br><span class="line"># gzip_proxied expired no-cache no-store private auth;</span><br><span class="line"># gzip_buffers 16 8k;</span><br><span class="line">gzip_min_length 1k;</span><br><span class="line">gzip_comp_level 4;</span><br><span class="line">gzip_http_version 1.0;</span><br><span class="line">gzip_vary off;</span><br><span class="line">gzip_disable &quot;MSIE [1-6]\.&quot;;</span><br></pre></td></tr></table></figure></p><ul><li>解释一下以上参数：<blockquote><ol><li>gzip_types：要采用 gzip 压缩的 MIME 文件类型，其中 text/html 被系统强制启用；</li><li>gzip_static：默认 off，该模块启用后，Nginx 首先检查是否存在请求静态文件的 gz 结尾的文件，如果有则直接返回该 .gz 文件内容；</li><li>gzip_proxied：默认 off nginx 做为反响代理时启用，用于设置启用或禁用从代理服务器上收到相应内容的 gzip 压缩；</li><li>gzip_buffers：获取多少内存用于缓存压缩结果，16 8k 表示 8k*16 为单位获得；</li><li>gzip_min_length：允许压缩的页面最小字节数，页面字节数 从 header 头中的 Content-Length 中进行获取，默认值是 0，不管也页面多大都压缩。建议设置成大于 1k 的字节数，小于 1k 可能会越压越大；</li><li>gzip_comp_level：gzip 压缩比，压缩级别是 1-9，1 压缩级别最低，9 最高，级别越高压缩率越大，压缩时间越长，建议 4-6；</li><li>gzip_http_version：默认 1.1，启用 gzip 所需的 HTTP 最低版本；</li><li>gzip_vary：用于在响应消息头中添加 Vary：Accept-Encoding，使代理服务器根据请求头中的 Accept-Encoding 识别是否启用 gzip 压缩；</li><li>gzip_disable：指定那些不需要 gzip 压缩的浏览器；<br>其中第2点，普遍是结合前端打包的时候打包成 gzip 文件后部署到服务器上，这样服务器就可以直接使用 gzip 的文件了，并且可以把压缩比例提高，这样 nginx 就不用压缩，也就不会影响速度，一般不追求极致的情况下，前端不用做任何配置就可以使用了。</li></ol></blockquote></li></ul><p>附前端 webpack 开启 gzip 压缩配置，在 vue-cli3 的 vue.config.js 配置文件中：<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CompressionWebpackPlugin = <span class="built_in">require</span>(<span class="string">'compression-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// gzip 配置</span></span><br><span class="line">    configureWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">            <span class="comment">// 生产环境</span></span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                plugins: [<span class="keyword">new</span> ConpressionWebpackPlugin (&#123;</span><br><span class="line">                    test: <span class="regexp">/\.js$|\.html$|\.css/</span>,    <span class="comment">// 匹配文件名</span></span><br><span class="line">                    threshold: <span class="number">1024</span>,                <span class="comment">// 文件压缩阀值，对超过 1k 的进行压缩</span></span><br><span class="line">                    deleteOriginalAssets: <span class="literal">false</span>     <span class="comment">// 是否删除源文件</span></span><br><span class="line">                &#125;)]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="HTTP-服务器"><a href="#HTTP-服务器" class="headerlink" title="HTTP 服务器"></a>HTTP 服务器</h3><p>nginx 本身也是一个静态资源的服务器，当只有静态资源的时候，就可以使用 nginx 来做服务器：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen  80;</span><br><span class="line">    server_name localhost;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root    &#x2F;usr&#x2F;local&#x2F;app;</span><br><span class="line">        index   index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>这样如果访问 <a href="http://ip" target="_blank" rel="noopener">http://ip</a> 就会默认访问到 /usr/local/app 目录下面的 index.html，如果一个网站只是静态页面的话，那么就可以通过这种方式来实现部署，比如一个静态官网。</p><h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3><p>就是把动态和静态的请求分开。方式主要有两种：<br>    *   一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也就是目前主流推崇的方案<br>    *   一种就是动态跟静态文件混合在一起发布，通过 nginx 配置来分开<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 所有静态请求都由nginx处理，存放目录为 html</span><br><span class="line">location ~ \.(gif|jpg|jpeg|png|bmp|swf|css|js)$ &#123;</span><br><span class="line">    root    &#x2F;usr&#x2F;local&#x2F;resource;</span><br><span class="line">    expires 10h;    # 设置过期时间为 10 小时</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 所有动态请求都转发给 tomcat 处理</span><br><span class="line">location ~ \.(jsp|do)$ &#123;</span><br><span class="line">    proxt_pass  127.0.0.1:8888;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意上面设置了 expires，当 nginx 设置了 expires 后，例如设置为：expires 10d；那么，所在的 location 或 if 的内容，用户在 10 天内请求的时候，都只会访问浏览器中的缓存，而不会去请求 nginx。</p><h3 id="请求限制"><a href="#请求限制" class="headerlink" title="请求限制"></a>请求限制</h3><p>对于大流量恶意的访问，会造成带宽的浪费，给服务器增加压力。可以通过 nginx 对于同一 ip 的连接数以及并发数进行限制。合理的控制还可以用来防止 DDos 和 CC攻击。</p><p>关于请求限制主要使用 nginx 默认集成的 2个模块：<br>    *   limit_conn_module 连接频率限制模块<br>    *   limit_req_module  请求频率限制模块</p><p>涉及到的配置主要是：<br>    *   limit_req_zone  限制请求数<br>    *   limit_conn_zone 限制并发连接数</p><h4 id="通过-limit-req-zone-限制请求数"><a href="#通过-limit-req-zone-限制请求数" class="headerlink" title="通过 limit_req_zone 限制请求数"></a>通过 limit_req_zone 限制请求数</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    limit_conn_zone $binary_remote_addrzone&#x3D;limit : 10m; &#x2F;&#x2F; 设置共享内存空间大小</span><br><span class="line">    server &#123;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            limit_conn addr 5;  # 同一用户地址同一时间只允许5个链接</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>如果共享内存空间被耗尽，服务器将会对后续所有的请求返回503（Service Temporarily Unavailable）错误。<br>当多个limit_conn_zone 指令被配置时，所有的连接数限制都会生效。比如，下面配置不仅会限制单一IP来源的连接数同时也会限制单一虚拟服务器的总连接数：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">limit_conn_zone $binary_remote_addr zone&#x3D;perip:10m;</span><br><span class="line">limit_conn_zone $server_name zone&#x3D;perserver:10m;</span><br><span class="line">server &#123;</span><br><span class="line">    limit_conn perip 10; # 限制每个 ip 连接到服务器的数量</span><br><span class="line">    limit_conn perserver 2000; # 限制连接到服务器的总数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h4 id="通过-limit-conn-zone-限制并发连接数"><a href="#通过-limit-conn-zone-限制并发连接数" class="headerlink" title="通过 limit_conn_zone 限制并发连接数"></a>通过 limit_conn_zone 限制并发连接数</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">limit_req_zone $binary_remote_addr zone&#x3D;creq:10 mrate&#x3D;10r&#x2F;s;</span><br><span class="line">server&#123;</span><br><span class="line">    location &#x2F;&#123;</span><br><span class="line">        limit_req zone&#x3D;creq burst&#x3D;5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>限制平均每秒不超过一个请求，同时允许超过频率限制的请求数不多于5个。<br>如果不希望超过的请求被延迟，可以用 nodelay 参数，如：<code>limit_req zone=creq burst=5 nodelay;</code></p><h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p>正向代理，意思是一个位于客户端和原始服务器（origin server）之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标（原始服务器），然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理，比如我们使用的 VPN 服务就是正向代理，直观区别：<br><img src= "/img/loading.gifs" data-src="/images/nginx/img1.jpg" alt=""></p><p>配置正向代理：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">resolver 8.8.8.8 # 谷歌的域名解析地址</span><br><span class="line">server &#123;</span><br><span class="line">    resolver_timeout 5s; &#x2F;&#x2F; 设超时时间</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        # 当客户端请求我的时候，我会把请求转发给它</span><br><span class="line">        # $host 要访问的主机名 $request_uri 请求路径</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;$host$request_uri;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>正向代理的对象是客户端，服务器端看不到正真的客户端。</p><h3 id="图片防盗链"><a href="#图片防盗链" class="headerlink" title="图片防盗链"></a>图片防盗链</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    server &#123;</span><br><span class="line">    listen       80;      </span><br><span class="line">    server_name  *.test;</span><br><span class="line"></span><br><span class="line">    # 图片防盗链</span><br><span class="line">    location ~* \.(gif|jpg|jpeg|png|bmp|swf)$ &#123;</span><br><span class="line">        valid_referers none blocked server_names ~\.google\. ~\.baidu\. *.qq.com;  # 只允许本机 IP 外链引用，将百度和谷歌也加入白名单有利于 SEO</span><br><span class="line">        if ($invalid_referer)&#123;</span><br><span class="line">            return 403;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>以上配置就能防止其它网站利用外链访问我们的图片，有利于节省流量。</p><h3 id="适配-PC-或移动设备"><a href="#适配-PC-或移动设备" class="headerlink" title="适配 PC 或移动设备"></a>适配 PC 或移动设备</h3><p>根据用户设备不用返回不用样式的站点，以前经常使用的是纯前端的自适应布局，但是复杂的网站并不适合响应式，无论是复杂性和易用性上面还是不如分开编写的好，比如我们常见的淘宝、京东。</p><p>根据用户请求的 user-agent 来判断是返回 PC 还是 H5 站点：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name test.com;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root  &#x2F;usr&#x2F;local&#x2F;app&#x2F;pc; # pc 的 html 路径</span><br><span class="line">        if ($http_user_agent ~* &#39;(Android|webOS|iPhone|iPod|BlackBerry)&#39;) &#123;</span><br><span class="line">            root &#x2F;usr&#x2F;local&#x2F;app&#x2F;mobile; # mobile 的 html 路径</span><br><span class="line">        &#125;</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="设置二级域名"><a href="#设置二级域名" class="headerlink" title="设置二级域名"></a>设置二级域名</h3><p>新建一个 server 即可：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name admin.test.com; &#x2F;&#x2F; 二级域名</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root  &#x2F;usr&#x2F;local&#x2F;app&#x2F;admin; # 二级域名的 html 路径</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="配置-HTTPS"><a href="#配置-HTTPS" class="headerlink" title="配置 HTTPS"></a>配置 HTTPS</h3><p>这里我们使用 cerbot 免费证书，但申请一次有效期只有三个月，（好像可以用 crontab 尝试配置自动续期）：<br>先安装 cerbot</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;dl.eff.org&#x2F;cerbot-auto</span><br><span class="line">chmod a+x cerbot-auto</span><br></pre></td></tr></table></figure></code></pre><p>申请证书（注意：需要把申请证书的域名先解析到这台服务器上，才能申请）：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo .&#x2F;certbot-auto certonly --standalone --email admin@abc.com -d test.com -d www.test.com</span><br></pre></td></tr></table></figure></code></pre><p>执行上面指令，按提示操作。<br>Cerbot 会启动一个临时服务器来完成验证，（会占用 80 端口或 443 端口，因此需要暂时关闭 Web 服务器），然后 Cerbot 会把证书以文件的形式保存，包括完整的证书链文件和私钥文件。</p><p>文件保存在 etc/letsencrypt/live 下面的域名目录下。</p><p>修改 nginx 配置：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    server&#123;</span><br><span class="line">    listen 443 ssl http2; &#x2F;&#x2F; 这里还启用了 http&#x2F;2.0</span><br><span class="line"></span><br><span class="line">    ssl_certificate &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;test.com&#x2F;fullchain.pem; # 证书文件地址</span><br><span class="line">    ssl_certificate_key &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;test.com&#x2F;privkey.pem; # 私钥文件地址</span><br><span class="line"></span><br><span class="line">    server_name test.com www.test.com; &#x2F;&#x2F; 证书绑定的域名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="配置-HTTP-转-HTTPS"><a href="#配置-HTTP-转-HTTPS" class="headerlink" title="配置 HTTP 转 HTTPS"></a>配置 HTTP 转 HTTPS</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    server &#123;</span><br><span class="line">    listen      80;</span><br><span class="line">    server_name test.com www.test.com;</span><br><span class="line"></span><br><span class="line">    # 单域名重定向</span><br><span class="line">    if ($host &#x3D; &#39;www.sherlocked93.club&#39;)&#123;</span><br><span class="line">        return 301 https:&#x2F;&#x2F;www.sherlocked93.club$request_uri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 全局非 https 协议时重定向</span><br><span class="line">    if ($scheme !&#x3D; &#39;https&#39;) &#123;</span><br><span class="line">        return 301 https:&#x2F;&#x2F;$server_name$request_uri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 或者全部重定向</span><br><span class="line">    return 301 https:&#x2F;&#x2F;$server_name$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>以上配置选择自己需要的一条即可，不用全部加。</p><h3 id="单页面项目-history-路由配置"><a href="#单页面项目-history-路由配置" class="headerlink" title="单页面项目 history 路由配置"></a>单页面项目 history 路由配置</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  fe.sherlocked93.club;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root       &#x2F;usr&#x2F;local&#x2F;app&#x2F;dist;  # vue 打包后的文件夹</span><br><span class="line">        index      index.html index.htm;</span><br><span class="line">        try_files  $uri $uri&#x2F; &#x2F;index.html @rewrites; # 默认目录下的 index.html，如果都不存在则重定向</span><br><span class="line"></span><br><span class="line">        expires -1;                          # 首页一般没有强制缓存</span><br><span class="line">        add_header Cache-Control no-cache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location @rewrites &#123; &#x2F;&#x2F; 重定向设置</span><br><span class="line">        rewrite ^(.+)$ &#x2F;index.html break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p><a href="https://router.vuejs.org/zh/guide/essentials/history-mode.html#%E5%90%8E%E7%AB%AF%E9%85%8D%E7%BD%AE%E4%BE%8B%E5%AD%90" target="_blank" rel="noopener">vue-router</a> 官网只有一句话 <code>try_files $uri $uri/ /index.html;</code> 而上面做了一些重定向处理。</p><h3 id="配置高可用集群（双机热备）"><a href="#配置高可用集群（双机热备）" class="headerlink" title="配置高可用集群（双机热备）"></a>配置高可用集群（双机热备）</h3><p>当主机 nginx 服务器宕机之后，切换到备份的 nginx 服务器</p><p>首先安装 keepalived：<code>yum install keepalived -y</code> 然后编辑 <code>/etc/keepalived/keepalived.conf</code> 配置文件，并在配置文件中增加 <code>vrrp_script</code> 定义一个外围检测机制，并在 <code>vrrp_instance</code> 中通过定义 <code>track_script</code> 来追踪脚本执行过程，实现节点转移：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">global_defs&#123;</span><br><span class="line">notification_email &#123;</span><br><span class="line">        cchroot@gmail.com</span><br><span class="line">&#125;</span><br><span class="line">notification_email_from test@firewall.loc</span><br><span class="line">smtp_server 127.0.0.1</span><br><span class="line">smtp_connect_timeout 30 &#x2F;&#x2F; 上面都是邮件配置</span><br><span class="line">router_id LVS_DEVEL     &#x2F;&#x2F; 当前服务器名字，用 hostname 命令来查看</span><br><span class="line">&#125;</span><br><span class="line">vrrp_script chk_maintainace &#123; &#x2F;&#x2F; 检测机制的脚本名称为chk_maintainace</span><br><span class="line">    script &quot;[[ -e&#x2F;etc&#x2F;keepalived&#x2F;down ]] &amp;&amp; exit 1 || exit 0&quot; &#x2F;&#x2F; 可以是脚本路径或脚本命令</span><br><span class="line">    &#x2F;&#x2F; script &quot;&#x2F;etc&#x2F;keepalived&#x2F;nginx_check.sh&quot;    &#x2F;&#x2F; 比如这样的脚本路径</span><br><span class="line">    interval 2  &#x2F;&#x2F; 每隔2秒检测一次</span><br><span class="line">    weight -20  &#x2F;&#x2F; 当脚本执行成立，那么把当前服务器优先级改为-20</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instanceVI_1 &#123;   &#x2F;&#x2F; 每一个vrrp_instance就是定义一个虚拟路由器</span><br><span class="line">    state MASTER      &#x2F;&#x2F; 主机为MASTER，备用机为BACKUP</span><br><span class="line">    interface eth0    &#x2F;&#x2F; 网卡名字，可以从ifconfig中查找</span><br><span class="line">    virtual_router_id 51 &#x2F;&#x2F; 虚拟路由的id号，一般小于255，主备机id需要一样</span><br><span class="line">    priority 100      &#x2F;&#x2F; 优先级，master的优先级比backup的大</span><br><span class="line">    advert_int 1      &#x2F;&#x2F; 默认心跳间隔</span><br><span class="line">    authentication &#123;  &#x2F;&#x2F; 认证机制</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111   &#x2F;&#x2F; 密码</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;  &#x2F;&#x2F; 虚拟地址vip</span><br><span class="line">    172.16.2.8</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>其中检测脚本 <code>nginx_check.sh</code> ，这里提供一个：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">A&#x3D;&#96;ps -C nginx --no-header | wc -l&#96;</span><br><span class="line">if [ $A -eq 0 ];then</span><br><span class="line">    &#x2F;usr&#x2F;sbin&#x2F;nginx # 尝试重新启动nginx</span><br><span class="line">    sleep 2         # 睡眠2秒</span><br><span class="line">    if [ &#96;ps -C nginx --no-header | wc -l&#96; -eq 0 ];then</span><br><span class="line">        killall keepalived # 启动失败，将keepalived服务杀死。将vip漂移到其它备份节点</span><br><span class="line">    fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></code></pre><p>复制一份到备份服务器，备份 nginx 的配置要将 <code>state</code> 后改为 <code>BACKUP</code> ， <code>priority</code> 改为比主机小。<br>设置完毕后各自 <code>service keepalived start</code> 启动，经过访问成功后，可以把 Master 机的 keepalived 停掉，此时 Master 机就不再是主机了 <code>services keepalived stop</code> 看到访问虚拟 IP 时是否能够自动切换到备机 ip addr。</p><p>再次启动 Master 的 keepalived，此时 vip 又变到了主机上。</p><p>配置高可用集群的内容来源于：<a href="https://juejin.cn/post/6844904144235413512#heading-11" target="_blank" rel="noopener">Nginx 从入门到实践，万字详解！</a></p><hr><h1 id="其它功能和技巧"><a href="#其它功能和技巧" class="headerlink" title="其它功能和技巧"></a>其它功能和技巧</h1><h3 id="代理缓存"><a href="#代理缓存" class="headerlink" title="代理缓存"></a>代理缓存</h3><p>nginx 的 http_proxy 模块，提供类似于 Squid 的缓存功能，使用 proxy_cache_path 来配置。</p><p>nginx 可以对访问过的内容在 nginx 服务器本地建立副本，这样在一段时间内再次访问该数据，就不需要通过 nginx 服务器再次向后端服务器发出请求，减小数据传输延迟，提高访问速度：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    proxy_cache_path usr&#x2F;local&#x2F;cache levels&#x3D;1:2 keys_zone&#x3D;my_cache:10m;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  test.com;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_cache my_cache;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;127.0.0.1:8888;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>上面的配置表示：nginx 提供一块 10m 的内存用于缓存，名字为 my_cache，levels 等级为1:2，缓存存放的路径为 <code>usr/local/cache</code> 。</p><h3 id="访问日志"><a href="#访问日志" class="headerlink" title="访问日志"></a>访问日志</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    http &#123;</span><br><span class="line">    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">                    &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">                    &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">    access_log  logs&#x2F;access.log  main;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>错误日志放在 main 全局区块中，打开 nginx.conf 就可以看见在配置文件中和下面一样的代码了：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#error_log  logs&#x2F;error.log;</span><br><span class="line">#error_log  logs&#x2F;error.log  notice;</span><br><span class="line">#error_log  logs&#x2F;error.log  info;</span><br></pre></td></tr></table></figure></p><p>nginx 错误日志默认配置为：<code>error_log logs/error.log error;</code> </p><h3 id="静态资源服务器"><a href="#静态资源服务器" class="headerlink" title="静态资源服务器"></a>静态资源服务器</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  static.bin;</span><br><span class="line">    charset utf-8;    # 防止中文文件名乱码</span><br><span class="line"></span><br><span class="line">    location &#x2F;download &#123;</span><br><span class="line">        alias          &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;static;  # 静态资源目录</span><br><span class="line"></span><br><span class="line">        autoindex               on;    # 开启静态资源列目录，浏览目录权限</span><br><span class="line">        autoindex_exact_size    off;   # on(默认)显示文件的确切大小，单位是byte；off显示文件大概大小，单位KB、MB、GB</span><br><span class="line">        autoindex_localtime     off;   # off(默认)时显示的文件时间为GMT时间；on显示的文件时间为服务器时间</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="禁止指定-user-agent"><a href="#禁止指定-user-agent" class="headerlink" title="禁止指定 user_agent"></a>禁止指定 user_agent</h3><p>nginx 可以禁止指定的浏览器和爬虫框架的访问：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># http_user_agent 为浏览器标识</span><br><span class="line"># 禁止 user_agent 为baidu、360和sohu，~*表示不区分大小写匹配</span><br><span class="line">if ($http_user_agent ~* &#39;baidu|360|sohu&#39;) &#123;</span><br><span class="line">    return 404;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 禁止 Scrapy 等工具的抓取</span><br><span class="line">if ($http_user_agent ~* (Scrapy|Curl|HttpClient)) &#123;</span><br><span class="line">    return 403;</span><br></pre></td></tr></table></figure></code></pre><h3 id="请求过滤"><a href="#请求过滤" class="headerlink" title="请求过滤"></a>请求过滤</h3><h4 id="根据请求类型过滤"><a href="#根据请求类型过滤" class="headerlink" title="根据请求类型过滤"></a>根据请求类型过滤</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 非指定请求全返回 403</span><br><span class="line">if ( $request_method !~ ^(GET|POST|HEAD)$ ) &#123;</span><br><span class="line">    return 403;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h4 id="根据状态码过滤"><a href="#根据状态码过滤" class="headerlink" title="根据状态码过滤"></a>根据状态码过滤</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">error_page 502 503 &#x2F;50x.html;</span><br><span class="line">location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">    root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>这样实际上是一个内部跳转，当访问出现 502、503 的时候就能返回 50x.html 中的内容，这里需要注意是否可以找到 50x.html 页面，所以加了个 location 保证找到你自定义的 50x 页面。</p><h4 id="根据-URL-名称过滤"><a href="#根据-URL-名称过滤" class="headerlink" title="根据 URL 名称过滤"></a>根据 URL 名称过滤</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    if ($host &#x3D; zy.com&#39; ) &#123;</span><br><span class="line">    #其中$1是取自regex部分()里的内容,匹配成功后跳转到的URL。</span><br><span class="line">    rewrite ^&#x2F;(.*)$  http:&#x2F;&#x2F;www.zy.com&#x2F;$1  permanent；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location &#x2F;test &#123;</span><br><span class="line">    &#x2F;&#x2F; &#x2F;test 全部重定向到首页</span><br><span class="line">    rewrite  ^(.*)$ &#x2F;index.html  redirect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h4 id="ab-命令"><a href="#ab-命令" class="headerlink" title="ab 命令"></a>ab 命令</h4><p>ab命令全称为：Apache bench，是 Apache 自带的压力测试工具，也可以测试 Nginx、IIS 等其它 Web 服务器：</p><pre><code>*   -n总共的请求数*   -c并发的请求数*   -t测试所进行的最大秒数，默认值为 50000*   -p包含了需要的 POST 的数据文件*   -T POST数据所使用的 Content-type 头信息</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ab -n 1000 -c 5000 http:&#x2F;&#x2F;127.0.0.1&#x2F; # 每次发送1000并发的请求数，请求数总数为5000。</span><br></pre></td></tr></table></figure><p>测试前需要安装 httpd-tools：<code>yum install httpd_tools</code> </p><h4 id="泛域名路径分离"><a href="#泛域名路径分离" class="headerlink" title="泛域名路径分离"></a>泛域名路径分离</h4><p>这是一个非常使用的技能，经常有时候我们可能需要配置一些二级或者三级域名，希望通过 nginx 自动指向对应目录，比如：</p><ol><li>test1.doc.test.club 自动指向 /usr/local/html/doc/test1 服务器地址；</li><li>test2.doc.test.club 自动指向 /usr/local/html/doc/test2 服务器地址； <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  ~^([\w-]+)\.doc\.test\.club$;</span><br><span class="line"></span><br><span class="line">    root &#x2F;usr&#x2F;local&#x2F;html&#x2F;doc&#x2F;$1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="泛域名转发"><a href="#泛域名转发" class="headerlink" title="泛域名转发"></a>泛域名转发</h4><p>和之前的功能类似，有时候我们希望把二级或者三级域名链接重写到我们希望的路径，让后端，就可以根据路由解析不同的规则：</p><ol><li>test1.serv.test.club/api?name=a 自动转发到 127.0.0.1:8080/test1/api?name=a</li><li>test2.serv.test.club/api?name=a 自动转发到 127.0.0.1:8080/test2/api?name=a <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name ~^([\w-]+)\.serv\.test\.club$;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_set_header        X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header        Host $http_host;</span><br><span class="line">        proxy_set_header        X-NginX-Proxy true;</span><br><span class="line">        proxy_pass              http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;$1$request_uri;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h3 id="nginx-中怎么设置变量"><a href="#nginx-中怎么设置变量" class="headerlink" title="nginx 中怎么设置变量"></a>nginx 中怎么设置变量</h3><p>或许你不知道， nginx 的配置文件使用的是一门微型编程语言。既然是编程语言，一般也就少不了“变量“这种东西，但是在 nginx 配置中，变量只能存放一种类型的值，因为也只存在一种类型的值，那就是字符串。</p><p>例如我们在 nginx.conf 中有这样一行配置：<code>set $name &quot;chroot&quot;;</code> </p><p>上面使用了 set 配置指令对变量 <code>$name</code> 进行了赋值操作，把“chroot” 赋值给了 <code>$name</code> 。<br>nginx 变量名前面有一个 <code>$</code> 符号，这是记法上的要求。所有的 Nginx 变量在 Nginx 配置文件中引用时都须带上 <code>$</code> 前缀。这种表示方法和 Perl、PHP 这些语言是相似的。</p><p>这种表示方法的用处在那里呢，那就是可以直接把变量嵌入到字符串常量中以构造出新的字符串，例如你需要进行一个字符串拼接：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  test.com;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        set $temp hello;</span><br><span class="line">        return &quot;$temp world&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上当匹配成功的时候就会返回字符串“hello world”了。需要注意的是，当引用变量名之后紧跟着变量名的构成字符时（比如后面跟字母、数字以及下划线），我们就需要使用特别的记法来消除歧义，例如：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  test.com;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        set $temp &quot;hello &quot;;</span><br><span class="line">        return &quot;$&#123;temp&#125;world&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里，我们在配置指令的参数值中引用变量 <code>$temp</code> 的时候，后面紧跟着 <code>world</code> 这个单词，所以如果直接写作 <code>$tempworld</code> 则 nginx 的计算引擎会将之识别为引用了变量 <code>$tempworld</code> ，为了解决这个问题， nginx 的字符串支持使用花括号在 <code>$</code> 之后把变量名围起来，比如这里的 <code>${temp}</code> ，所以上面这个例子返回的还是“hello world”：<br><code>curl  &#39;http://test.com/&#39;</code></p><p>还需要注意的是，若是向输出 <code>$</code> 符号本身，可以这样做：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    geo $dollar &#123;</span><br><span class="line">    default &quot;$&quot;;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  test.com;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        set $temp &quot;hello &quot;;</span><br><span class="line">        return &quot;$&#123;temp&#125;world: $dollar&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>上面用到了标准模块的 ngx_geo 提供的配置指令 geo 来为变量 <code>$dollar</code> 赋予字符串， <code>$</code> ，这样，这里的返回值就是 “hello world：$” 了。</p><hr><h1 id="附-nginx-内置预定义变量"><a href="#附-nginx-内置预定义变量" class="headerlink" title="附 nginx 内置预定义变量"></a>附 nginx 内置预定义变量</h1><ul><li>按字母顺序，变量名对应定义<blockquote><ul><li><code>$arg_PARAMETER</code>  #GET 请求中变量名 PARAMETER 参数的值</li><li><code>$args</code>  #这个变量等于 GET 请求中的参数，例如，foo=123&amp;bar=blahblah;这个变量可以被修改</li><li><code>$binary_remote_addr</code>  #二进制码形式的客户端地址</li><li><code>$body_bytes_sent</code>  #传送页面的字节数</li><li><code>$content_length</code>  #请求头中的 Content-length 字段</li><li><code>$content_type</code>  #请求头中的 Content-Type 字段</li><li><code>$cookie_COOKIE</code>  #cookie COOKIE 的值</li><li><code>$document_root</code>  #当前请求在 root 指令中指定的值</li><li><code>document_uri</code>  #与 $uri 相同</li><li><code>$host</code>  #请求中的主机头(Host)字段，如果请求中的主机头不可用或者空，则为处理请求的server 名称(处理请求的 server 的 server_name 指令的值)。值为小写，不包含端口</li><li><code>$hostname</code>  #机器名使用 gethostname 系统调用的值</li><li><code>$http_HEADER</code>  #HTTP 请求头中的内容，HEADER 为 HTTP 请求中的内容转为小写，-变为_(破折号变为下划线)，例如：$http_user_agent(Uaer-Agent 的值)</li><li><code>$sent_http_HEADER</code>  #HTTP 响应头中的内容，HEADER 为 HTTP 响应中的内容转为小写，-变为_(破折号变为下划线)，例如：、senthttpcachecontrol、sent_http_content_type…</li><li><code>$is_args</code>  #如果 $args 设置，值为”?”，否则为””</li><li><code>$limit_rate</code>  #这个变量可以限制连接速率</li><li><code>$nginx_version</code>  #当前运行的 nginx 版本号</li><li><code>$query_string</code>  #与 $args 相同</li><li><code>$remote_addr</code>  #客户端的IP地址</li><li><code>$remote_port</code>  #客户端的端口</li><li><code>$remote_port</code>  #已经经过 Auth Basic Module 验证的用户名</li><li><code>$request_filename</code>  #当前连接请求的文件路径，由 root 或 alias 指令与 URI 请求生成</li><li><code>$request_body</code>  #这个变量（0.7.58+）包含请求的主要信息。在使用 proxy_pass 或 fastcgi_pass 指令的 location 中比较有意义</li><li><code>$request_body_file</code>  #客户端请求主体信息的临时文件名</li><li><code>$request_completion</code>  #如果请求成功，设为”OK”；如果请求未完成或者不是一系列请求中最后一部分则设为空</li><li><code>$request_method</code>  #这个变量是客户端请求的动作，通常为 GET 或 POST。包括 0.8.20 及之前的版本中，这个变量总为 main request 中的动作，如果当前请求是一个子请求，并不使用这个当前请求的动作</li><li><code>$request_uri</code>  #这个变量等于包含一些客户端请求参数的原始 URI，它无法修改，请查看 $uri 更改或重写 URI</li><li><code>$scheme</code>  #所用的协议，例如 http 或者是 https，例如 <code>rewrite ^(.+)$$scheme://example.com$1 redirect</code></li><li><code>$server_addr</code>  #服务器地址，在完成一次系统调用后可以确定这个值，如果要绕开系统调用，则必须在listen中指定地址并且使用bind参数</li><li><code>$server_name</code>  #服务器名称</li><li><code>$server_port</code>  #请求到达服务器的端口号</li><li><code>$server_protocol</code>  #请求使用的协议，通常是 HTTP/1.0、HTTP/1.1或HTTP/2</li><li><code>$uri</code>  #请求中的当前 URI(不带请求参数，参数位于 args ) ， 不 同 于 浏 览 器 传 递 的 args)，不同于浏览器传递的 args)，不同于浏览器传递的 request_uri 的值，它可以通过内部重定向，或者使用 index 指令进行修改。不包括协议和主机名，例如 /foo/bar.html</li></ul></blockquote></li></ul><hr><h1 id="附-nginx-模块"><a href="#附-nginx-模块" class="headerlink" title="附 nginx 模块"></a>附 nginx 模块</h1><h3 id="nginx-模块分类"><a href="#nginx-模块分类" class="headerlink" title="nginx 模块分类"></a>nginx 模块分类</h3><ul><li>nginx 模块分类<blockquote><ul><li>核心模块：nginx 最基本最核心的服务，如进程管理、权限控制、日志记录；</li><li>标准 HTTP 模块：nginx 服务器的标准 HTTP 功能；</li><li>可选 HTTP 模块：处理特殊的 HTTP 请求；</li><li>邮件服务模块：邮件服务；</li><li>第三方模块：作为扩展，完成特殊功能；</li></ul></blockquote></li></ul><h3 id="模块清单"><a href="#模块清单" class="headerlink" title="模块清单"></a>模块清单</h3><ul><li>模块清单<blockquote><ul><li>ngx_core</li><li>ngx_errlog</li><li>ngx_conf</li><li>ngx_events</li><li>ngx_event_core</li><li>ngx_epll</li><li>ngx_regex</li></ul></blockquote></li></ul><h3 id="标准-HTTP-模块"><a href="#标准-HTTP-模块" class="headerlink" title="标准 HTTP 模块"></a>标准 HTTP 模块</h3><ul><li>标准 HTTP 模块<blockquote><ul><li>ngx_http</li><li>ngx_http_core #配置端口，URI 分析，服务器相应错误处理，别名控制 (alias) 等</li><li>ngx_http_log #自定义 access 日志</li><li>ngx_http_upstream #定义一组服务器，可以接受来自 proxy, Fastcgi,Memcache 的重定向；主要用作负载均衡</li><li>ngx_http_static</li><li>ngx_http_autoindex #自动生成目录列表</li><li>ngx_http_index #处理以/结尾的请求，如果没有找到 index 页，则看是否开启了random_index；如开启，则用之，否则用 autoindex</li><li>ngx_http_auth_basic #基于 http 的身份认证 (auth_basic)</li><li>ngx_http_access #基于 IP 地址的访问控制 (deny,allow)</li><li>ngx_http_limit_conn #限制来自客户端的连接的响应和处理速率</li><li>ngx_http_limit_req #限制来自客户端的请求的响应和处理速率</li><li>ngx_http_geo</li><li>ngx_http_map #创建任意的键值对变量</li><li>ngx_http_split_clients</li><li>ngx_http_referer #过滤 HTTP 头中 Referer 为空的对象</li><li>ngx_http_rewrite #通过正则表达式重定向请求</li><li>ngx_http_proxy</li><li>ngx_http_fastcgi #支持 fastcgi</li><li>ngx_http_uwsgi</li><li>ngx_http_scgi</li><li>ngx_http_memcached</li><li>ngx_http_empty_gif #从内存创建一个 1×1 的透明 gif 图片，可以快速调用</li><li>ngx_http_browser #解析 http 请求头部的 User-Agent 值</li><li>ngx_http_charset #指定网页编码</li><li>ngx_http_upstream_ip_hash</li><li>ngx_http_upstream_least_conn</li><li>ngx_http_upstream_keepalive</li><li>ngx_http_write_filter</li><li>ngx_http_header_filter</li><li>ngx_http_chunked_filter</li><li>ngx_http_range_header</li><li>ngx_http_gzip_filter</li><li>ngx_http_postpone_filter</li><li>ngx_http_ssi_filter</li><li>ngx_http_charset_filter</li><li>ngx_http_userid_filter</li><li>ngx_http_headers_filter #设置 http 响应头</li><li>ngx_http_copy_filter</li><li>ngx_http_range_body_filter</li><li>ngx_http_not_modified_filter</li></ul></blockquote></li></ul><h3 id="可选-HTTP-模块"><a href="#可选-HTTP-模块" class="headerlink" title="可选 HTTP 模块"></a>可选 HTTP 模块</h3><ul><li>可选 HTTP 模块<blockquote><ul><li>ngx_http_addition #在响应请求的页面开始或者结尾添加文本信息</li><li>ngx_http_degradation #在低内存的情况下允许服务器返回 444 或者 204 错误</li><li>ngx_http_perl</li><li>ngx_http_flv #支持将 Flash 多媒体信息按照流文件传输，可以根据客户端指定的开始位置返回 Flash</li><li>ngx_http_geoip #支持解析基于 GeoIP 数据库的客户端请求</li><li>ngx_google_perftools</li><li>ngx_http_gzip #gzip 压缩请求的响应</li><li>ngx_http_gzip_static #搜索并使用预压缩的以.gz 为后缀的文件代替一般文件响应客户端请求</li><li>ngx_http_image_filter #支持改变 png，jpeg，gif 图片的尺寸和旋转方向</li><li>ngx_http_mp4 #支持.mp4,.m4v,.m4a 等多媒体信息按照流文件传输，常与 ngx_http_flv 一起使用</li><li>ngx_http_random_index #当收到 / 结尾的请求时，在指定目录下随机选择一个文件作为 index</li><li>ngx_http_secure_link #支持对请求链接的有效性检查</li><li>ngx_http_ssl #支持 https</li><li>ngx_http_stub_status</li><li>ngx_http_sub_module #使用指定的字符串替换响应中的信息</li><li>ngx_http_dav #支持 HTTP 和 WebDAV 协议中的 PUT/DELETE/MKCOL/COPY/MOVE 方法</li><li>ngx_http_xslt #将 XML 响应信息使用 XSLT 进行转换</li></ul></blockquote></li></ul><h3 id="邮件服务模块"><a href="#邮件服务模块" class="headerlink" title="邮件服务模块"></a>邮件服务模块</h3><ul><li>邮件服务模块<blockquote><ul><li>ngx_mail_core</li><li>ngx_mail_pop3</li><li>ngx_mail_imap</li><li>ngx_mail_smtp</li><li>ngx_mail_auth_http</li><li>ngx_mail_proxy</li><li>ngx_mail_ssl</li></ul></blockquote></li></ul><h3 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h3><ul><li>第三方模块<blockquote><ul><li>echo-nginx-module #支持在 nginx 配置文件中使用 echo/sleep/time/exec 等类 Shell 命令</li><li>memc-nginx-module</li><li>rds-json-nginx-module #使 nginx 支持 json 数据的处理</li><li>lua-nginx-module</li></ul></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker-compose搭建MySQL主从复制集群</title>
      <link href="/2020/09/02/docker/docker-compose%E6%90%AD%E5%BB%BAMySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E9%9B%86%E7%BE%A4/"/>
      <url>/2020/09/02/docker/docker-compose%E6%90%AD%E5%BB%BAMySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>随着应用业务数据不断的增大，应用的 响应速度不断下降，在检测过程中我们不难发现大多数的请求都是 查询操作。此时，我们可以将数据库扩展成 主从复制模式，将 读操作 和 写操作 分离开来，多台数据库 分摊请求，从而 减少单库 的 访问压力，进而应用得到优化。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h3 id="主从复制的方式"><a href="#主从复制的方式" class="headerlink" title="主从复制的方式"></a>主从复制的方式</h3><hr><p><code>MySQL 5.6</code>开始主从复制有两种方式：基于日志（<code>binlog</code>）和 基于 <code>GTID</code>（全局事务标示符）。<br>本文只涉及基于日志 <code>binlog 的</code> 主从配置。</p><h1 id="主从复制的流程"><a href="#主从复制的流程" class="headerlink" title="主从复制的流程"></a>主从复制的流程</h1><hr><p><img src= "/img/loading.gifs" data-src="/images/mysql/zhucong.jpg" alt=""><br><code>MySQL</code> 同步操作通过 <code>3</code> 个线程实现，其基本步骤如下：</p><ol><li>主从服务器将数据的更新记录到二进制日志（<code>Binary log</code>）中，用于记录二进制日志事件，这一步由主库线程完成；</li><li>从库 将 主库 的 二进制日志 复制到本地的 中继日志（<code>Relay log</code>），这一步由 从库 <code>I/O</code> 线程 完成；</li><li>从库 读取 中继日志 中的 事件，将其重放到数据中，这一步由 从库 <code>SQL</code> 线程 完成。</li></ol><h1 id="主从模式的优点"><a href="#主从模式的优点" class="headerlink" title="主从模式的优点"></a>主从模式的优点</h1><hr><ol><li><p>负载均衡<br> 通常情况下，会使用 主服务器 对数据进行 更新、删除 和 新建 等操作，而将 查询 工作落到 从库 头上。</p></li><li><p>异地容灾备份<br> 可以将主服务器上的数据同步到 异地从服务器 上，极大地提高了 数据安全性。</p></li><li><p>高可用<br> 数据库的复制功能实现了 主服务器 与 从服务器间 的数据同步，一旦主服务器出了 故障，从服务器立即担当起主服务器的角色，保障系统持续稳定运作。</p></li><li><p>高扩展性<br> 主从复制 模式支持 2 种扩展方式:</p><pre><code>scale-up    向上扩展或者 纵向扩展，主要是提供比现在服务器 性能更好 的服务器，比如 增加 CPU 和 内存 以及 磁盘阵列等，因为有多台服务器，所以可扩展性比单台更大。scale-out    向外扩展或者 横向扩展，是指增加 服务器数量 的扩展，这样主要能分散各个服务器的压力。</code></pre></li></ol><h1 id="主从模式的缺点"><a href="#主从模式的缺点" class="headerlink" title="主从模式的缺点"></a>主从模式的缺点</h1><hr><ol><li><p>成本增加<br> 搭建主从肯定会增加成本，毕竟一台服务器和两台服务器的成本完全不同，另外由于主从必须要开启 二进制日志，所以也会造成额外的 性能消耗。</p></li><li><p>数据延迟<br> 从库 从 主库 复制数据肯定是会有一定的 数据延迟 的。所以当刚插入就出现查询的情况，可能查询不出来。当然如果是插入者自己查询，那么可以直接从 主库 中查询出来，当然这个也是需要用代码来控制的。</p></li><li><p>写入更慢<br> 主从复制 主要是针对 读远大于写 或者对 数据备份实时性 要求较高的系统中。因为 主服务器 在写中需要更多操作，而且 只有一台 可以写入的 主库，所以写入的压力并不能被分散。</p></li></ol><h1 id="主从复制的前提条件"><a href="#主从复制的前提条件" class="headerlink" title="主从复制的前提条件"></a>主从复制的前提条件</h1><hr><ol><li><p>主从服务器 操作系统版本 和 位数 一致。</p></li><li><p>主数据库和从数据库的 版本 要一致。</p></li><li><p>主数据库和从数据库中的 数据 要一致。</p></li><li><p>主数据库 开启 二进制日志，主数据库和从数据库的 <code>server_id</code> 在局域网内必须 唯一。</p></li></ol><h1 id="具体配置"><a href="#具体配置" class="headerlink" title="具体配置"></a>具体配置</h1><hr><h3 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h3><table><thead><tr><th>名称</th><th>版本号</th></tr></thead><tbody><tr><td>Docker</td><td>19.03.8</td></tr><tr><td>docker-compose</td><td>1.25.4</td></tr><tr><td>MySQL</td><td>5.7.17</td></tr></tbody></table><h3 id="2-配置docker-compose-yml"><a href="#2-配置docker-compose-yml" class="headerlink" title="2. 配置docker-compose.yml"></a>2. 配置docker-compose.yml</h3><p>docker-compose.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span> </span><br><span class="line">    <span class="attr">mysql-master:</span></span><br><span class="line">        <span class="attr">build:</span> </span><br><span class="line">            <span class="attr">context:</span> <span class="string">./</span></span><br><span class="line">            <span class="attr">dockerfile:</span> <span class="string">./master/Dockerfile</span></span><br><span class="line">        <span class="attr">environment:</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="string">"MYSQL_ROOT_PASSWORD=root"</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">"MYSQL_DATABASE=replicas_db"</span></span><br><span class="line">        <span class="attr">links:</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="string">mysql-slave</span></span><br><span class="line">        <span class="attr">ports:</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="string">"33065:3306"</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">        <span class="attr">hostname:</span> <span class="string">mysql-master</span></span><br><span class="line">    <span class="attr">mysql-slave:</span></span><br><span class="line">        <span class="attr">build:</span> </span><br><span class="line">            <span class="attr">context:</span> <span class="string">./</span></span><br><span class="line">            <span class="attr">dockerfile:</span> <span class="string">./slave/Dockerfile</span></span><br><span class="line">        <span class="attr">environment:</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="string">"MYSQL_ROOT_PASSWORD=root"</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">"MYSQL_DATABASE=replicas_db"</span></span><br><span class="line">        <span class="attr">ports:</span> </span><br><span class="line">            <span class="bullet">-</span> <span class="string">"33066:3306"</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">        <span class="attr">hostname:</span> <span class="string">mysql-slave</span></span><br></pre></td></tr></table></figure><h3 id="3-主数据库配置"><a href="#3-主数据库配置" class="headerlink" title="3. 主数据库配置"></a>3. 主数据库配置</h3><pre><code>3.1 配置DockerfileDockerfile<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> mysql:<span class="number">5.7</span>.<span class="number">17</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> ./master/my.cnf /etc/mysql/my.cnf</span></span><br></pre></td></tr></table></figure>3.2 配置my.cnf文件my.cnf<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">## 设置server_id，一般设置为IP，注意要唯一</span><br><span class="line">server_id&#x3D;100  </span><br><span class="line">## 复制过滤：也就是指定哪个数据库不用同步（mysql库一般不同步）</span><br><span class="line">binlog-ignore-db&#x3D;mysql  </span><br><span class="line">## 开启二进制日志功能，可以随便取，最好有含义（关键就是这里了）</span><br><span class="line">log-bin&#x3D;replicas-mysql-bin  </span><br><span class="line">## 为每个session分配的内存，在事务过程中用来存储二进制日志的缓存</span><br><span class="line">binlog_cache_size&#x3D;1M  </span><br><span class="line">## 主从复制的格式（mixed,statement,row，默认格式是statement）</span><br><span class="line">binlog_format&#x3D;mixed  </span><br><span class="line">## 二进制日志自动删除&#x2F;过期的天数。默认值为0，表示不自动删除。</span><br><span class="line">expire_logs_days&#x3D;7  </span><br><span class="line">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span><br><span class="line">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span><br><span class="line">slave_skip_errors&#x3D;1062</span><br></pre></td></tr></table></figure></code></pre><h3 id="4-从数据库配置"><a href="#4-从数据库配置" class="headerlink" title="4. 从数据库配置"></a>4. 从数据库配置</h3><pre><code>4.1 配置DockerfileDockerfile<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> mysql:<span class="number">5.7</span>.<span class="number">17</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> ./slave/my.cnf /etc/mysql/my.cnf</span></span><br></pre></td></tr></table></figure></code></pre><hr><pre><code>4.2 配置my.cnf文件my.cnf<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">## 设置server_id，一般设置为IP，注意要唯一</span><br><span class="line">server_id&#x3D;101  </span><br><span class="line">## 复制过滤：也就是指定哪个数据库不用同步（mysql库一般不同步）</span><br><span class="line">binlog-ignore-db&#x3D;mysql  </span><br><span class="line">## 开启二进制日志功能，以备Slave作为其它Slave的Master时使用</span><br><span class="line">log-bin&#x3D;replicas-mysql-slave1-bin  </span><br><span class="line">## 为每个session 分配的内存，在事务过程中用来存储二进制日志的缓存</span><br><span class="line">binlog_cache_size&#x3D;1M  </span><br><span class="line">## 主从复制的格式（mixed,statement,row，默认格式是statement）</span><br><span class="line">binlog_format&#x3D;mixed  </span><br><span class="line">## 二进制日志自动删除&#x2F;过期的天数。默认值为0，表示不自动删除。</span><br><span class="line">expire_logs_days&#x3D;7  </span><br><span class="line">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span><br><span class="line">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span><br><span class="line">slave_skip_errors&#x3D;1062  </span><br><span class="line">## relay_log配置中继日志</span><br><span class="line">relay_log&#x3D;replicas-mysql-relay-bin  </span><br><span class="line">## log_slave_updates表示slave将复制事件写进自己的二进制日志</span><br><span class="line">log_slave_updates&#x3D;1  </span><br><span class="line">## 防止改变数据(除了特殊的线程)</span><br><span class="line">read_only&#x3D;1</span><br></pre></td></tr></table></figure></code></pre><h3 id="5-创建容器"><a href="#5-创建容器" class="headerlink" title="5. 创建容器"></a>5. 创建容器</h3><p>进入 <code>docker</code> 目录，运行 <code>docker-compose</code> 启动命令。<br>    <code>docker-compose up -d</code></p><p>如图所示，<code>MySQL</code> 主数据库和从数据库的容器创建成功。</p><p><img src= "/img/loading.gifs" data-src="/images/mysql/docker-compose_up-success.jpg" alt=""></p><p>分别配置主数据库和从数据库的连接信息如下：</p><ul><li>主数据库<br><img src= "/img/loading.gifs" data-src="/images/mysql/navicat-master-success.jpg" alt=""></li></ul><hr><ul><li>从数据库<br><img src= "/img/loading.gifs" data-src="/images/mysql/navicat-slave-success.jpg" alt=""></li></ul><h3 id="6-配置从数据库"><a href="#6-配置从数据库" class="headerlink" title="6. 配置从数据库"></a>6. 配置从数据库</h3><p>检查从库的起始状态<br>    <code>show master status;</code></p><p>如图所示，从数据库处于未同步复制状态。<br><img src= "/img/loading.gifs" data-src="/images/mysql/show-master-status.jpg" alt=""></p><p>检查主库状态<br>    <code>show master status;</code></p><p>记录从数据库 <code>binary-log</code> 的文件名和数据同步起始位置。<br>        *   File: replicas-mysql-bin.000003<br>        *   Position: 154<br>        <img src= "/img/loading.gifs" data-src="/images/mysql/binary-log.jpg" alt=""></p><p>从库配置主库信息</p><p>在从数据库上运行主数据库的相关配置 <code>sql</code> 进行主从关联</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CHANGE</span> <span class="keyword">MASTER</span> <span class="keyword">TO</span></span><br><span class="line">    MASTER_HOST=<span class="string">'mysql-master'</span>,</span><br><span class="line">    MASTER_USER=<span class="string">'root'</span>,</span><br><span class="line">    MASTER_PASSWORD=<span class="string">'root'</span>,</span><br><span class="line">    MASTER_LOG_FILE=<span class="string">'replicas-mysql-bin.000003'</span>,</span><br><span class="line">    MASTER_LOG_POS=<span class="number">154</span>;</span><br></pre></td></tr></table></figure><p>重新启动 <code>slave</code> 服务</p><p><code>stop slave;</code><br><code>start slave;</code></p><p>进一步检查从数据库的状态信息，两者已经进行数据同步关联。<br><img src= "/img/loading.gifs" data-src="/images/mysql/show-slave-status.jpg" alt=""></p><h3 id="7-创建目标表"><a href="#7-创建目标表" class="headerlink" title="7. 创建目标表"></a>7. 创建目标表</h3><p>在主数据库中创建一张测试数据表 <code>course</code> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for course</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`course`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`course`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`lesson_period`</span> <span class="keyword">double</span>(<span class="number">5</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`score`</span> <span class="keyword">double</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br></pre></td></tr></table></figure><p>主数据库和从数据库的数据处于同步状态，主从复制集群搭建完成。<br><img src= "/img/loading.gifs" data-src="/images/mysql/master-slave.jpg" alt=""></p><h1 id="MySQL的复制类型"><a href="#MySQL的复制类型" class="headerlink" title="MySQL的复制类型"></a>MySQL的复制类型</h1><h3 id="基于语句的复制"><a href="#基于语句的复制" class="headerlink" title="基于语句的复制"></a>基于语句的复制</h3><p>主服务器上面执行的语句在从服务器上面再执行一遍，在 MySQL-3.23 版本以后支持。<br><code>问题：时间上可能不完全同步造成偏差，执行语句的用户也可能是不同一个用户。</code></p><h3 id="基于行的复制"><a href="#基于行的复制" class="headerlink" title="基于行的复制"></a>基于行的复制</h3><p>把主服务器上面改变后的内容直接复制过去，而不关心到底改变该内容是由哪条语句引发的，在 MySQL-5.0 版本以后引入。<br><code>问题：比如一个工资表中有一万个用户，我们把每个用户的工资+1000，那么基于行的复制则要复制一万行的内容，由此造成的开销比较大，而基于语句的复制仅仅一条语句就可以了。</code></p><h3 id="混合类型的复制"><a href="#混合类型的复制" class="headerlink" title="混合类型的复制"></a>混合类型的复制</h3><p><code>MySQL</code> 默认使用 基于语句的复制，当 基于语句的复制 会引发问题的时候就会使用 基于行的复制，<code>MySQL</code> 会自动进行选择。</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis集群 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个故事讲完https</title>
      <link href="/2020/08/08/https/%E4%B8%80%E4%B8%AA%E6%95%85%E4%BA%8B%E8%AE%B2%E5%AE%8Chttps/"/>
      <url>/2020/08/08/https/%E4%B8%80%E4%B8%AA%E6%95%85%E4%BA%8B%E8%AE%B2%E5%AE%8Chttps/</url>
      
        <content type="html"><![CDATA[<h1 id="1-序言"><a href="#1-序言" class="headerlink" title="1. 序言"></a>1. 序言</h1><p>在开始之前，我们来虚构两个人物， 一个是位于中国的张大胖（怎么又是你？！）， 还有一个是位于米国的Bill (怎么还是你？！)。<br>这俩哥们隔着千山万水，通过网络联系上了， 两个人臭味相投，聊得火热。<br>此时正值米国大选， 张大胖亲切地“致电”Bill, 对米国总统大选的情况表示强烈地关注。 Bill则回电说谢谢关心米国人的事情我们米国人自己做主，不用你们歪果仁瞎操心……</p><p>张大胖继续“致电”说其实我们支持特朗普， 因为希拉里太情绪化，太难打交道了， 我们挺希望看到特朗普上台这样米国就会变成 <code>The Divided State of America ......</code></p><p>Bill 回电： 拉倒你吧你， 我们米国的政体有着强大的纠错性， 虽然有时候发展得慢， 有时候会走上岔路， 但很快就会回到正途，几百年来稳定得很，不像你们像坐了过山车一样…..</p><p>两个人越聊越投机，天南地北，海阔天空，还夹杂着不少隐私的话题。</p><h1 id="2-总是有一种被偷看的感觉"><a href="#2-总是有一种被偷看的感觉" class="headerlink" title="2. 总是有一种被偷看的感觉"></a>2. 总是有一种被偷看的感觉</h1><p>有一天， Bill 突然意识到： 坏了， 我们的通信是明文的， 这简直就是网络上裸奔啊， 任何一个不怀好意的家伙都可以监听我们通信，打开我们发送的数据包，窥探我们的隐私啊。</p><p>张大胖说： “你不早点说，我刚才是不是把我的微信号给你发过去了？ 我是不是告诉你我上周去哪儿旅游了?   估计已经被人截取了吧！”</p><p>Bill  提议： “要不我们做个数据的加密？ 每次传输之前， 你把消息用一个加密算法加密， 然后发到我这里以后我再解密， 这样别人就无法偷窥了，像这样： ”</p><p><img src= "/img/loading.gifs" data-src="/images/posts/tu1.png" alt=""></p><p>张大胖冰雪聪明，一看就明白了， 这<code>加密和解密算法是公开的，那个密钥是保密的</code>， 只有两人才知道， 这样生成的加密消息（密文） 别人就无法得知了。 他说： “Bill 老兄，你生成一个密钥， 然后把密钥发给我， 咱们这就开启加密消息， 让那些偷窥狂人们哭去吧！”</p><p>（码农翻身注：这叫<code>对称加密算法</code>， 因为加密和解密用的是同一个密钥）</p><p>一炷香功夫过去了， Bill 还是没有回音， 张大胖忍不住地催促： “快发啊？！！！”</p><p>Bill 终于回复了： “ 我感觉有一双眼睛正在虎视眈眈地盯着我们的通话， 如果我把密钥发给你， 也被他截取了， 那加密岂不白费工夫？”</p><p>张大胖沉默了， 是啊， 网络是不安全的， 这密钥怎么安全地发过来啊 ？　</p><p>“奥，对了，我下周要去米国旅游，到时候我们见一面，把密码确定下来，写到纸上，谁也偷不走， 这不就结了？”　</p><p>“哈哈， 这倒是终极解决之道 ”  Bill 笑了， “不过，我不仅仅和你聊天， 我还要和易卜拉欣，阿卜杜拉， 弗拉基米尔，克里斯托夫，玛格丽特， 桥本龙太郎， 李贤俊， 许木木，郭芙蓉，吕秀才等人通信， 我总不能打着飞的，满世界的和人交换密码吧？ ”</p><p>张大胖心里暗自佩服Bill同学的好友竟然遍布全球，看来他对加密通信的要求更加强烈啊！</p><p>可是这个加密解密算法需要的密钥双方必须得知道啊， 但是密钥又无法通过网络发送， 这该死的偷窥者！</p><h1 id="3-RSA-非对称加密"><a href="#3-RSA-非对称加密" class="headerlink" title="3. RSA : 非对称加密"></a>3. RSA : 非对称加密</h1><p>Bill 和 张大胖的通信无法加密，说话谨慎了不少， 直到有一天， 他们听说了一个叫做RSA的<code>非对称加密算法</code>，一下子来了灵感。</p><p>这个<code>RSA算法</code>非常有意思，它不是像之前的算法， 双方必须协商一个保密的密钥， 而是有一对儿钥匙， 一个是保密的，称为<code>私钥</code>，另外一个是公开的，称为<code>公钥</code>。</p><p>更有意思的是，<code>用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据， 只有对应的私钥才能解密。</code></p><p><img src= "/img/loading.gifs" data-src="/images/posts/tu2.png" alt=""></p><p>有了这两个漂亮的特性， 当张大胖给Bill发消息的时候， 就可以先用Bill的公钥去加密（反正Bill的公钥是公开的，地球人都知道）， 等到消息被Bill 收到后， 他就可以用自己的私钥去解密（只有Bill才能解开，私钥是保密的 ）</p><p><img src= "/img/loading.gifs" data-src="/images/posts/tu3.png" alt=""></p><p>反过来也是如此， 当Bill 想给张大胖发消息的时候，就用张大胖的公钥加密， 张大胖收到后，就用自己的私钥解密。</p><p>这样以来，通信安全固若金汤， 没有任何人能窥探他们的小秘密了。</p><h1 id="4-非对称加密-对称加密"><a href="#4-非对称加密-对称加密" class="headerlink" title="4. 非对称加密+对称加密"></a>4. 非对称加密+对称加密</h1><p>两人实验了几次，  张大胖说： “Bill  , 你有没有感觉这个RSA的加密和解密有点慢啊？”</p><p>Bill叹了口气 ：“是啊， 我也注意到了， 刚才搜了一下，这个RSA算法比之前的对称密钥算法要慢上百倍。我们就是加个密而已，现在搞得都没法用了”</p><p>“回到咱们最初的问题，我们想用一个密钥来加密通信，那个对称加密算法是非常快的，但是苦于密钥无法安全传输， 现在有了RSA ,我想可以结合一下， 分两步走　<code>(1) 我生成一个对称加密算法的密钥， 用RSA的方式安全发给你，  (2) 我们随后就不用RSA了， 只用这个密钥，利用对称加密算法来通信,  如何？ ”</code></p><p>Bill 说： “你小子可以啊， 这样以来既解决了密钥的传递问题， 又解决了RSA速度慢的问题，不错。”　</p><p>于是两人就安全地传递了对称加密的密钥， 用它来加密解密，果然快多了！</p><h1 id="5-中间人攻击"><a href="#5-中间人攻击" class="headerlink" title="5. 中间人攻击"></a>5. 中间人攻击</h1><p>张大胖把和Bill 聊天的情况给老婆汇报了一次。</p><p>老婆告诫他说： “你要小心啊， 你确定网络那边坐着的确实是Bill ?”</p><p>张大胖着急地辩解说：“肯定是他啊，我都有他的公钥，我们俩的通信都是加密的。”</p><p>老婆提醒道：＂假如啊，Bill给你发公钥的时候， 有个中间人，截取了Bill的公钥， 然后把自己的公钥发给了你，冒充Bill ，你发的消息就用中间人的公钥加了密，　那中间人不就可以解密看到消息了？＂</p><p>张大胖背后出汗了，是啊，这个中间人解密以后，还可以用Bill的公钥加密，发给Bill ,  Bill和我根本都意识不到， 还以为我们在安全传输呢！</p><p><img src= "/img/loading.gifs" data-src="/images/posts/tu4.png" alt=""></p><p><code>看来问题出现在公钥的分发上！</code>  虽然这个东西是公开的， 但是在别有用心的人看来，截取以后还可以干坏事 ！</p><h1 id="6-你到底是谁？"><a href="#6-你到底是谁？" class="headerlink" title="6. 你到底是谁？"></a>6. 你到底是谁？</h1><p>但是怎么安全地分发公钥呢？ 似乎又回到了最初的问题： 怎么安全的保护密钥？</p><p>可是似乎和最初的问题还不一样，这一次的公钥不用保密，但是一定得有个办法<code>声明这个公钥确实是Bill的</code>， 而不是别人的。</p><p>怎么声明呢？</p><p>张大胖突然想到： 现实中有公证处，它提供的公证材料大家都信任，那在网络世界也可以建立一个这样的具备公信力的认证中心， 这个中心给大家颁发一个证书， 用于证明一个人的身份。</p><p>这个证书里除了包含一个人的基本信息之外，还有包括最关键的一环：这个人的公钥！</p><p>这样以来我拿到证书就可以安全地取到公钥了 ！ 完美！</p><p>可是Bill 马上泼了一盆冷水：证书怎么安全传输？ 要是证书传递的过程中被篡改了怎么办？</p><p>张大胖心里不由地咒骂起来： 我操， 这简直就是鸡生蛋，蛋生鸡的问题啊。</p><p>天无绝人之路， 张大胖很快就找到了突破口： <code>数字签名。</code></p><p>简单来讲是这样的， Bill可以把他的公钥和个人信息用一个Hash算法生成一个消息摘要， 这个Hash算法有个极好的特性，<code>只要输入数据有一点点变化，那生成的消息摘要就会有巨变</code>，这样就可以防止别人修改原始内容。</p><p><img src= "/img/loading.gifs" data-src="/images/posts/tu5.png" alt=""></p><p>可是作为攻击者的中间人笑了： “虽然我没办法改公钥，但是我可以把整个原始信息都替换了， 生成一个新的消息摘要， 你不还是辨别不出来？”</p><p>张大胖说你别得意的太早 ， 我们会让有公信力的认证中心<code>（简称CA）</code>用它的私钥对消息摘要加密，形成签名：</p><p><img src= "/img/loading.gifs" data-src="/images/posts/tu6.png" alt=""></p><p>这还不算， 还把原始信息和数据签名合并， 形成一个全新的东西，叫做“<code>数字证书</code>”</p><p><img src= "/img/loading.gifs" data-src="/images/posts/tu7.png" alt=""></p><p>张大胖接着说：当Bill把他的证书发给我的时候， 我就用同样的Hash 算法， 再次生成消息摘要，然后用CA的公钥对数字签名解密， 得到CA创建的消息摘要， 两者一比，就知道有没有人篡改了！</p><p>如果没人篡改， 我就可以安全的拿到Bill的公钥喽，有了公钥， 后序的加密工作就可以开始了。</p><p>虽然很费劲， 但是为了防范你们这些偷窥者，实在是没办法啊。</p><p><img src= "/img/loading.gifs" data-src="/images/posts/tu8.png" alt=""></p><p>中间人恶狠狠地说： “算你小子狠！ 等着吧，我还有别的招。 对了，我且问你， 你这个CA的公钥怎么拿到？　难道不怕我在你传输ＣＡ公钥的时候发起中间人攻击吗？　如果我成功的伪装成了ＣＡ，你这一套体系彻底玩完。”</p><p>张大胖语塞了，折腾了半天，又回到了公钥安全传输的问题！</p><p>不过转念一想，想解决鸡生蛋，蛋生鸡的问题必须得打破这个怪圈才行，我必须得信任ＣＡ，并且通过安全的的方式获取他们的公钥，这样才能把游戏玩下去。</p><p>（注：这些ＣＡ本身也有证书来证明自己的身份，并且ＣＡ的信用是像树一样分级的，高层的ＣＡ给底层的ＣＡ做信用背书，而操作系统／浏览器中会内置一些顶层的ＣＡ的证书，相当于你自动信任了他们。　这些顶层的ＣＡ证书一定得安全地放入操作系统／浏览器当中，否则世界大乱。）</p><h1 id="7-https"><a href="#7-https" class="headerlink" title="7. https"></a>7. https</h1><p>终于可以介绍https了，前面已经介绍了https的原理， 你把张大胖替换成浏览器， 把Bill 替换成某个网站就行了。</p><p>一个<code>简化的（例如下图没有包含Pre-Master Secret）https流程图</code>是这样的， 如果你理解了前面的原理，这张图就变得非常简单：</p><p><img src= "/img/loading.gifs" data-src="/images/posts/tu9.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> https </category>
          
      </categories>
      
      
        <tags>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决hexo博客文章太长导致的显示不全的问题</title>
      <link href="/2020/07/24/blog/%E8%A7%A3%E5%86%B3hexo%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%A4%AA%E9%95%BF%E5%AF%BC%E8%87%B4%E7%9A%84%E6%98%BE%E7%A4%BA%E4%B8%8D%E5%85%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2020/07/24/blog/%E8%A7%A3%E5%86%B3hexo%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%A4%AA%E9%95%BF%E5%AF%BC%E8%87%B4%E7%9A%84%E6%98%BE%E7%A4%BA%E4%B8%8D%E5%85%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h1><p>前两天准备发布上一篇介绍<code>https</code>的文章,结果写好markdown之后本地测试发现问题:</p><ul><li>文章显示最后内容突然缺失</li><li>导航栏，底部的返回顶部按钮均异常</li><li>查看网页源代码，发现内容消失的地方之后内容全部是空格</li></ul><p>尝试解决问题,发现文章变短显示就正常,使用hexo新建blog,测试长文显示OK,换上同样的主题也没问题,说明是我的环境配置哪里出错.</p><h1 id="2-解决"><a href="#2-解决" class="headerlink" title="2. 解决"></a>2. 解决</h1><p>折腾几天,重装hexo-xx相关库,更新hexo版本,库版本,拿出错的配置和正常的去比较,终于发现问题出现在<br>package.json的“hexo-browsersync”: “^0.3.0”, 将这一行注释掉或者删除就OK<br>然后来到这个库的github的issues,发现不少人也遇到了这个问题,可惜我是找了好久才发现</p><h1 id="3-其他"><a href="#3-其他" class="headerlink" title="3. 其他"></a>3. 其他</h1><p>另外总结其他遇到的问题</p><h3 id="hexo-server报错："><a href="#hexo-server报错：" class="headerlink" title="hexo server报错："></a>hexo server报错：</h3><p><code>Cannot GET /</code></p><p>解决方案：<code>npm audit fix</code> 查看缺少哪些模块，<code>npm install xxx</code> 安装</p><h3 id="检查hexo相关库："><a href="#检查hexo相关库：" class="headerlink" title="检查hexo相关库："></a>检查hexo相关库：</h3><ul><li>npm install -g npm-check</li><li>npm-check</li><li>npm install -g npm-upgrade</li><li>npm-upgrade</li><li>npm install hexo –savess</li></ul>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git详解</title>
      <link href="/2020/07/24/git/git%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/07/24/git/git%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Git是什么（what）"><a href="#1-Git是什么（what）" class="headerlink" title="1. Git是什么（what）"></a>1. Git是什么（what）</h1><h2 id="（-）概述"><a href="#（-）概述" class="headerlink" title="（-）概述"></a>（-）概述</h2><p>Git是分布式版本控制系统，与SVN类似的集中化版本控制系统相比，集中化版本控制系统如果中央服务器宕机则会影响数据和协同开发。</p><p>Git是分布式的版本控制系统，客户端不只是提取最新版本的快照，而且将整个代码仓库镜像复制下来。如果任何协同工作用的服务器发生故障了，也可以用任何一个代码仓库来恢复。而且在协作服务器宕机期间，你也可以提交代码到本地仓库，当协作服务器正常工作后，你再将本地仓库同步到远程仓库。</p><h2 id="（二）特性"><a href="#（二）特性" class="headerlink" title="（二）特性"></a>（二）特性</h2><ul><li>能够对文件版本控制和多人协作开发</li><li>拥有强大的分支特性，所以能够灵活地以不同的工作流协同开发</li><li>分布式版本控制系统，即使协作服务器宕机，也能继续提交代码或文件到本地仓库，当协作服务器恢复正常工作时，再将本地仓库同步到远程仓库。</li><li>当团队中某个成员完成某个功能时，通过<code>pull request</code>操作来通知其他团队成员，其他团队成员能够<code>review code</code>后再合并代码。</li></ul><h1 id="2-为什么要用Git（why）"><a href="#2-为什么要用Git（why）" class="headerlink" title="2. 为什么要用Git（why）"></a>2. 为什么要用Git（why）</h1><ul><li>能够对文件版本控制和多人协作开发</li><li>拥有强大的分支特性，所以能够灵活地以不同的工作流协同开发</li><li>分布式版本控制系统，即使协作服务器宕机，也能继续提交代码或文件到本地仓库，当协作服务器恢复正常工作时，再将本地仓库同步到远程仓库。</li><li>当团队中某个成员完成某个功能时，通过pull request操作来通知其他团队成员，其他团队成员能够review code后再合并代码。</li></ul><h1 id="3-如何使用Git（how）"><a href="#3-如何使用Git（how）" class="headerlink" title="3. 如何使用Git（how）"></a>3. 如何使用Git（how）</h1><h2 id="（-）Git的命令"><a href="#（-）Git的命令" class="headerlink" title="（-）Git的命令"></a>（-）Git的命令</h2><p><img src= "/img/loading.gifs" data-src="/images/git/git2.png" alt=""></p><ul><li>Workspace：工作区</li><li>Index / Stage：暂存区</li><li>Repository：仓库区（或本地仓库）</li><li>Remote：远程仓库</li></ul><h3 id="3-1-新建代码库"><a href="#3-1-新建代码库" class="headerlink" title="3.1 新建代码库"></a>3.1 新建代码库</h3><p>#在当前目录新建一个Git代码库<br><code>git init</code><br>#新建一个目录，将其初始化为Git代码库<br><code>git init [project-name]</code><br>#下载一个项目和它的整个代码历史<br><code>git clone [url]</code></p><h3 id="3-2-配置"><a href="#3-2-配置" class="headerlink" title="3.2 配置"></a>3.2 配置</h3><p>Git的设置文件为.gitconfig，它可以在用户主目录行哦啊（全局配置），也可以在项目目录下（项目配置）。</p><p>#显示当前的Git配置<br><code>git config --list</code><br>#编辑Git配置文件<br><code>git config -e [--global]</code><br>#设置提交代码时的用户信息<br><code>git config [--global] user.name &quot;[name]&quot;</code><br><code>git config [--global] user.email &quot;[email address]&quot;</code></p><h3 id="3-3-增加-删除文件"><a href="#3-3-增加-删除文件" class="headerlink" title="3.3 增加/删除文件"></a>3.3 增加/删除文件</h3><p>#添加指定文件到暂存区<br><code>git add [file1] [file2] ...</code><br>#添加指定目录到暂存区，包括子目录<br><code>git add [dir]</code><br>#添加当前目录的所有文件到暂存区<br><code>git add .</code><br>#添加每个变化前，都会要求确认<br>#对于同一个文件的多处变化，可以实现分次提交<br><code>git add -p</code><br>#删除工作区文件，并且将这次删除放入暂存区<br><code>git rm [file1] [file2] ...</code><br>#停止追踪指定文件，但该文件会保留在工作区<br><code>git rm --cached [file]</code><br>#改名文件，并且将这个改名放入暂存区<br><code>git mv [file-original] [file-renamed]</code></p><h3 id="3-4-代码提交"><a href="#3-4-代码提交" class="headerlink" title="3.4 代码提交"></a>3.4 代码提交</h3><p>#提交暂存区到仓库区<br><code>git commit -m [message]</code><br>#提交暂存区的指定文件到仓库区<br><code>git commit [file1] [file2] ... -m [message]</code><br>#提交工作区自上次commit之后的变化，直接到仓库区<br><code>git commit -a</code><br>#提交时显示所有diff信息<br><code>git commit -v</code><br>#使用一次新的commit，替代上一次提交<br>#如果代码没有任何新变化，则用来改写上一次commit的提交信息<br><code>git commit --amend -m [message]</code><br>#重做上一次commit，并包括指定文件的新变化<br><code>git commit --amend [file1] [file2] ...</code></p><h3 id="3-5-分支"><a href="#3-5-分支" class="headerlink" title="3.5 分支"></a>3.5 分支</h3><p>#列出所有本地分支<br><code>git branch</code><br>#列出所有本地分支<br><code>git branch -a</code><br>#新建一个分支，但依然停留在当前分支<br><code>git branch [branch-name]</code><br>#新建一个分支，并切换到该分支<br><code>git checkout -b [branch]</code><br>#新建一个分支，指向指定commit<br><code>git branch [branch] [commit]</code><br>#新建一个分支，与指定的远程分支建立追踪关系<br><code>git branch --track [branch] [remote-branch]</code><br>#切换到指定分支，并更新工作区<br><code>git checkout [branch-name]</code><br>#切换到上一个分支<br><code>git checkout -</code><br>#建立追踪关系，在现有分支与指定的远程分支之间<br><code>git branch --set-upstream [branch] [remote-branch]</code><br>#合并指定分支到当前分支<br><code>git merge [branch]</code><br>#选择一个commit，合并进当前分支<br><code>git cherry-pick [commit]</code><br>#删除分支<br><code>git push origin --delete [branch-name]</code><br><code>git branch -dr [remote/branch]</code></p><h3 id="3-6-标签"><a href="#3-6-标签" class="headerlink" title="3.6 标签"></a>3.6 标签</h3><p>#列出所有tag<br><code>git tag</code><br>#新建一个tag在当前commit<br><code>git tag [tag]</code><br>#新建一个tag在指定commit<br><code>git tag [tag] [commit]</code><br>#删除本地tag<br><code>git tag -d [tag]</code><br>#删除远程tag<br><code>git push origin :refs/tags/[tagName]</code><br>#查看tag信息<br><code>git show [tag]</code><br>#提交指定tag<br><code>git push [remote] [tag]</code><br>#提交所有tag<br><code>git push [remote] --tags</code><br>#新建一个分支，指向某个tag<br><code>git checkout -b [branch] [tag]</code></p><h3 id="3-7-查看信息"><a href="#3-7-查看信息" class="headerlink" title="3.7 查看信息"></a>3.7 查看信息</h3><p>#列出所有tag<br><code>git tag</code><br>#新建一个tag在当前commit<br><code>git tag [tag]</code><br>#新建一个tag在指定commit<br><code>git tag [tag] [commit]</code><br>#删除本地tag<br><code>git tag -d [tag]</code><br>#删除远程tag<br><code>git push origin :refs/tags/[tagName]</code><br>#查看tag信息<br><code>git show [tag]</code><br>#提交指定tag<br><code>git push [remote] [tag]</code><br>#提交所有tag<br><code>git push [remote] --tags</code><br>#新建一个分支，指向某个tag<br><code>git checkout -b [branch] [tag]</code></p><h3 id="3-8-远程同步"><a href="#3-8-远程同步" class="headerlink" title="3.8 远程同步"></a>3.8 远程同步</h3><p>#下载远程仓库的所有变动<br><code>git fetch [remote]</code><br>#显示所有远程仓库<br><code>git remote -v</code><br>#显示某个远程仓库的信息<br><code>git remote show [remote]</code><br>#增加一个新的远程仓库，并命名<br><code>git remote add [shortname] [url]</code><br>#取回远程仓库的变化，并与本地分支合并<br><code>git pull [remote] [branch]</code><br>#上传本地指定分支到远程仓库<br><code>git push [remote] [branch]</code><br>#强行推送当前分支到远程仓库，即使有冲突<br><code>git push [remote] --force</code><br>#推送所有分支到远程仓库<br><code>git push [remote] --all</code></p><h3 id="3-9-撤销"><a href="#3-9-撤销" class="headerlink" title="3.9 撤销"></a>3.9 撤销</h3><p>#恢复暂存区的指定文件到工作区<br><code>git checkout [file]</code><br>#恢复某个commit的指定文件到暂存区和工作区<br><code>git checkout [commit] [file]</code><br>#恢复暂存区的所有文件到工作区<br><code>git checkout .</code><br>#重置暂存区的指定文件，与上一次commit保持一致，但工作区不变<br><code>git reset [file]</code><br>#重置暂存区与工作区，与上一次commit保持一致<br><code>git reset --hard</code><br>#重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变<br><code>git reset [commit]</code><br>#重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致<br><code>git reset --hard [commit]</code><br>#重置当前HEAD为指定commit，但保持暂存区和工作区不变<br><code>git reset --keep [commit]</code><br>#新建一个commit，用来撤销指定commit<br>#后者的所有变化都将被前者抵消，并且应用到当前分支<br><code>git revert [commit]</code><br>#暂时将未提交的变化移除，稍后再移入<br><code>git stash</code><br><code>git stash pop</code></p><h3 id="3-10-其他"><a href="#3-10-其他" class="headerlink" title="3.10 其他"></a>3.10 其他</h3><p>#生成一个可供发布的压缩包<br><code>git archive</code><br>#设置换行符为LF<br><code>git config --global core.autocrlf false</code><br>#拒绝提交包含混合换行符的文件<br><code>git config --global core.safecrlf true</code></p><h1 id="4-Git命令思维导图"><a href="#4-Git命令思维导图" class="headerlink" title="4. Git命令思维导图"></a>4. Git命令思维导图</h1><p><img src= "/img/loading.gifs" data-src="/images/git/git3.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo + github 快速搭建博客</title>
      <link href="/2020/07/01/blog/hexo+github%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2020/07/01/blog/hexo+github%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo-github-快速搭建博客"><a href="#hexo-github-快速搭建博客" class="headerlink" title="hexo + github 快速搭建博客"></a>hexo + github 快速搭建博客</h1><p>话不多说，咱们直接进入主题～</p><h2 id="1-新建城池"><a href="#1-新建城池" class="headerlink" title="1.新建城池"></a>1.新建城池</h2><p>既然要给人访问，如果没有存放代码的地方，既不是白日做梦了，首先上 全球最大同性交友网站 <code>github</code> 新建一个仓库，仓库名必须为 <code>&lt;user-name&gt;.github.io</code>, 其中 <code>&lt;user-name&gt;</code> 就是我们github的昵称，<br>注意必须一样，不能自定义，不要问我为什么，问了我也不会说。</p><h2 id="2-手握神器"><a href="#2-手握神器" class="headerlink" title="2.手握神器"></a>2.手握神器</h2><p>打开命令行，输入下面的命令，全局安装神奇 <code>hexo</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g</span><br></pre></td></tr></table></figure><h2 id="3-组建大军"><a href="#3-组建大军" class="headerlink" title="3. 组建大军"></a>3. 组建大军</h2><p><code>hexo</code> 神器使用口诀如下 急急如律令，嘿嘿哈。。。sorry sorry 跑题了，口诀如下，所有口诀掐完，紧跟 <code>hexo s</code>，之后在浏览器访问 <code>localhost:4000</code> 神器搭配，手速要快。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init &#x2F;&#x2F; 初始化</span><br><span class="line"></span><br><span class="line">hexo s &#x2F;&#x2F; 本地服务启动</span><br></pre></td></tr></table></figure><p>我们的文件夹下的文件,主要关注以下几个文件</p><ul><li>source 里面存放我们的页面和文章 _post 下都是文章，其他则为页面</li><li>themes 里面是我们下载的主题</li><li>public 里面是我们编译后的文件</li><li>_config.yml 全局的一些配置</li></ul><h2 id="4-神器，城池，大军都有，该去收割一波了"><a href="#4-神器，城池，大军都有，该去收割一波了" class="headerlink" title="4.神器，城池，大军都有，该去收割一波了"></a>4.神器，城池，大军都有，该去收割一波了</h2><p>虽然此时咱们只要默认的一篇 <code>Hello World</code>, 也不能阻止我们想做最靓的仔的决心，首先在根目录下 <code>_config.yml</code>找到 <code>deploy</code>字段，然后使用绝技 <code>copy</code> 大法</p><h4 id="注意点，-github-记得这是-SSH-key-免密登陆-就不用手动了，不会的同学下课记得补习。"><a href="#注意点，-github-记得这是-SSH-key-免密登陆-就不用手动了，不会的同学下课记得补习。" class="headerlink" title="注意点， github 记得这是 SSH key 免密登陆 就不用手动了，不会的同学下课记得补习。"></a>注意点， github 记得这是 SSH key 免密登陆 就不用手动了，不会的同学下课记得补习。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: &lt;你的仓库地址&gt; # https:&#x2F;&#x2F;github.com&#x2F;14138993&#x2F;14138993.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>施展完毕，不过我们需要喝瓶 脉动 补充下体力进行最后的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 下载自动提交的 npm 包</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>是时候向世界证明我们的存在了，下面开始公布</p><p>ps: 不想手动敲这么多命令，下方有配置教你怎么偷懒哟</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &#x2F;&#x2F; 清除 pubkic</span><br><span class="line"></span><br><span class="line">hexo g &#x2F;&#x2F; 编译</span><br><span class="line"></span><br><span class="line">hexo d &#x2F;&#x2F; 提交</span><br></pre></td></tr></table></figure><h2 id="5-收获成果"><a href="#5-收获成果" class="headerlink" title="5. 收获成果"></a>5. 收获成果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问 https:&#x2F;&#x2F;&lt;user-name&gt;.github.io&#x2F; 查看效果。</span><br></pre></td></tr></table></figure><h3 id="课外知识点"><a href="#课外知识点" class="headerlink" title="课外知识点"></a>课外知识点</h3><ol><li>如何创建新页面，新文章？</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo new post xxx(文件名) &#x2F;&#x2F; 创建新文章</span><br><span class="line"></span><br><span class="line">hexo new page xxx(文件名) &#x2F;&#x2F; 创建新页面</span><br></pre></td></tr></table></figure><p>这里提一下 关于tags link categories 这三个页面 需要在对应md文件里增type 这个属性 值就是本身名字 例如 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">title: link</span><br><span class="line">type: link</span><br></pre></td></tr></table></figure><ol start="2"><li>更换主题皮肤</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 下载主题到themes文件夹下</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;butterfly&#x2F;hexo-theme-butterfly xxx&#x2F;themes</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 修改 根目录_config.yml 配置</span><br><span class="line">theme: 你的主题名称</span><br></pre></td></tr></table></figure><ol start="3"><li>中文乱码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 修改 根目录_config.yml 配置</span><br><span class="line">language: zh-CN &#x2F;&#x2F; 改为中文</span><br></pre></td></tr></table></figure><ol start="4"><li>部署优化</li></ol><p>国际惯例，能偷懒的绝不多写一个字母😂, 修改咱们的<code>package.json</code> 在 <code>script</code> 里增加命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;dev&quot;: &quot;hexo s&quot;, &#x2F;&#x2F; 本地启动</span><br><span class="line">&quot;build&quot;: &quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo deploy&quot; &#x2F;&#x2F; 一键部署到github</span><br></pre></td></tr></table></figure><p>到此搭建博客已经完成，但是你可能觉得美中不足</p><h2 id="优化点"><a href="#优化点" class="headerlink" title="优化点"></a>优化点</h2><h3 id="个人域名解析到github域名"><a href="#个人域名解析到github域名" class="headerlink" title="个人域名解析到github域名"></a>个人域名解析到github域名</h3><ol><li>上传到github后在根目录创建 <code>CNAME</code> 里面为自己的域名地址</li><li>在域名服务商将域名解析 不会的请百度，这里就不细说了</li></ol><h3 id="主题优化，评论功能等"><a href="#主题优化，评论功能等" class="headerlink" title="主题优化，评论功能等"></a>主题优化，评论功能等</h3><ol><li>直接去hexo 官网挑选喜欢的主题，一般主题都有详细的配置教程，跟着教程做</li><li>我的博客使用的是 <code>butterfly</code> 如果你觉得喜欢，或者觉得功能满足你，不想自己琢磨，可以直接<a href="https://github.com/14138993/book-config.git" target="_blank" rel="noopener">Fork</a> 一键使用</li><li>评论系统 我使用的是 <a href="https://valine.js.org/quickstart.html" target="_blank" rel="noopener">valine</a>, 如果你是fork我的 需要在 <code>source &gt; _data &gt; butterfly.yml</code> 里 <code>valine</code> 配置你的 <code>appID</code> 和 <code>appKey</code></li></ol><p>谢谢，到此结束</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
