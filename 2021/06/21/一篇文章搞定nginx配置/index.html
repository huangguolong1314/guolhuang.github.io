<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>nginx详解 | guolhuang</title><meta name="description" content="目录 安装nginx nginx配置 基本结构 主要配置含义 nginx.conf配置文件的语法规则 内置变量 常用命令 配置nginx开机自启 配置nginx全局可用   nginx常用功能配置 反向代理 访问控制 6种负载均衡策略 gzip压缩 HTTP服务器 动静分离 请求限制 正向代理 图片防盗链 适配PC或移动设备 设置耳机域名 配置HTTPS 配置HTTP转HTTPS 单页面项目his"><meta name="keywords" content="https"><meta name="author" content="guolhuang"><meta name="copyright" content="guolhuang"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/caihong.png"><link rel="canonical" href="https://huangguolong1314.github.io/2021/06/21/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%90%9E%E5%AE%9Anginx%E9%85%8D%E7%BD%AE/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="nginx详解"><meta property="og:url" content="https://huangguolong1314.github.io/2021/06/21/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%90%9E%E5%AE%9Anginx%E9%85%8D%E7%BD%AE/"><meta property="og:site_name" content="guolhuang"><meta property="og:description" content="目录 安装nginx nginx配置 基本结构 主要配置含义 nginx.conf配置文件的语法规则 内置变量 常用命令 配置nginx开机自启 配置nginx全局可用   nginx常用功能配置 反向代理 访问控制 6种负载均衡策略 gzip压缩 HTTP服务器 动静分离 请求限制 正向代理 图片防盗链 适配PC或移动设备 设置耳机域名 配置HTTPS 配置HTTP转HTTPS 单页面项目his"><meta property="og:image" content="https://huangguolong1314.github.io/images/nginx/cover.png"><meta property="article:published_time" content="2021-06-21T07:51:00.000Z"><meta property="article:modified_time" content="2022-02-10T09:01:49.574Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="prev" title="MySql学习 —— 子查询(where、from、exists) 及 连接查询(left join、right join、inner join、union join)" href="https://huangguolong1314.github.io/2022/02/09/mySql%E5%AD%A6%E4%B9%A0/"><link rel="next" title="docker-compose搭建MySQL主从复制集群" href="https://huangguolong1314.github.io/2020/09/02/docker-compose%E6%90%AD%E5%BB%BAMySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E9%9B%86%E7%BE%A4/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: {"languages":{"author":"作者: guolhuang","link":"链接: ","source":"来源: guolhuang","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/css/custom.min.css"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="guolhuang" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">7</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">4</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/leave/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#目录"><span class="toc-number">1.</span> <span class="toc-text">目录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#安装nginx"><span class="toc-number">2.</span> <span class="toc-text">安装nginx</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#nginx配置"><span class="toc-number">3.</span> <span class="toc-text">nginx配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本结构"><span class="toc-number">3.0.1.</span> <span class="toc-text">基本结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#主要配置含义"><span class="toc-number">3.0.2.</span> <span class="toc-text">主要配置含义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nginx-conf-配置文件的语法规则"><span class="toc-number">3.0.3.</span> <span class="toc-text">nginx.conf 配置文件的语法规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内置变量"><span class="toc-number">3.0.4.</span> <span class="toc-text">内置变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常用命令"><span class="toc-number">3.0.5.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#配置-nginx-开启自启"><span class="toc-number">3.0.6.</span> <span class="toc-text">配置 nginx 开启自启</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过开机启动命令脚本实现开机自启"><span class="toc-number">3.0.7.</span> <span class="toc-text">通过开机启动命令脚本实现开机自启</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#配置-nginx-全局可用"><span class="toc-number">3.0.8.</span> <span class="toc-text">配置 nginx 全局可用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#nginx-常用功能"><span class="toc-number">4.</span> <span class="toc-text">nginx 常用功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#反向代理"><span class="toc-number">4.0.1.</span> <span class="toc-text">反向代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#访问控制"><span class="toc-number">4.0.2.</span> <span class="toc-text">访问控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#负载均衡"><span class="toc-number">4.0.3.</span> <span class="toc-text">负载均衡</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#轮训策略（默认）"><span class="toc-number">4.0.3.1.</span> <span class="toc-text">轮训策略（默认）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#根据服务器权重"><span class="toc-number">4.0.3.2.</span> <span class="toc-text">根据服务器权重</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#客户端-id-绑定（ip-hash）"><span class="toc-number">4.0.3.3.</span> <span class="toc-text">客户端 id 绑定（ip_hash）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最小连接数策略"><span class="toc-number">4.0.3.4.</span> <span class="toc-text">最小连接数策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最快响应时间策略（依赖于第三方-NGINX-Plus）"><span class="toc-number">4.0.3.5.</span> <span class="toc-text">最快响应时间策略（依赖于第三方 NGINX Plus）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#按访问url的hash结果（第三方）"><span class="toc-number">4.0.3.6.</span> <span class="toc-text">按访问url的hash结果（第三方）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gzip-压缩"><span class="toc-number">4.0.4.</span> <span class="toc-text">gzip 压缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-服务器"><span class="toc-number">4.0.5.</span> <span class="toc-text">HTTP 服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动静分离"><span class="toc-number">4.0.6.</span> <span class="toc-text">动静分离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请求限制"><span class="toc-number">4.0.7.</span> <span class="toc-text">请求限制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#通过-limit-req-zone-限制请求数"><span class="toc-number">4.0.7.1.</span> <span class="toc-text">通过 limit_req_zone 限制请求数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#通过-limit-conn-zone-限制并发连接数"><span class="toc-number">4.0.7.2.</span> <span class="toc-text">通过 limit_conn_zone 限制并发连接数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#正向代理"><span class="toc-number">4.0.8.</span> <span class="toc-text">正向代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图片防盗链"><span class="toc-number">4.0.9.</span> <span class="toc-text">图片防盗链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#适配-PC-或移动设备"><span class="toc-number">4.0.10.</span> <span class="toc-text">适配 PC 或移动设备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置二级域名"><span class="toc-number">4.0.11.</span> <span class="toc-text">设置二级域名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#配置-HTTPS"><span class="toc-number">4.0.12.</span> <span class="toc-text">配置 HTTPS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#配置-HTTP-转-HTTPS"><span class="toc-number">4.0.13.</span> <span class="toc-text">配置 HTTP 转 HTTPS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单页面项目-history-路由配置"><span class="toc-number">4.0.14.</span> <span class="toc-text">单页面项目 history 路由配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#配置高可用集群（双机热备）"><span class="toc-number">4.0.15.</span> <span class="toc-text">配置高可用集群（双机热备）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#其它功能和技巧"><span class="toc-number">5.</span> <span class="toc-text">其它功能和技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#代理缓存"><span class="toc-number">5.0.1.</span> <span class="toc-text">代理缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#访问日志"><span class="toc-number">5.0.2.</span> <span class="toc-text">访问日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#错误日志"><span class="toc-number">5.0.3.</span> <span class="toc-text">错误日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态资源服务器"><span class="toc-number">5.0.4.</span> <span class="toc-text">静态资源服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#禁止指定-user-agent"><span class="toc-number">5.0.5.</span> <span class="toc-text">禁止指定 user_agent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请求过滤"><span class="toc-number">5.0.6.</span> <span class="toc-text">请求过滤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#根据请求类型过滤"><span class="toc-number">5.0.6.1.</span> <span class="toc-text">根据请求类型过滤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#根据状态码过滤"><span class="toc-number">5.0.6.2.</span> <span class="toc-text">根据状态码过滤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#根据-URL-名称过滤"><span class="toc-number">5.0.6.3.</span> <span class="toc-text">根据 URL 名称过滤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ab-命令"><span class="toc-number">5.0.6.4.</span> <span class="toc-text">ab 命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#泛域名路径分离"><span class="toc-number">5.0.6.5.</span> <span class="toc-text">泛域名路径分离</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#泛域名转发"><span class="toc-number">5.0.6.6.</span> <span class="toc-text">泛域名转发</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#常见问题"><span class="toc-number">6.</span> <span class="toc-text">常见问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#nginx-中怎么设置变量"><span class="toc-number">6.0.1.</span> <span class="toc-text">nginx 中怎么设置变量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#附-nginx-内置预定义变量"><span class="toc-number">7.</span> <span class="toc-text">附 nginx 内置预定义变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#附-nginx-模块"><span class="toc-number">8.</span> <span class="toc-text">附 nginx 模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#nginx-模块分类"><span class="toc-number">8.0.1.</span> <span class="toc-text">nginx 模块分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模块清单"><span class="toc-number">8.0.2.</span> <span class="toc-text">模块清单</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标准-HTTP-模块"><span class="toc-number">8.0.3.</span> <span class="toc-text">标准 HTTP 模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可选-HTTP-模块"><span class="toc-number">8.0.4.</span> <span class="toc-text">可选 HTTP 模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#邮件服务模块"><span class="toc-number">8.0.5.</span> <span class="toc-text">邮件服务模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第三方模块"><span class="toc-number">8.0.6.</span> <span class="toc-text">第三方模块</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/nginx/cover.png)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">guolhuang</a></span><span class="pull-right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/leave/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">nginx详解</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2021-06-21 15:51:00"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2021-06-21</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2022-02-10 17:01:49"><i class="fas fa-history fa-fw"></i> 更新于 2022-02-10</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE/">网络通讯协议</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li>安装nginx</li>
<li>nginx配置<ul>
<li>基本结构</li>
<li>主要配置含义</li>
<li>nginx.conf配置文件的语法规则</li>
<li>内置变量</li>
<li>常用命令</li>
<li>配置nginx开机自启</li>
<li>配置nginx全局可用</li>
</ul>
</li>
<li>nginx常用功能配置<ul>
<li>反向代理</li>
<li>访问控制</li>
<li>6种负载均衡策略</li>
<li>gzip压缩</li>
<li>HTTP服务器</li>
<li>动静分离</li>
<li>请求限制</li>
<li>正向代理</li>
<li>图片防盗链</li>
<li>适配PC或移动设备</li>
<li>设置耳机域名</li>
<li>配置HTTPS</li>
<li>配置HTTP转HTTPS</li>
<li>单页面项目history路由配置</li>
<li>配置最高可用集群（双机热备）</li>
</ul>
</li>
<li>其它功能和技巧配置<ul>
<li>代理缓存</li>
<li>访问日志</li>
<li>错误日志</li>
<li>静态资源服务器</li>
<li>禁止指定user_agent</li>
<li>请求过滤</li>
<li>ab命令</li>
<li>泛域名路径分离</li>
<li>泛域名转发</li>
</ul>
</li>
<li>附nginx模块<ul>
<li>nginx模块分类</li>
<li>模块清单</li>
</ul>
</li>
</ul>
<hr>
<h1 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h1><p>下载nginx的压缩包文件到根目录，官网下载地址：nginx.org/download/nginx-x.xx.xx.tar.gz<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum update  # 更新系统软件</span><br><span class="line">cd &#x2F;</span><br><span class="line">wget nginx.org&#x2F;download&#x2F;nginx-1.22.2.tar.gz</span><br></pre></td></tr></table></figure><br>解压tar.gz压缩包文件，进去nginx-1.22.2<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf nginx-1.22.2.tar.gz</span><br><span class="line">cd nginx-1.22.2</span><br></pre></td></tr></table></figure><br>进入文件夹后进行配置检查<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure</span><br></pre></td></tr></table></figure><br>通过安装前的配置检查，发现有报错，检查中发现一些依赖库没有找到，这时候需要先安装nginx的一些依赖库<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum -y install pcre  # 安装nginx支持rewrite</span><br><span class="line">yum -y install gcc-c++</span><br><span class="line">yum -y install zlib*</span><br><span class="line">yum -y install openssl openssl-devel</span><br></pre></td></tr></table></figure><br>再次进行检查操作./configure 没有发现报错显示，接下来进行编译并安装的操作<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure</span><br></pre></td></tr></table></figure><br>这里需要特别注意下，以后需要用到的功能模块是否存在，不然以后添加新的包会比较麻烦。<br>查看默认安装的模块支持<br>命令 <code>ls nginx-1.22.2</code> 查看nginx的文件列表，可以发现里面又一个auto的目录<br>在这个auto的目录种又一个options文件，这个文件里面保存的就是nginx编译过程种的所有选项配置<br>用过命令： <code>cat nginx-1.22.2/auto/options | grep YES</code> 就可以查看<br><a href="https://jingyan.baidu.com/article/454316ab354edcf7a7c03a81.html" target="_blank" rel="noopener">nginx编译安装时，怎么查看安装模块</a></p>
<p>编译安装<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><br>这里需要注意，模块的支持跟后续的nginx配置有关，比如SSL，gzip压缩等等，编译安装前最好检查需要配置的模块存不存在。<br>查看nginx安装后的目录，可以看到已经安装到 <code>/usr/local/nginx</code> 目录了<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">whereis nginx</span><br><span class="line">$nginx: &#x2F;usr&#x2F;local&#x2F;nginx</span><br></pre></td></tr></table></figure><br>启动nginx服务<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin</span><br><span class="line">.&#x2F;nginx</span><br></pre></td></tr></table></figure><br>服务启动的时候报错了： <code>nginx : [emerg] bind() to 0.0.0.0:80 filed (98: Address alredy in use)</code> 通过命令查看本机网络地址和端口等一些信息，<br>找到被占用的80端口 <code>netstat -ntpl</code> 的tcp连接，并杀死进程（kill 进程 pid）<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -ntpl</span><br><span class="line">kill 进程PID</span><br></pre></td></tr></table></figure><br>继续启动 nginx 服务，启动成功<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nginx</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h1><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main        # 全局配置，对全局生效</span><br><span class="line">|-- events  # 配置影响 nginx 服务器与用户的网络连接</span><br><span class="line">|-- http    # 配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置</span><br><span class="line">|   |-- upstream        # 配置后端服务器具体地址，负载均衡配置不可或缺的部分</span><br><span class="line">|   |-- server          # 配置虚拟主机的相关参数，一个http块中可以有多个server块</span><br><span class="line">|   |-- server</span><br><span class="line">|   |   |-- location    # server块可以包含多个location块，location指令用于匹配uri</span><br><span class="line">|   |   |-- location</span><br><span class="line">|   |   |-- ...</span><br><span class="line">|   |-- ...</span><br><span class="line">|-- ...</span><br></pre></td></tr></table></figure>

<h3 id="主要配置含义"><a href="#主要配置含义" class="headerlink" title="主要配置含义"></a>主要配置含义</h3><pre><code>&gt;   main:nginx： 的全局配置，对全局生效；
&gt;   events： 配置影响nginx服务器或与用户的网络连接；
&gt;   http： 可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模版的配置；
&gt;   server： 配置虚拟主机的相关参数，一个http中可以有多个server；
&gt;   location： 配置请求的路由，以及各种页面的处理情况；
&gt;   upstream： 配置后端服务器具体地址，负载均衡配置不可或缺的部分；</code></pre><h3 id="nginx-conf-配置文件的语法规则"><a href="#nginx-conf-配置文件的语法规则" class="headerlink" title="nginx.conf 配置文件的语法规则"></a>nginx.conf 配置文件的语法规则</h3><pre><code>&gt;   配置文件由指令与指令块构成；
&gt;   每条指令以 “;“ 分号结尾，指令与参数间以空格符号分隔；
&gt;   指令块以 {} 大括号将多条指令组织在一起；
&gt;   include 语句允许组合多个配置文件以提升可维护性；
&gt;   通过 # 符号添加注释，提高可读性；
&gt;   通过 $ 符号使用变量；
&gt;   部分指令的参数支持正则表达式，例如常用的 location 指令；</code></pre><h3 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h3><pre><code>|       TCP         |       UDP      | 
|       ----        |      ----        |
|     $host      |   请求信息中的Host，如果请求中没有Host行，则等于设置的服务器名        |
|     $request_method      |     客户端请求类型，如 GET、POST      |
|     $remote_addr      |   客户端的 ip 地址        |
|     $args      |   请求中的参数        |
|     $content_length      |   请求头中的 Content-length 字段        |
|     $http_user_agent      |   客户端 agent 信息        |
|     $http_cookie      |    客户端 cookie 信息       |
|     $remote_port      |    客户端的端口       |
|     $server_protocol      |  请求使用的协议，如 HTTP/1.1         |
|     $server_addr      |   服务器地址        |
|     $server_name      |   服务器名称        |
|     $server_port      |   服务器的端口号        |</code></pre><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>这里列举几个常用的命令<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload  # 向主进程发送信号，重新加载配置文件，热重启</span><br><span class="line">nginx -s reopen  # 重启nginx</span><br><span class="line">nginx -s stop  # 快速关闭</span><br><span class="line">nginx -s quit  # 等待工作进程处理完成后关闭</span><br><span class="line">nginx -T  # 查看当前 nginx 最终的配置</span><br><span class="line">nginx -t -c &lt;配置路径&gt;  # 检查配置是否由问题，如果预警在配置目录，则不需要 -c</span><br></pre></td></tr></table></figure><br>以上命令通过 <code>nginx -h</code> 就可以查看到，还有其它不常用的这里不在列出。</p>
<p>Linux 系统应用管理工具 systemd 关于 nginx 的常用命令：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx  # 启动 nginx</span><br><span class="line">systemctl stop nginx   # 停止 nginx</span><br><span class="line">systemctl restart nginx  # 重启 nginx</span><br><span class="line">systemctl reload nginx  # 重新加载 nginx，用于修改配置后</span><br><span class="line">systemctl enable nginx  # 设置开机启动 nginx</span><br><span class="line">systemctl disable nginx  # 关闭开启启动 nginx</span><br><span class="line">systemctl status nginx  # 查看 nginx 运行状态</span><br></pre></td></tr></table></figure></p>
<h3 id="配置-nginx-开启自启"><a href="#配置-nginx-开启自启" class="headerlink" title="配置 nginx 开启自启"></a>配置 nginx 开启自启</h3><p>利用 systemctl 命令：<br>如果用yum install 命令安装的nginx，yum命令会自动创建nginx.service文件，直接用命令：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable nginx  # 设置开机启动 nginx</span><br><span class="line">systemctl disable nginx  # 关闭开机启动 nginx</span><br></pre></td></tr></table></figure><br>就你可以设置开机自启，否则需要在系统服务目录里创建 nginx.service 文件。<br>创建并打开 nginx.service 文件：<br><code>vi /lib/systemd/system/nginx.service</code><br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">内容如下:</span><br><span class="line">        [Unit]</span><br><span class="line">        Description&#x3D;nginx</span><br><span class="line">        After&#x3D;network.target</span><br><span class="line"></span><br><span class="line">        [Service]</span><br><span class="line">        Type&#x3D;forking</span><br><span class="line">        ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx</span><br><span class="line">        ExecReload&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s reload</span><br><span class="line">        ExecStop&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s quit</span><br><span class="line">        PrivateTmp&#x3D;true</span><br><span class="line"></span><br><span class="line">        [Install]</span><br><span class="line">        WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure><br><code>:wq</code> 保存退出，运行 <code>systemctl daemon-reload</code> 使文件生效。</p>
<p>这样便可以通过以下命令操作nginx了：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx.service  # 启动nginx服务</span><br><span class="line">systemctl enable nginx.service  # 设置开机启动</span><br><span class="line">systemctl disable nginx.service  # 停止开机启动</span><br><span class="line">systemctl status nginx.service  # 查看服务当前状态</span><br><span class="line">systemctl restart nginx.service  # 重新启动服务</span><br><span class="line">systemctl is-enabled nginx.service  # 查询服务是否开机启动</span><br></pre></td></tr></table></figure></p>
<h3 id="通过开机启动命令脚本实现开机自启"><a href="#通过开机启动命令脚本实现开机自启" class="headerlink" title="通过开机启动命令脚本实现开机自启"></a>通过开机启动命令脚本实现开机自启</h3><p>创建开启启动命令脚本文件：<br><code>vi /etc/init.d/nginx</code></p>
<p>在这个 nginx 文件中插入以下启动脚本代码，启动脚本代码来源网络复制，实测有效：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#! &#x2F;bin&#x2F;bash</span><br><span class="line"># chkconfig: -85 15</span><br><span class="line">PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx</span><br><span class="line">DESC&#x3D;&quot;nginx daemon&quot;</span><br><span class="line">NAME&#x3D;nginx</span><br><span class="line">DAEMON&#x3D;$PATH&#x2F;sbin&#x2F;$NAME</span><br><span class="line">CONFIGFILE&#x3D;$PATH&#x2F;logs&#x2F;$NAME.pid</span><br><span class="line">scriptNAME&#x3D;&#x2F;etc&#x2F;init.d&#x2F;$NAME</span><br><span class="line">set -e</span><br><span class="line">[ -x &quot;$DAEMON&quot; ] || exit 0</span><br><span class="line">do_start() &#123;</span><br><span class="line">    $DAEMON -c $CONFIGFILE || echo -n &quot;nginx already running&quot;</span><br><span class="line">&#125;</span><br><span class="line">do_stop() &#123;</span><br><span class="line">    $DAEMON -s stop || echo -n &quot;nginx not running&quot;</span><br><span class="line">&#125;</span><br><span class="line">do_reload() &#123;</span><br><span class="line">    $DAEMON -s reload || echo -n &quot;nginx can&#39;t reload&quot;</span><br><span class="line">&#125;</span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">start()</span><br><span class="line">echo -n &quot;Starting $DESC: $NAME&quot;</span><br><span class="line">do_start</span><br><span class="line">echo &quot;.&quot;</span><br><span class="line">;;</span><br><span class="line">restart()</span><br><span class="line">echo -n &quot;Restarting $DESC: $NAME&quot;</span><br><span class="line">do_stop</span><br><span class="line">do_start</span><br><span class="line">echo &quot;.&quot;</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">echo &quot;Usage: $scriptNAME &#123;start|stop|reload|restart&#125;&quot; &gt;&amp;2</span><br><span class="line">exit 3</span><br><span class="line">;;</span><br><span class="line">esac</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><br>设置所有人都有对这个启动脚本 nginx 文件的执行权限：<br><code>chmod a+x /etc/init.d/nginx</code></p>
<p>把nginx加入系统服务中：<br><code>chkconfig --add nginx</code></p>
<p>把服务设置为开机启动<br><code>chkconfig nginx on</code></p>
<p>reboot 重启系统生效，可以使用上面 systemctl 方法相同的命令：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx.service  # 启动nginx服务</span><br><span class="line">systemctl enable nginx.service  # 设置开机启动</span><br><span class="line">systemctl disable nginx.service  # 停止开机启动</span><br><span class="line">systemctl status nginx.service  # 查看服务当前状态</span><br><span class="line">systemctl restart nginx.service  # 重新启动服务</span><br><span class="line">systemctl is-enabled nginx.service  # 查询服务是否开机启动</span><br></pre></td></tr></table></figure></p>
<p>如果服务启动的时候出现 <code>Restarting nginx daemon: nginxnginx: [error] open() &quot;/usr/local/nginx/logs/nginx.pid&quot; filed (2: No such file or directory) nginx not running</code> 的错误，通过 nginx -c 参数指定配置文件即可解决<br><code>/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/ngonx.conf</code></p>
<p>如果服务启动中出现 <code>nginx: [emerg] bind() to 0.0.0.0:80 filed (98: Address already in use)</code> 的错误，可以先通过 <code>service nginx stop</code> 停止服务，再启动就好。</p>
<h3 id="配置-nginx-全局可用"><a href="#配置-nginx-全局可用" class="headerlink" title="配置 nginx 全局可用"></a>配置 nginx 全局可用</h3><p>当你每次改了 <code>nginx.conf</code> 配置文件的内容都需要重新到 nginx 启动目录去执行命令，或者通过 -p 参数指向特定目录，会不会感觉很麻烦？</p>
<p>例如：直接执行 <code>nginx -s reload</code> 会报错 <code>-bash: nginx command not found</code> 需要 <code>/usr/local/nginx/sbin</code> 目录下面去执行，并且是执行 <code>./nginx -s reload</code> 。</p>
<p>这里有两种方式可以解决，一种是通过脚本对 nginx 命令包装，这里介绍另外一种比较简单：通过把 nginx 配置到环境变量里，用nginx执行指令即可。步骤如下：</p>
<p>1、编辑/etc/profile<br><code>vi /etc/profile</code></p>
<p>2、在最后一行添加配置，:wq 保存<br><code>export PATH=$PATH:/usr/local/nginx/sbin</code></p>
<p>3、使配置立即生效<br><code>source /etc/profile</code></p>
<p>这样就可以愉快的直接在全局使用 nginx 命令了。</p>
<hr>
<h1 id="nginx-常用功能"><a href="#nginx-常用功能" class="headerlink" title="nginx 常用功能"></a>nginx 常用功能</h1><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>我们最常说的反向代理的是通过反向代理解决跨域问题。</p>
<p>其实反响代理还可以用来控制缓存（代理缓存 proxy cache），进行访问控制等等，以及后面说的负载均衡其实都是通过反向代理来实现的。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen  8080;</span><br><span class="line">    # 用户访问 ip:8080&#x2F;test 下的所有路径代理到 baidu.com</span><br><span class="line">    location &#x2F;test &#123;</span><br><span class="line">        proxy_pass  https:&#x2F;&#x2F;baidu.com;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 所有 &#x2F;api 下的接口访问代理到本地的 8080 端口</span><br><span class="line">    # 例如你本地运行的 go 服务的端口是 8888，接口都是以 &#x2F;api 开头</span><br><span class="line">    location &#x2F;api &#123;</span><br><span class="line">        proxy_pass  http:&#x2F;&#x2F;localhost:8888;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    location ~ ^&#x2F;index.html &#123;</span><br><span class="line">        # 匹配 index.html 页面除了 127.0.0.1 以外都可以访问</span><br><span class="line">        deny 192.168.1.1;</span><br><span class="line">        deny 192.168.1.2;</span><br><span class="line">        allow all;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>上面命令表示禁止 192.168.1.1 和 192.168.1.2 两个 ip 访问，其它全部允许。从上到下的顺序，匹配到了便跳出，可以按你的需求设置。</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>通过负载均衡充利用服务器资源，nginx 目前支持自带4中负载均衡策略，还有2种常用的第三方策略。</p>
<h4 id="轮训策略（默认）"><a href="#轮训策略（默认）" class="headerlink" title="轮训策略（默认）"></a>轮训策略（默认）</h4><p>每个请求按照时间顺序逐一分配到不同的后端服务器，如果有后端服务器挂掉，能自动剔除。但是如果其中某一台服务器压力太大，出现延迟，会影响所有分配在这台服务器下的用户。</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream test.com &#123;</span><br><span class="line">        server 192.168.1.12:8887;</span><br><span class="line">        server 192.168.1.13:8888;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        location &#x2F;api &#123;</span><br><span class="line">            proxy_pass  http:&#x2F;&#x2F;test.com;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h4 id="根据服务器权重"><a href="#根据服务器权重" class="headerlink" title="根据服务器权重"></a>根据服务器权重</h4><p>例如要配置：10 次请求中大概 1 次访问到 8888 端口，9 次访问到 8887 端口：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream test.com &#123;</span><br><span class="line">        server 192.168.1.12:8887 weight&#x3D;9;</span><br><span class="line">        server 192.168.1.13:8888 weight&#x3D;1;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        location &#x2F;api &#123;</span><br><span class="line">            proxy_pass  http:&#x2F;&#x2F;test.com;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="客户端-id-绑定（ip-hash）"><a href="#客户端-id-绑定（ip-hash）" class="headerlink" title="客户端 id 绑定（ip_hash）"></a>客户端 id 绑定（ip_hash）</h4><p>来自同一个 ip 的请求永远只分配一台服务器，有效解决了动态网页的 session 共享问题，例如：比如把登陆信息保存到了 session 中，那么跳转到另外一台服务器的时候就需要重新登陆了。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream test.com &#123;</span><br><span class="line">        ip_hash;</span><br><span class="line">        server 192.168.1.12:8887;</span><br><span class="line">        server 192.168.1.13:8888;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        location &#x2F;api &#123;</span><br><span class="line">            proxy_pass  http:&#x2F;&#x2F;test.com;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="最小连接数策略"><a href="#最小连接数策略" class="headerlink" title="最小连接数策略"></a>最小连接数策略</h4><p>将请求优先分配给压力较小的服务器，它可以平衡每个队列的长度，并避免向压力大的服务器添加更多的请求。</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream test.com &#123;</span><br><span class="line">        least_conn;</span><br><span class="line">        server 192.168.1.12:8887;</span><br><span class="line">        server 192.168.1.13:8888;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        location &#x2F;api &#123;</span><br><span class="line">            proxy_pass  http:&#x2F;&#x2F;test.com;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h4 id="最快响应时间策略（依赖于第三方-NGINX-Plus）"><a href="#最快响应时间策略（依赖于第三方-NGINX-Plus）" class="headerlink" title="最快响应时间策略（依赖于第三方 NGINX Plus）"></a>最快响应时间策略（依赖于第三方 NGINX Plus）</h4><p>依赖于 NGINX Plus，优先分配给响应时间最短的服务器。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream test.com &#123;</span><br><span class="line">        fair;</span><br><span class="line">        server 192.168.1.12:8887;</span><br><span class="line">        server 192.168.1.13:8888;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        location &#x2F;api &#123;</span><br><span class="line">            proxy_pass  http:&#x2F;&#x2F;test.com;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="按访问url的hash结果（第三方）"><a href="#按访问url的hash结果（第三方）" class="headerlink" title="按访问url的hash结果（第三方）"></a>按访问url的hash结果（第三方）</h4><p>按访问的 url 的 hash 结果来分配请求，使每个 url 定向到同一个后端服务器，后端服务器为缓存时比较有效。在 upstream 中加入 hash 语句，server 语句中 不能写入 weight 等其它的参数，hash_method 是使用的 hash 算法。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream test.com &#123;</span><br><span class="line">        hash $request_uri;</span><br><span class="line">        hash_method crc32;</span><br><span class="line">        server 192.168.1.12:8887;</span><br><span class="line">        server 192.168.1.13:8888;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        location &#x2F;api &#123;</span><br><span class="line">            proxy_pass  http:&#x2F;&#x2F;test.com;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>采用 HAproxy 的 loadbalance uri 或者 nginx 的 upstream_hash 模块，都可以做到针对 uri 进行哈希算法式的负载均衡转发。</p>
<h3 id="gzip-压缩"><a href="#gzip-压缩" class="headerlink" title="gzip 压缩"></a>gzip 压缩</h3><p>开启 gzip 压缩可以大幅减少 http 传输过程中文件的大小，可以极大的提高网站的访问速度，基本是必不可少的优化操作：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gzip    on;  # 开启 gzip 压缩</span><br><span class="line"># gzip_types</span><br><span class="line"># gzip_static on;</span><br><span class="line"># gzip_proxied expired no-cache no-store private auth;</span><br><span class="line"># gzip_buffers 16 8k;</span><br><span class="line">gzip_min_length 1k;</span><br><span class="line">gzip_comp_level 4;</span><br><span class="line">gzip_http_version 1.0;</span><br><span class="line">gzip_vary off;</span><br><span class="line">gzip_disable &quot;MSIE [1-6]\.&quot;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>解释一下以上参数：<blockquote>
<ol>
<li>gzip_types：要采用 gzip 压缩的 MIME 文件类型，其中 text/html 被系统强制启用；</li>
<li>gzip_static：默认 off，该模块启用后，Nginx 首先检查是否存在请求静态文件的 gz 结尾的文件，如果有则直接返回该 .gz 文件内容；</li>
<li>gzip_proxied：默认 off nginx 做为反响代理时启用，用于设置启用或禁用从代理服务器上收到相应内容的 gzip 压缩；</li>
<li>gzip_buffers：获取多少内存用于缓存压缩结果，16 8k 表示 8k*16 为单位获得；</li>
<li>gzip_min_length：允许压缩的页面最小字节数，页面字节数 从 header 头中的 Content-Length 中进行获取，默认值是 0，不管也页面多大都压缩。建议设置成大于 1k 的字节数，小于 1k 可能会越压越大；</li>
<li>gzip_comp_level：gzip 压缩比，压缩级别是 1-9，1 压缩级别最低，9 最高，级别越高压缩率越大，压缩时间越长，建议 4-6；</li>
<li>gzip_http_version：默认 1.1，启用 gzip 所需的 HTTP 最低版本；</li>
<li>gzip_vary：用于在响应消息头中添加 Vary：Accept-Encoding，使代理服务器根据请求头中的 Accept-Encoding 识别是否启用 gzip 压缩；</li>
<li>gzip_disable：指定那些不需要 gzip 压缩的浏览器；<br>其中第2点，普遍是结合前端打包的时候打包成 gzip 文件后部署到服务器上，这样服务器就可以直接使用 gzip 的文件了，并且可以把压缩比例提高，这样 nginx 就不用压缩，也就不会影响速度，一般不追求极致的情况下，前端不用做任何配置就可以使用了。</li>
</ol>
</blockquote>
</li>
</ul>
<p>附前端 webpack 开启 gzip 压缩配置，在 vue-cli3 的 vue.config.js 配置文件中：<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CompressionWebpackPlugin = <span class="built_in">require</span>(<span class="string">'compression-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// gzip 配置</span></span><br><span class="line">    configureWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">            <span class="comment">// 生产环境</span></span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                plugins: [<span class="keyword">new</span> ConpressionWebpackPlugin (&#123;</span><br><span class="line">                    test: <span class="regexp">/\.js$|\.html$|\.css/</span>,    <span class="comment">// 匹配文件名</span></span><br><span class="line">                    threshold: <span class="number">1024</span>,                <span class="comment">// 文件压缩阀值，对超过 1k 的进行压缩</span></span><br><span class="line">                    deleteOriginalAssets: <span class="literal">false</span>     <span class="comment">// 是否删除源文件</span></span><br><span class="line">                &#125;)]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="HTTP-服务器"><a href="#HTTP-服务器" class="headerlink" title="HTTP 服务器"></a>HTTP 服务器</h3><p>nginx 本身也是一个静态资源的服务器，当只有静态资源的时候，就可以使用 nginx 来做服务器：</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen  80;</span><br><span class="line">    server_name localhost;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root    &#x2F;usr&#x2F;local&#x2F;app;</span><br><span class="line">        index   index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>这样如果访问 <a href="http://ip" target="_blank" rel="noopener">http://ip</a> 就会默认访问到 /usr/local/app 目录下面的 index.html，如果一个网站只是静态页面的话，那么就可以通过这种方式来实现部署，比如一个静态官网。</p>
<h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3><p>就是把动态和静态的请求分开。方式主要有两种：<br>    *   一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也就是目前主流推崇的方案<br>    *   一种就是动态跟静态文件混合在一起发布，通过 nginx 配置来分开<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 所有静态请求都由nginx处理，存放目录为 html</span><br><span class="line">location ~ \.(gif|jpg|jpeg|png|bmp|swf|css|js)$ &#123;</span><br><span class="line">    root    &#x2F;usr&#x2F;local&#x2F;resource;</span><br><span class="line">    expires 10h;    # 设置过期时间为 10 小时</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 所有动态请求都转发给 tomcat 处理</span><br><span class="line">location ~ \.(jsp|do)$ &#123;</span><br><span class="line">    proxt_pass  127.0.0.1:8888;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意上面设置了 expires，当 nginx 设置了 expires 后，例如设置为：expires 10d；那么，所在的 location 或 if 的内容，用户在 10 天内请求的时候，都只会访问浏览器中的缓存，而不会去请求 nginx。</p>
<h3 id="请求限制"><a href="#请求限制" class="headerlink" title="请求限制"></a>请求限制</h3><p>对于大流量恶意的访问，会造成带宽的浪费，给服务器增加压力。可以通过 nginx 对于同一 ip 的连接数以及并发数进行限制。合理的控制还可以用来防止 DDos 和 CC攻击。</p>
<p>关于请求限制主要使用 nginx 默认集成的 2个模块：<br>    *   limit_conn_module 连接频率限制模块<br>    *   limit_req_module  请求频率限制模块</p>
<p>涉及到的配置主要是：<br>    *   limit_req_zone  限制请求数<br>    *   limit_conn_zone 限制并发连接数</p>
<h4 id="通过-limit-req-zone-限制请求数"><a href="#通过-limit-req-zone-限制请求数" class="headerlink" title="通过 limit_req_zone 限制请求数"></a>通过 limit_req_zone 限制请求数</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    limit_conn_zone $binary_remote_addrzone&#x3D;limit : 10m; &#x2F;&#x2F; 设置共享内存空间大小</span><br><span class="line">    server &#123;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            limit_conn addr 5;  # 同一用户地址同一时间只允许5个链接</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>如果共享内存空间被耗尽，服务器将会对后续所有的请求返回503（Service Temporarily Unavailable）错误。<br>当多个limit_conn_zone 指令被配置时，所有的连接数限制都会生效。比如，下面配置不仅会限制单一IP来源的连接数同时也会限制单一虚拟服务器的总连接数：</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">limit_conn_zone $binary_remote_addr zone&#x3D;perip:10m;</span><br><span class="line">limit_conn_zone $server_name zone&#x3D;perserver:10m;</span><br><span class="line">server &#123;</span><br><span class="line">    limit_conn perip 10; # 限制每个 ip 连接到服务器的数量</span><br><span class="line">    limit_conn perserver 2000; # 限制连接到服务器的总数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h4 id="通过-limit-conn-zone-限制并发连接数"><a href="#通过-limit-conn-zone-限制并发连接数" class="headerlink" title="通过 limit_conn_zone 限制并发连接数"></a>通过 limit_conn_zone 限制并发连接数</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">limit_req_zone $binary_remote_addr zone&#x3D;creq:10 mrate&#x3D;10r&#x2F;s;</span><br><span class="line">server&#123;</span><br><span class="line">    location &#x2F;&#123;</span><br><span class="line">        limit_req zone&#x3D;creq burst&#x3D;5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>限制平均每秒不超过一个请求，同时允许超过频率限制的请求数不多于5个。<br>如果不希望超过的请求被延迟，可以用 nodelay 参数，如：<code>limit_req zone=creq burst=5 nodelay;</code></p>
<h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p>正向代理，意思是一个位于客户端和原始服务器（origin server）之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标（原始服务器），然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理，比如我们使用的 VPN 服务就是正向代理，直观区别：<br><img src= "/img/loading.gifs" data-src="/images/nginx/img1.jpg" alt=""></p>
<p>配置正向代理：</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">resolver 8.8.8.8 # 谷歌的域名解析地址</span><br><span class="line">server &#123;</span><br><span class="line">    resolver_timeout 5s; &#x2F;&#x2F; 设超时时间</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        # 当客户端请求我的时候，我会把请求转发给它</span><br><span class="line">        # $host 要访问的主机名 $request_uri 请求路径</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;$host$request_uri;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>正向代理的对象是客户端，服务器端看不到正真的客户端。</p>
<h3 id="图片防盗链"><a href="#图片防盗链" class="headerlink" title="图片防盗链"></a>图片防盗链</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    server &#123;</span><br><span class="line">    listen       80;      </span><br><span class="line">    server_name  *.test;</span><br><span class="line"></span><br><span class="line">    # 图片防盗链</span><br><span class="line">    location ~* \.(gif|jpg|jpeg|png|bmp|swf)$ &#123;</span><br><span class="line">        valid_referers none blocked server_names ~\.google\. ~\.baidu\. *.qq.com;  # 只允许本机 IP 外链引用，将百度和谷歌也加入白名单有利于 SEO</span><br><span class="line">        if ($invalid_referer)&#123;</span><br><span class="line">            return 403;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>以上配置就能防止其它网站利用外链访问我们的图片，有利于节省流量。</p>
<h3 id="适配-PC-或移动设备"><a href="#适配-PC-或移动设备" class="headerlink" title="适配 PC 或移动设备"></a>适配 PC 或移动设备</h3><p>根据用户设备不用返回不用样式的站点，以前经常使用的是纯前端的自适应布局，但是复杂的网站并不适合响应式，无论是复杂性和易用性上面还是不如分开编写的好，比如我们常见的淘宝、京东。</p>
<p>根据用户请求的 user-agent 来判断是返回 PC 还是 H5 站点：</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name test.com;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root  &#x2F;usr&#x2F;local&#x2F;app&#x2F;pc; # pc 的 html 路径</span><br><span class="line">        if ($http_user_agent ~* &#39;(Android|webOS|iPhone|iPod|BlackBerry)&#39;) &#123;</span><br><span class="line">            root &#x2F;usr&#x2F;local&#x2F;app&#x2F;mobile; # mobile 的 html 路径</span><br><span class="line">        &#125;</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="设置二级域名"><a href="#设置二级域名" class="headerlink" title="设置二级域名"></a>设置二级域名</h3><p>新建一个 server 即可：</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name admin.test.com; &#x2F;&#x2F; 二级域名</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root  &#x2F;usr&#x2F;local&#x2F;app&#x2F;admin; # 二级域名的 html 路径</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="配置-HTTPS"><a href="#配置-HTTPS" class="headerlink" title="配置 HTTPS"></a>配置 HTTPS</h3><p>这里我们使用 cerbot 免费证书，但申请一次有效期只有三个月，（好像可以用 crontab 尝试配置自动续期）：<br>先安装 cerbot</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;dl.eff.org&#x2F;cerbot-auto</span><br><span class="line">chmod a+x cerbot-auto</span><br></pre></td></tr></table></figure></code></pre><p>申请证书（注意：需要把申请证书的域名先解析到这台服务器上，才能申请）：</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo .&#x2F;certbot-auto certonly --standalone --email admin@abc.com -d test.com -d www.test.com</span><br></pre></td></tr></table></figure></code></pre><p>执行上面指令，按提示操作。<br>Cerbot 会启动一个临时服务器来完成验证，（会占用 80 端口或 443 端口，因此需要暂时关闭 Web 服务器），然后 Cerbot 会把证书以文件的形式保存，包括完整的证书链文件和私钥文件。</p>
<p>文件保存在 etc/letsencrypt/live 下面的域名目录下。</p>
<p>修改 nginx 配置：</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    server&#123;</span><br><span class="line">    listen 443 ssl http2; &#x2F;&#x2F; 这里还启用了 http&#x2F;2.0</span><br><span class="line"></span><br><span class="line">    ssl_certificate &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;test.com&#x2F;fullchain.pem; # 证书文件地址</span><br><span class="line">    ssl_certificate_key &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;test.com&#x2F;privkey.pem; # 私钥文件地址</span><br><span class="line"></span><br><span class="line">    server_name test.com www.test.com; &#x2F;&#x2F; 证书绑定的域名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="配置-HTTP-转-HTTPS"><a href="#配置-HTTP-转-HTTPS" class="headerlink" title="配置 HTTP 转 HTTPS"></a>配置 HTTP 转 HTTPS</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    server &#123;</span><br><span class="line">    listen      80;</span><br><span class="line">    server_name test.com www.test.com;</span><br><span class="line"></span><br><span class="line">    # 单域名重定向</span><br><span class="line">    if ($host &#x3D; &#39;www.sherlocked93.club&#39;)&#123;</span><br><span class="line">        return 301 https:&#x2F;&#x2F;www.sherlocked93.club$request_uri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 全局非 https 协议时重定向</span><br><span class="line">    if ($scheme !&#x3D; &#39;https&#39;) &#123;</span><br><span class="line">        return 301 https:&#x2F;&#x2F;$server_name$request_uri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 或者全部重定向</span><br><span class="line">    return 301 https:&#x2F;&#x2F;$server_name$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>以上配置选择自己需要的一条即可，不用全部加。</p>
<h3 id="单页面项目-history-路由配置"><a href="#单页面项目-history-路由配置" class="headerlink" title="单页面项目 history 路由配置"></a>单页面项目 history 路由配置</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  fe.sherlocked93.club;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root       &#x2F;usr&#x2F;local&#x2F;app&#x2F;dist;  # vue 打包后的文件夹</span><br><span class="line">        index      index.html index.htm;</span><br><span class="line">        try_files  $uri $uri&#x2F; &#x2F;index.html @rewrites; # 默认目录下的 index.html，如果都不存在则重定向</span><br><span class="line"></span><br><span class="line">        expires -1;                          # 首页一般没有强制缓存</span><br><span class="line">        add_header Cache-Control no-cache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location @rewrites &#123; &#x2F;&#x2F; 重定向设置</span><br><span class="line">        rewrite ^(.+)$ &#x2F;index.html break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p><a href="https://router.vuejs.org/zh/guide/essentials/history-mode.html#%E5%90%8E%E7%AB%AF%E9%85%8D%E7%BD%AE%E4%BE%8B%E5%AD%90" target="_blank" rel="noopener">vue-router</a> 官网只有一句话 <code>try_files $uri $uri/ /index.html;</code> 而上面做了一些重定向处理。</p>
<h3 id="配置高可用集群（双机热备）"><a href="#配置高可用集群（双机热备）" class="headerlink" title="配置高可用集群（双机热备）"></a>配置高可用集群（双机热备）</h3><p>当主机 nginx 服务器宕机之后，切换到备份的 nginx 服务器</p>
<p>首先安装 keepalived：<code>yum install keepalived -y</code> 然后编辑 <code>/etc/keepalived/keepalived.conf</code> 配置文件，并在配置文件中增加 <code>vrrp_script</code> 定义一个外围检测机制，并在 <code>vrrp_instance</code> 中通过定义 <code>track_script</code> 来追踪脚本执行过程，实现节点转移：</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">global_defs&#123;</span><br><span class="line">notification_email &#123;</span><br><span class="line">        cchroot@gmail.com</span><br><span class="line">&#125;</span><br><span class="line">notification_email_from test@firewall.loc</span><br><span class="line">smtp_server 127.0.0.1</span><br><span class="line">smtp_connect_timeout 30 &#x2F;&#x2F; 上面都是邮件配置</span><br><span class="line">router_id LVS_DEVEL     &#x2F;&#x2F; 当前服务器名字，用 hostname 命令来查看</span><br><span class="line">&#125;</span><br><span class="line">vrrp_script chk_maintainace &#123; &#x2F;&#x2F; 检测机制的脚本名称为chk_maintainace</span><br><span class="line">    script &quot;[[ -e&#x2F;etc&#x2F;keepalived&#x2F;down ]] &amp;&amp; exit 1 || exit 0&quot; &#x2F;&#x2F; 可以是脚本路径或脚本命令</span><br><span class="line">    &#x2F;&#x2F; script &quot;&#x2F;etc&#x2F;keepalived&#x2F;nginx_check.sh&quot;    &#x2F;&#x2F; 比如这样的脚本路径</span><br><span class="line">    interval 2  &#x2F;&#x2F; 每隔2秒检测一次</span><br><span class="line">    weight -20  &#x2F;&#x2F; 当脚本执行成立，那么把当前服务器优先级改为-20</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instanceVI_1 &#123;   &#x2F;&#x2F; 每一个vrrp_instance就是定义一个虚拟路由器</span><br><span class="line">    state MASTER      &#x2F;&#x2F; 主机为MASTER，备用机为BACKUP</span><br><span class="line">    interface eth0    &#x2F;&#x2F; 网卡名字，可以从ifconfig中查找</span><br><span class="line">    virtual_router_id 51 &#x2F;&#x2F; 虚拟路由的id号，一般小于255，主备机id需要一样</span><br><span class="line">    priority 100      &#x2F;&#x2F; 优先级，master的优先级比backup的大</span><br><span class="line">    advert_int 1      &#x2F;&#x2F; 默认心跳间隔</span><br><span class="line">    authentication &#123;  &#x2F;&#x2F; 认证机制</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111   &#x2F;&#x2F; 密码</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;  &#x2F;&#x2F; 虚拟地址vip</span><br><span class="line">    172.16.2.8</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>其中检测脚本 <code>nginx_check.sh</code> ，这里提供一个：</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">A&#x3D;&#96;ps -C nginx --no-header | wc -l&#96;</span><br><span class="line">if [ $A -eq 0 ];then</span><br><span class="line">    &#x2F;usr&#x2F;sbin&#x2F;nginx # 尝试重新启动nginx</span><br><span class="line">    sleep 2         # 睡眠2秒</span><br><span class="line">    if [ &#96;ps -C nginx --no-header | wc -l&#96; -eq 0 ];then</span><br><span class="line">        killall keepalived # 启动失败，将keepalived服务杀死。将vip漂移到其它备份节点</span><br><span class="line">    fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></code></pre><p>复制一份到备份服务器，备份 nginx 的配置要将 <code>state</code> 后改为 <code>BACKUP</code> ， <code>priority</code> 改为比主机小。<br>设置完毕后各自 <code>service keepalived start</code> 启动，经过访问成功后，可以把 Master 机的 keepalived 停掉，此时 Master 机就不再是主机了 <code>services keepalived stop</code> 看到访问虚拟 IP 时是否能够自动切换到备机 ip addr。</p>
<p>再次启动 Master 的 keepalived，此时 vip 又变到了主机上。</p>
<p>配置高可用集群的内容来源于：<a href="https://juejin.cn/post/6844904144235413512#heading-11" target="_blank" rel="noopener">Nginx 从入门到实践，万字详解！</a></p>
<hr>
<h1 id="其它功能和技巧"><a href="#其它功能和技巧" class="headerlink" title="其它功能和技巧"></a>其它功能和技巧</h1><h3 id="代理缓存"><a href="#代理缓存" class="headerlink" title="代理缓存"></a>代理缓存</h3><p>nginx 的 http_proxy 模块，提供类似于 Squid 的缓存功能，使用 proxy_cache_path 来配置。</p>
<p>nginx 可以对访问过的内容在 nginx 服务器本地建立副本，这样在一段时间内再次访问该数据，就不需要通过 nginx 服务器再次向后端服务器发出请求，减小数据传输延迟，提高访问速度：</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    proxy_cache_path usr&#x2F;local&#x2F;cache levels&#x3D;1:2 keys_zone&#x3D;my_cache:10m;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  test.com;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_cache my_cache;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;127.0.0.1:8888;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>上面的配置表示：nginx 提供一块 10m 的内存用于缓存，名字为 my_cache，levels 等级为1:2，缓存存放的路径为 <code>usr/local/cache</code> 。</p>
<h3 id="访问日志"><a href="#访问日志" class="headerlink" title="访问日志"></a>访问日志</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    http &#123;</span><br><span class="line">    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">                    &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">                    &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">    access_log  logs&#x2F;access.log  main;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>错误日志放在 main 全局区块中，打开 nginx.conf 就可以看见在配置文件中和下面一样的代码了：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#error_log  logs&#x2F;error.log;</span><br><span class="line">#error_log  logs&#x2F;error.log  notice;</span><br><span class="line">#error_log  logs&#x2F;error.log  info;</span><br></pre></td></tr></table></figure></p>
<p>nginx 错误日志默认配置为：<code>error_log logs/error.log error;</code> </p>
<h3 id="静态资源服务器"><a href="#静态资源服务器" class="headerlink" title="静态资源服务器"></a>静态资源服务器</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  static.bin;</span><br><span class="line">    charset utf-8;    # 防止中文文件名乱码</span><br><span class="line"></span><br><span class="line">    location &#x2F;download &#123;</span><br><span class="line">        alias	          &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;static;  # 静态资源目录</span><br><span class="line"></span><br><span class="line">        autoindex               on;    # 开启静态资源列目录，浏览目录权限</span><br><span class="line">        autoindex_exact_size    off;   # on(默认)显示文件的确切大小，单位是byte；off显示文件大概大小，单位KB、MB、GB</span><br><span class="line">        autoindex_localtime     off;   # off(默认)时显示的文件时间为GMT时间；on显示的文件时间为服务器时间</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="禁止指定-user-agent"><a href="#禁止指定-user-agent" class="headerlink" title="禁止指定 user_agent"></a>禁止指定 user_agent</h3><p>nginx 可以禁止指定的浏览器和爬虫框架的访问：</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># http_user_agent 为浏览器标识</span><br><span class="line"># 禁止 user_agent 为baidu、360和sohu，~*表示不区分大小写匹配</span><br><span class="line">if ($http_user_agent ~* &#39;baidu|360|sohu&#39;) &#123;</span><br><span class="line">    return 404;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 禁止 Scrapy 等工具的抓取</span><br><span class="line">if ($http_user_agent ~* (Scrapy|Curl|HttpClient)) &#123;</span><br><span class="line">    return 403;</span><br></pre></td></tr></table></figure></code></pre><h3 id="请求过滤"><a href="#请求过滤" class="headerlink" title="请求过滤"></a>请求过滤</h3><h4 id="根据请求类型过滤"><a href="#根据请求类型过滤" class="headerlink" title="根据请求类型过滤"></a>根据请求类型过滤</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 非指定请求全返回 403</span><br><span class="line">if ( $request_method !~ ^(GET|POST|HEAD)$ ) &#123;</span><br><span class="line">    return 403;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h4 id="根据状态码过滤"><a href="#根据状态码过滤" class="headerlink" title="根据状态码过滤"></a>根据状态码过滤</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">error_page 502 503 &#x2F;50x.html;</span><br><span class="line">location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">    root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>这样实际上是一个内部跳转，当访问出现 502、503 的时候就能返回 50x.html 中的内容，这里需要注意是否可以找到 50x.html 页面，所以加了个 location 保证找到你自定义的 50x 页面。</p>
<h4 id="根据-URL-名称过滤"><a href="#根据-URL-名称过滤" class="headerlink" title="根据 URL 名称过滤"></a>根据 URL 名称过滤</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    if ($host &#x3D; zy.com&#39; ) &#123;</span><br><span class="line">    #其中$1是取自regex部分()里的内容,匹配成功后跳转到的URL。</span><br><span class="line">    rewrite ^&#x2F;(.*)$  http:&#x2F;&#x2F;www.zy.com&#x2F;$1  permanent；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location &#x2F;test &#123;</span><br><span class="line">    &#x2F;&#x2F; &#x2F;test 全部重定向到首页</span><br><span class="line">    rewrite  ^(.*)$ &#x2F;index.html  redirect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h4 id="ab-命令"><a href="#ab-命令" class="headerlink" title="ab 命令"></a>ab 命令</h4><p>ab命令全称为：Apache bench，是 Apache 自带的压力测试工具，也可以测试 Nginx、IIS 等其它 Web 服务器：</p>
<pre><code>*   -n总共的请求数
*   -c并发的请求数
*   -t测试所进行的最大秒数，默认值为 50000
*   -p包含了需要的 POST 的数据文件
*   -T POST数据所使用的 Content-type 头信息</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ab -n 1000 -c 5000 http:&#x2F;&#x2F;127.0.0.1&#x2F; # 每次发送1000并发的请求数，请求数总数为5000。</span><br></pre></td></tr></table></figure>
<p>测试前需要安装 httpd-tools：<code>yum install httpd_tools</code> </p>
<h4 id="泛域名路径分离"><a href="#泛域名路径分离" class="headerlink" title="泛域名路径分离"></a>泛域名路径分离</h4><p>这是一个非常使用的技能，经常有时候我们可能需要配置一些二级或者三级域名，希望通过 nginx 自动指向对应目录，比如：</p>
<ol>
<li>test1.doc.test.club 自动指向 /usr/local/html/doc/test1 服务器地址；</li>
<li>test2.doc.test.club 自动指向 /usr/local/html/doc/test2 服务器地址； <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  ~^([\w-]+)\.doc\.test\.club$;</span><br><span class="line"></span><br><span class="line">    root &#x2F;usr&#x2F;local&#x2F;html&#x2F;doc&#x2F;$1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="泛域名转发"><a href="#泛域名转发" class="headerlink" title="泛域名转发"></a>泛域名转发</h4><p>和之前的功能类似，有时候我们希望把二级或者三级域名链接重写到我们希望的路径，让后端，就可以根据路由解析不同的规则：</p>
<ol>
<li>test1.serv.test.club/api?name=a 自动转发到 127.0.0.1:8080/test1/api?name=a</li>
<li>test2.serv.test.club/api?name=a 自动转发到 127.0.0.1:8080/test2/api?name=a <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name ~^([\w-]+)\.serv\.test\.club$;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_set_header        X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header        Host $http_host;</span><br><span class="line">        proxy_set_header        X-NginX-Proxy true;</span><br><span class="line">        proxy_pass              http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;$1$request_uri;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h3 id="nginx-中怎么设置变量"><a href="#nginx-中怎么设置变量" class="headerlink" title="nginx 中怎么设置变量"></a>nginx 中怎么设置变量</h3><p>或许你不知道， nginx 的配置文件使用的是一门微型编程语言。既然是编程语言，一般也就少不了“变量“这种东西，但是在 nginx 配置中，变量只能存放一种类型的值，因为也只存在一种类型的值，那就是字符串。</p>
<p>例如我们在 nginx.conf 中有这样一行配置：<code>set $name &quot;chroot&quot;;</code> </p>
<p>上面使用了 set 配置指令对变量 <code>$name</code> 进行了赋值操作，把“chroot” 赋值给了 <code>$name</code> 。<br>nginx 变量名前面有一个 <code>$</code> 符号，这是记法上的要求。所有的 Nginx 变量在 Nginx 配置文件中引用时都须带上 <code>$</code> 前缀。这种表示方法和 Perl、PHP 这些语言是相似的。</p>
<p>这种表示方法的用处在那里呢，那就是可以直接把变量嵌入到字符串常量中以构造出新的字符串，例如你需要进行一个字符串拼接：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  test.com;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        set $temp hello;</span><br><span class="line">        return &quot;$temp world&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上当匹配成功的时候就会返回字符串“hello world”了。需要注意的是，当引用变量名之后紧跟着变量名的构成字符时（比如后面跟字母、数字以及下划线），我们就需要使用特别的记法来消除歧义，例如：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  test.com;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        set $temp &quot;hello &quot;;</span><br><span class="line">        return &quot;$&#123;temp&#125;world&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，我们在配置指令的参数值中引用变量 <code>$temp</code> 的时候，后面紧跟着 <code>world</code> 这个单词，所以如果直接写作 <code>$tempworld</code> 则 nginx 的计算引擎会将之识别为引用了变量 <code>$tempworld</code> ，为了解决这个问题， nginx 的字符串支持使用花括号在 <code>$</code> 之后把变量名围起来，比如这里的 <code>${temp}</code> ，所以上面这个例子返回的还是“hello world”：<br><code>curl  &#39;http://test.com/&#39;</code></p>
<p>还需要注意的是，若是向输出 <code>$</code> 符号本身，可以这样做：</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    geo $dollar &#123;</span><br><span class="line">    default &quot;$&quot;;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  test.com;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        set $temp &quot;hello &quot;;</span><br><span class="line">        return &quot;$&#123;temp&#125;world: $dollar&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>上面用到了标准模块的 ngx_geo 提供的配置指令 geo 来为变量 <code>$dollar</code> 赋予字符串， <code>$</code> ，这样，这里的返回值就是 “hello world：$” 了。</p>
<hr>
<h1 id="附-nginx-内置预定义变量"><a href="#附-nginx-内置预定义变量" class="headerlink" title="附 nginx 内置预定义变量"></a>附 nginx 内置预定义变量</h1><ul>
<li>按字母顺序，变量名对应定义<blockquote>
<ul>
<li><code>$arg_PARAMETER</code>  #GET 请求中变量名 PARAMETER 参数的值</li>
<li><code>$args</code>  #这个变量等于 GET 请求中的参数，例如，foo=123&amp;bar=blahblah;这个变量可以被修改</li>
<li><code>$binary_remote_addr</code>  #二进制码形式的客户端地址</li>
<li><code>$body_bytes_sent</code>  #传送页面的字节数</li>
<li><code>$content_length</code>  #请求头中的 Content-length 字段</li>
<li><code>$content_type</code>  #请求头中的 Content-Type 字段</li>
<li><code>$cookie_COOKIE</code>  #cookie COOKIE 的值</li>
<li><code>$document_root</code>  #当前请求在 root 指令中指定的值</li>
<li><code>document_uri</code>  #与 $uri 相同</li>
<li><code>$host</code>  #请求中的主机头(Host)字段，如果请求中的主机头不可用或者空，则为处理请求的server 名称(处理请求的 server 的 server_name 指令的值)。值为小写，不包含端口</li>
<li><code>$hostname</code>  #机器名使用 gethostname 系统调用的值</li>
<li><code>$http_HEADER</code>  #HTTP 请求头中的内容，HEADER 为 HTTP 请求中的内容转为小写，-变为_(破折号变为下划线)，例如：$http_user_agent(Uaer-Agent 的值)</li>
<li><code>$sent_http_HEADER</code>  #HTTP 响应头中的内容，HEADER 为 HTTP 响应中的内容转为小写，-变为_(破折号变为下划线)，例如：、senthttpcachecontrol、sent_http_content_type…</li>
<li><code>$is_args</code>  #如果 $args 设置，值为”?”，否则为””</li>
<li><code>$limit_rate</code>  #这个变量可以限制连接速率</li>
<li><code>$nginx_version</code>  #当前运行的 nginx 版本号</li>
<li><code>$query_string</code>  #与 $args 相同</li>
<li><code>$remote_addr</code>  #客户端的IP地址</li>
<li><code>$remote_port</code>  #客户端的端口</li>
<li><code>$remote_port</code>  #已经经过 Auth Basic Module 验证的用户名</li>
<li><code>$request_filename</code>  #当前连接请求的文件路径，由 root 或 alias 指令与 URI 请求生成</li>
<li><code>$request_body</code>  #这个变量（0.7.58+）包含请求的主要信息。在使用 proxy_pass 或 fastcgi_pass 指令的 location 中比较有意义</li>
<li><code>$request_body_file</code>  #客户端请求主体信息的临时文件名</li>
<li><code>$request_completion</code>  #如果请求成功，设为”OK”；如果请求未完成或者不是一系列请求中最后一部分则设为空</li>
<li><code>$request_method</code>  #这个变量是客户端请求的动作，通常为 GET 或 POST。包括 0.8.20 及之前的版本中，这个变量总为 main request 中的动作，如果当前请求是一个子请求，并不使用这个当前请求的动作</li>
<li><code>$request_uri</code>  #这个变量等于包含一些客户端请求参数的原始 URI，它无法修改，请查看 $uri 更改或重写 URI</li>
<li><code>$scheme</code>  #所用的协议，例如 http 或者是 https，例如 <code>rewrite ^(.+)$$scheme://example.com$1 redirect</code></li>
<li><code>$server_addr</code>  #服务器地址，在完成一次系统调用后可以确定这个值，如果要绕开系统调用，则必须在listen中指定地址并且使用bind参数</li>
<li><code>$server_name</code>  #服务器名称</li>
<li><code>$server_port</code>  #请求到达服务器的端口号</li>
<li><code>$server_protocol</code>  #请求使用的协议，通常是 HTTP/1.0、HTTP/1.1或HTTP/2</li>
<li><code>$uri</code>  #请求中的当前 URI(不带请求参数，参数位于 args ) ， 不 同 于 浏 览 器 传 递 的 args)，不同于浏览器传递的 args)，不同于浏览器传递的 request_uri 的值，它可以通过内部重定向，或者使用 index 指令进行修改。不包括协议和主机名，例如 /foo/bar.html</li>
</ul>
</blockquote>
</li>
</ul>
<hr>
<h1 id="附-nginx-模块"><a href="#附-nginx-模块" class="headerlink" title="附 nginx 模块"></a>附 nginx 模块</h1><h3 id="nginx-模块分类"><a href="#nginx-模块分类" class="headerlink" title="nginx 模块分类"></a>nginx 模块分类</h3><ul>
<li>nginx 模块分类<blockquote>
<ul>
<li>核心模块：nginx 最基本最核心的服务，如进程管理、权限控制、日志记录；</li>
<li>标准 HTTP 模块：nginx 服务器的标准 HTTP 功能；</li>
<li>可选 HTTP 模块：处理特殊的 HTTP 请求；</li>
<li>邮件服务模块：邮件服务；</li>
<li>第三方模块：作为扩展，完成特殊功能；</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="模块清单"><a href="#模块清单" class="headerlink" title="模块清单"></a>模块清单</h3><ul>
<li>模块清单<blockquote>
<ul>
<li>ngx_core</li>
<li>ngx_errlog</li>
<li>ngx_conf</li>
<li>ngx_events</li>
<li>ngx_event_core</li>
<li>ngx_epll</li>
<li>ngx_regex</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="标准-HTTP-模块"><a href="#标准-HTTP-模块" class="headerlink" title="标准 HTTP 模块"></a>标准 HTTP 模块</h3><ul>
<li>标准 HTTP 模块<blockquote>
<ul>
<li>ngx_http</li>
<li>ngx_http_core #配置端口，URI 分析，服务器相应错误处理，别名控制 (alias) 等</li>
<li>ngx_http_log #自定义 access 日志</li>
<li>ngx_http_upstream #定义一组服务器，可以接受来自 proxy, Fastcgi,Memcache 的重定向；主要用作负载均衡</li>
<li>ngx_http_static</li>
<li>ngx_http_autoindex #自动生成目录列表</li>
<li>ngx_http_index #处理以/结尾的请求，如果没有找到 index 页，则看是否开启了random_index；如开启，则用之，否则用 autoindex</li>
<li>ngx_http_auth_basic #基于 http 的身份认证 (auth_basic)</li>
<li>ngx_http_access #基于 IP 地址的访问控制 (deny,allow)</li>
<li>ngx_http_limit_conn #限制来自客户端的连接的响应和处理速率</li>
<li>ngx_http_limit_req #限制来自客户端的请求的响应和处理速率</li>
<li>ngx_http_geo</li>
<li>ngx_http_map #创建任意的键值对变量</li>
<li>ngx_http_split_clients</li>
<li>ngx_http_referer #过滤 HTTP 头中 Referer 为空的对象</li>
<li>ngx_http_rewrite #通过正则表达式重定向请求</li>
<li>ngx_http_proxy</li>
<li>ngx_http_fastcgi #支持 fastcgi</li>
<li>ngx_http_uwsgi</li>
<li>ngx_http_scgi</li>
<li>ngx_http_memcached</li>
<li>ngx_http_empty_gif #从内存创建一个 1×1 的透明 gif 图片，可以快速调用</li>
<li>ngx_http_browser #解析 http 请求头部的 User-Agent 值</li>
<li>ngx_http_charset #指定网页编码</li>
<li>ngx_http_upstream_ip_hash</li>
<li>ngx_http_upstream_least_conn</li>
<li>ngx_http_upstream_keepalive</li>
<li>ngx_http_write_filter</li>
<li>ngx_http_header_filter</li>
<li>ngx_http_chunked_filter</li>
<li>ngx_http_range_header</li>
<li>ngx_http_gzip_filter</li>
<li>ngx_http_postpone_filter</li>
<li>ngx_http_ssi_filter</li>
<li>ngx_http_charset_filter</li>
<li>ngx_http_userid_filter</li>
<li>ngx_http_headers_filter #设置 http 响应头</li>
<li>ngx_http_copy_filter</li>
<li>ngx_http_range_body_filter</li>
<li>ngx_http_not_modified_filter</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="可选-HTTP-模块"><a href="#可选-HTTP-模块" class="headerlink" title="可选 HTTP 模块"></a>可选 HTTP 模块</h3><ul>
<li>可选 HTTP 模块<blockquote>
<ul>
<li>ngx_http_addition #在响应请求的页面开始或者结尾添加文本信息</li>
<li>ngx_http_degradation #在低内存的情况下允许服务器返回 444 或者 204 错误</li>
<li>ngx_http_perl</li>
<li>ngx_http_flv #支持将 Flash 多媒体信息按照流文件传输，可以根据客户端指定的开始位置返回 Flash</li>
<li>ngx_http_geoip #支持解析基于 GeoIP 数据库的客户端请求</li>
<li>ngx_google_perftools</li>
<li>ngx_http_gzip #gzip 压缩请求的响应</li>
<li>ngx_http_gzip_static #搜索并使用预压缩的以.gz 为后缀的文件代替一般文件响应客户端请求</li>
<li>ngx_http_image_filter #支持改变 png，jpeg，gif 图片的尺寸和旋转方向</li>
<li>ngx_http_mp4 #支持.mp4,.m4v,.m4a 等多媒体信息按照流文件传输，常与 ngx_http_flv 一起使用</li>
<li>ngx_http_random_index #当收到 / 结尾的请求时，在指定目录下随机选择一个文件作为 index</li>
<li>ngx_http_secure_link #支持对请求链接的有效性检查</li>
<li>ngx_http_ssl #支持 https</li>
<li>ngx_http_stub_status</li>
<li>ngx_http_sub_module #使用指定的字符串替换响应中的信息</li>
<li>ngx_http_dav #支持 HTTP 和 WebDAV 协议中的 PUT/DELETE/MKCOL/COPY/MOVE 方法</li>
<li>ngx_http_xslt #将 XML 响应信息使用 XSLT 进行转换</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="邮件服务模块"><a href="#邮件服务模块" class="headerlink" title="邮件服务模块"></a>邮件服务模块</h3><ul>
<li>邮件服务模块<blockquote>
<ul>
<li>ngx_mail_core</li>
<li>ngx_mail_pop3</li>
<li>ngx_mail_imap</li>
<li>ngx_mail_smtp</li>
<li>ngx_mail_auth_http</li>
<li>ngx_mail_proxy</li>
<li>ngx_mail_ssl</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h3><ul>
<li>第三方模块<blockquote>
<ul>
<li>echo-nginx-module #支持在 nginx 配置文件中使用 echo/sleep/time/exec 等类 Shell 命令</li>
<li>memc-nginx-module</li>
<li>rds-json-nginx-module #使 nginx 支持 json 数据的处理</li>
<li>lua-nginx-module</li>
</ul>
</blockquote>
</li>
</ul>
</div><div><div style="text-align:center;color: #ccc;font-size:14px;font-family: cursive;">-------------&#x7EB8;&#x77ED;&#x60C5;&#x957F; <i class="fa fa-umbrella"></i> &#x4E0B;&#x6B21;&#x518D;&#x89C1;-------------</div></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">guolhuang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://huangguolong1314.github.io/2021/06/21/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%90%9E%E5%AE%9Anginx%E9%85%8D%E7%BD%AE/">https://huangguolong1314.github.io/2021/06/21/一篇文章搞定nginx配置/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://huangguolong1314.github.io" target="_blank">guolhuang</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/https/">https</a></div><div class="post_share"><div class="social-share" data-image="/images/posts/tu10.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><button class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="wechat" onclick="window.open('/img/wechat.jpg')"/><div class="post-qr-code__desc">wechat</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="alipay" onclick="window.open('/img/wechat.jpg')"/><div class="post-qr-code__desc">alipay</div></li></ul></div></button></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/02/09/mySql%E5%AD%A6%E4%B9%A0/"><img class="prev-cover" data-src="/images/mysql/mysql-logo.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySql学习 —— 子查询(where、from、exists) 及 连接查询(left join、right join、inner join、union join)</div></div></a></div><div class="next-post pull-right"><a href="/2020/09/02/docker-compose%E6%90%AD%E5%BB%BAMySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E9%9B%86%E7%BE%A4/"><img class="next-cover" data-src="/images/mysql/mysql-logo.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">docker-compose搭建MySQL主从复制集群</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/08/08/一个故事讲完https/" title="一个故事讲完https"><img class="relatedPosts_cover" data-src="/images/posts/tu10.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-08</div><div class="relatedPosts_title">一个故事讲完https</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail'],'false')

window.valine = new Valine({
  el:'#vcomment',
  appId: 'FlsfpLkCjk3itJM3iyTD9VWV-gzGzoHsz',
  appKey: 'F6NgK7UBaqIxKOBO22ikWQxL',
  placeholder: '記得留下你的暱稱和郵箱....可以快速收到回復',
  avatar: 'monsterid',
  meta: guestInfo,
  pageSize: '10',
  lang: 'zh-CN',
  recordIP: false,
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: "",
  enableQQ: true,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By guolhuang</div><div class="footer_custom_text">今日事,今日毕</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">繁</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fas fa-comments"></i></a><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/live2d-widget/autoload.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/search/local-search.js"></script></body></html>